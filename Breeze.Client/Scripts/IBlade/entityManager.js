define(["core", "config", "entityMetadata", "entityAspect", "entityQuery", "keyGenerator"],
function (core, a_config, m_entityMetadata, m_entityAspect, m_entityQuery, KeyGenerator) {
    "use strict";

    /**
    @module breeze
    **/
    var Enum = core.Enum;
    var Event = core.Event;
    var assertConfig = core.assertConfig;
    var assertParam = core.assertParam;

    var MetadataStore = m_entityMetadata.MetadataStore;
    var DataService = m_entityMetadata.DataService;
    var EntityType = m_entityMetadata.EntityType;
    var AutoGeneratedKeyType = m_entityMetadata.AutoGeneratedKeyType;
    var DataType = m_entityMetadata.DataType;
    
    
    var EntityAspect = m_entityAspect.EntityAspect;
    var EntityKey = m_entityAspect.EntityKey;
    var EntityState = m_entityAspect.EntityState;
    var EntityAction = m_entityAspect.EntityAction;

    var EntityQuery = m_entityQuery.EntityQuery;

    var Q = core.requireLib("Q", "see https://github.com/kriskowal/q");
    
    // TODO: think about dif between find and get.

    var EntityManager = (function () {
        /**
        Instances of the EntityManager contain and manage collections of entities, either retrieved from a backend datastore or created on the client. 
        @class EntityManager
        **/
        
        /** 
        @example                    
        At its most basic an EntityManager can be constructed with just a service name
        @example                    
            var entityManager = new EntityManager( "api/NorthwindIBModel");
        This is the same as calling it with the following configuration object
        @example                    
            var entityManager = new EntityManager( {serviceName: "api/NorthwindIBModel" });
        Usually however, configuration objects will contain more than just the 'serviceName';
        @example
            var metadataStore = new MetadataStore();
            var entityManager = new EntityManager( {
                serviceName: "api/NorthwindIBModel", 
                metadataStore: metadataStore 
            });
        or
        @example
            return new QueryOptions({ 
                mergeStrategy: obj, 
                fetchStrategy: this.fetchStrategy 
            });
            var queryOptions = new QueryOptions({ 
                mergeStrategy: MergeStrategy.OverwriteChanges, 
                fetchStrategy: FetchStrategy.FromServer 
            });
            var validationOptions = new ValidationOptions({ 
                validateOnAttach: true, 
                validateOnSave: true, 
                validateOnQuery: false
            });
            var entityManager = new EntityManager({ 
                serviceName: "api/NorthwindIBModel", 
                queryOptions: queryOptions, 
                validationOptions: validationOptions 
            });
        @method <ctor> EntityManager
        @param [config] {Object|String} Configuration settings or a service name.
        @param [config.serviceName] {String}
        @param [config.dataService] {DataService} An entire DataService (instead of just the serviceName above).
        @param [config.metadataStore=MetadataStore.defaultInstance] {MetadataStore}
        @param [config.queryOptions=QueryOptions.defaultInstance] {QueryOptions}
        @param [config.saveOptions=SaveOptions.defaultInstance] {SaveOptions}
        @param [config.validationOptions=ValidationOptions.defaultInstance] {ValidationOptions}
        @param [config.keyGeneratorCtor] {Function}
        **/
        var ctor = function (config) {
            
            if (arguments.length > 1) {
                throw new Error("The EntityManager ctor has a single optional argument that is either a 'serviceName' or a configuration object.");
            }
            if (arguments.length === 0) {
                config = { serviceName: "" };
            } else if (typeof config === 'string') {
                config = { serviceName: config };
            }
            
            assertConfig(config)
                .whereParam("serviceName").isOptional().isString()
                .whereParam("dataService").isOptional().isInstanceOf(DataService)
                .whereParam("metadataStore").isInstanceOf(MetadataStore).isOptional().withDefault(new MetadataStore())
                .whereParam("queryOptions").isInstanceOf(QueryOptions).isOptional().withDefault(QueryOptions.defaultInstance)
                .whereParam("saveOptions").isInstanceOf(SaveOptions).isOptional().withDefault(SaveOptions.defaultInstance)
                .whereParam("validationOptions").isInstanceOf(ValidationOptions).isOptional().withDefault(ValidationOptions.defaultInstance)
                .whereParam("keyGeneratorCtor").isFunction().isOptional().withDefault(KeyGenerator)
                .applyAll(this);

            if (config.dataService) {
                this.dataServiceAdapterInstance = a_config.getAdapterInstance("dataService", config.dataService.adapterName);
            } else if (config.serviceName) {
                this.dataServiceAdapterInstance = a_config.getAdapterInstance("dataService");
                this.dataService = new DataService({
                    serviceName: this.serviceName,
                });
            } 

            if (this.dataService) {
                this.serviceName = this.dataService.serviceName;
            }
            this.entityChanged = new Event("entityChanged_entityManager", this);
            this.hasChanges = new Event("hasChanges_entityManager", this, null, function (entityTypes) {
                if (!this._hasChanges) return false;
                if (entityTypes === undefined) return this._hasChanges;
                return this._hasChangesCore(entityTypes);
            });
            
            this.clear();
            
        };
        ctor.prototype._$typeName = "EntityManager";
        

        Event.bubbleEvent(ctor.prototype, null);
        
        /**
        The service name associated with this EntityManager.

        __readOnly__
        @property serviceName {String}
        **/
        
        /**
        The DataService name associated with this EntityManager.

        __readOnly__
        @property dataService {DataService}
        **/

        /**
        The {{#crossLink "MetadataStore"}}{{/crossLink}} associated with this EntityManager. 

         __readOnly__         
        @property metadataStore {MetadataStore}
        **/

        /**
        The {{#crossLink "QueryOptions"}}{{/crossLink}} associated with this EntityManager.

        __readOnly__
        @property queryOptions {QueryOptions}
        **/

        /**
        The {{#crossLink "SaveOptions"}}{{/crossLink}} associated with this EntityManager.

        __readOnly__
        @property saveOptions {SaveOptions}
        **/

        /**
        The {{#crossLink "ValidationOptions"}}{{/crossLink}} associated with this EntityManager.

        __readOnly__
        @property validationOptions {ValidationOptions}
        **/

        /**
        The {{#crossLink "KeyGenerator"}}{{/crossLink}} constructor associated with this EntityManager.

        __readOnly__
        @property keyGeneratorCtor {KeyGenerator constructor}
        **/

        /**
        The "dataService" adapter implementation instance associated with this EntityManager.

        __readOnly__
        @property dataServiceAdapterInstance {an instance of the "dataService" adapter interface}
        **/
       
        // events
        /**
        An {{#crossLink "Event"}}{{/crossLink}} that fires whenever a change to any entity in this EntityManager occurs.
        @example                    
            var em = new EntityManager( {serviceName: "api/NorthwindIBModel" });
            em.entityChanged.subscribe(function(changeArgs) {
                // This code will be executed any time any entity within the entityManager is added, modified, deleted or detached for any reason. 
                var action = changeArgs.entityAction;
                var entity = changeArgs.entity;
                // .. do something to this entity when it is changed.
            });
        });
        
        @event entityChanged 
        @param entityAction {EntityAction} The {{#crossLink "EntityAction"}}{{/crossLink}} that occured. 
        @param entity {Object} The entity that changed.  If this is null, then all entities in the entityManager were affected. 
        @param args {Object} Additional information about this event. This will differ based on the entityAction.
        @readOnly
        **/

        // class methods 

        /**
        Creates a new EntityManager and imports a previously exported result into it.
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities.
            var bundle = em1.exportEntities();
            // can be stored via the web storage api
            window.localStorage.setItem("myEntityManager", bundle);
            // assume the code below occurs in a different session.
            var bundleFromStorage = window.localStorage.getItem("myEntityManager");
            // and imported
            var em2 = EntityManager.importEntities(bundleFromStorage);
            // em2 will now have a complete copy of what was in em1
        @method importEntities
        @static
        @param exportedString {String} The result of a previous 'exportEntities' call.
        @param [config] {Object} A configuration object.
        @param [config.mergeStrategy] {MergeStrategy} A  {{#crossLink "MergeStrategy"}}{{/crossLink}} to use when 
        merging into an existing EntityManager.
        @return {EntityManager} A new EntityManager.
        **/
        ctor.importEntities = function (exportedString, config) {
            var em = new EntityManager();
            em.importEntities(exportedString, config);
            return em;
        };

        // instance methods

        /**
        Exports an entire EntityManager or just selected entities into a serialized string for external storage.
        @example
        This method can be used to take a snapshot of an EntityManager that can be either stored offline or held 
        memory.  This snapshot can be restored or merged into an another EntityManager at some later date. 
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var bundle = em1.exportEntities();
            // can be stored via the web storage api
            window.localStorage.setItem("myEntityManager", bundle);
            // assume the code below occurs in a different session.
            var bundleFromStorage = window.localStorage.getItem("myEntityManager");
            var em2 = new EntityManager({ 
                serviceName: em1.serviceName, 
                metadataStore: em1.metadataStore 
            });
            em2.importEntities(bundleFromStorage);
            // em2 will now have a complete copy of what was in em1
        You can also control exactly which entities are exported. 
        @example
            // assume entitiesToExport is an array of entities to export.
            var bundle = em1.exportEntities(entitiesToExport);
            // assume em2 is another entityManager containing some of the same entities possibly with modifications.
            em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );
        @method exportEntities
        @param [entities] {Array of entities} The entities to export; all entities are exported if this is omitted.
        @return {String} A serialized version of the exported data.
        **/
        ctor.prototype.exportEntities = function (entities) {
            var exportBundle = exportEntityGroups(this, entities);
            var json = {
                metadataStore: this.metadataStore.exportMetadata(),
                serviceName: this.serviceName,
                saveOptions: this.saveOptions,
                queryOptions: this.queryOptions,
                validationOptions: this.validationOptions,
                tempKeys: exportBundle.tempKeys,
                entityGroupMap: exportBundle.entityGroupMap
            };
            var result = JSON.stringify(json, null, a_config.stringifyPad);
            return result;
        };

        /**
        Imports a previously exported result into this EntityManager.
        @example
        This method can be used to make a complete copy of any previously created entityManager, even if created
        in a previous session and stored in localStorage. The static version of this method performs a
        very similar process. 
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var bundle = em1.exportEntities();
            // bundle can be stored in window.localStorage or just held in memory.
            var em2 = new EntityManager({ 
                serviceName: em1.serviceName, 
                metadataStore: em1.metadataStore 
            });
            em2.importEntities(bundle);
            // em2 will now have a complete copy of what was in em1
        It can also be used to merge the contents of a previously created EntityManager with an 
        existing EntityManager with control over how the two are merged.
        @example
            var bundle = em1.exportEntities();
            // assume em2 is another entityManager containing some of the same entities possibly with modifications.
            em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );
            // em2 will now contain all of the entities from both em1 and em2.  Any em2 entities with previously 
            // made modifications will not have been touched, but all other entities from em1 will have been imported.
        @method importEntities
        @param exportedString {String} The result of a previous 'export' call.
        @param [config] {Object} A configuration object.
            @param [config.mergeStrategy] {MergeStrategy} A  {{#crossLink "MergeStrategy"}}{{/crossLink}} to use when 
            merging into an existing EntityManager.
        @chainable
        **/
        ctor.prototype.importEntities = function (exportedString, config) {
            config = config || {};
            assertConfig(config)
                .whereParam("mergeStrategy").isEnumOf(MergeStrategy).isOptional().withDefault(this.queryOptions.mergeStrategy)
                .applyAll(config);
            var that = this;
            
            var json = JSON.parse(exportedString);
            this.metadataStore.importMetadata(json.metadataStore);
            this.serviceName = json.serviceName;
            this.saveOptions = new SaveOptions(json.saveOptions);
            this.queryOptions = QueryOptions.fromJSON(json.queryOptions);
            this.validationOptions = new ValidationOptions(json.validationOptions);

            var tempKeyMap = {};
            json.tempKeys.forEach(function (k) {
                var oldKey = EntityKey.fromJSON(k, that.metadataStore);
                tempKeyMap[oldKey.toString()] = that.keyGenerator.generateTempKeyValue(oldKey.entityType);
            });
            config.tempKeyMap = tempKeyMap;
            core.wrapExecution(function() {
                that._pendingPubs = [];
            }, function(state) {
                that._pendingPubs.forEach(function(fn) { fn(); });
                that._pendingPubs = null;
            }, function() {
                core.objectForEach(json.entityGroupMap, function(entityTypeName, jsonGroup) {
                    var entityType = that.metadataStore.getEntityType(entityTypeName, true);
                    var targetEntityGroup = findOrCreateEntityGroup(that, entityType);
                    importEntityGroup(targetEntityGroup, jsonGroup, config);
                });
            });
            return this;
        };

        /**
        Clears this EntityManager's cache but keeps all other settings. Note that this 
        method is not as fast as creating a new EntityManager via 'new EntityManager'.
        This is because clear actually detaches all of the entities from the EntityManager.
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            em1.clear();
            // em1 is will now contain no entities, but all other setting will be maintained.
        @method clear
        **/
        ctor.prototype.clear = function () {
            core.objectForEach(this._entityGroupMap, function (key, entityGroup) {
                // remove en
                entityGroup._clear();
            });
            this._entityGroupMap = {};
            this._unattachedChildrenMap = new UnattachedChildrenMap();
            this.keyGenerator = new this.keyGeneratorCtor();
            this.entityChanged.publish({ entityAction: EntityAction.Clear });
            if (this._hasChanges) {
                this._hasChanges = false;
                this.hasChanges.publish({ entityManager: this, hasChanges: false });
            }
        };

        /**
        General purpose property set method.  Any of the properties documented below 
        may be set.
        @example
             // assume em1 is a previously created EntityManager
             // where we want to change some of its settings.
             em1.setProperties( {
                serviceName: "api/foo",
                });
        @method setProperties
        @param config {Object}
            @param [config.serviceName] {String}
            @param [config.dataService] {DataService}
            @param [config.queryOptions] {QueryOptions}
            @param [config.saveOptions] {SaveOptions}
            @param [config.validationOptions] {ValidationOptions}
            @param [config.keyGeneratorCtor] {Function}

        **/
        ctor.prototype.setProperties = function (config) {
            assertConfig(config)
                .whereParam("serviceName").isString().isOptional()
                .whereParam("dataService").isInstanceOf(DataService).isOptional()
                .whereParam("queryOptions").isInstanceOf(QueryOptions).isOptional()
                .whereParam("saveOptions").isInstanceOf(SaveOptions).isOptional()
                .whereParam("validationOptions").isInstanceOf(ValidationOptions).isOptional()
                .whereParam("keyGeneratorCtor").isOptional()
             .applyAll(this);
            
            if (config.dataService) {
                this.dataServiceAdapterInstance = getAdapterInstance("dataService", this.dataService.adapterName);
                this.serviceName = this.dataService.serviceName;
            } else if (config.serviceName) {
                this.dataService = new DataService({
                    serviceName: this.serviceName,
                });
                this.serviceName = this.dataService.serviceName;
            }
            
            if (config.keyGeneratorCtor) {
                this.keyGenerator = new this.keyGeneratorCtor();
            }
            
        };

        /**
        Creates an empty copy of this EntityManager
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var em2 = em1.createEmptyCopy();
            // em2 is a new EntityManager with all of em1's settings
            // but no entities.
        @method createEmptyCopy
        @return {EntityManager} A new EntityManager.
        **/
        ctor.prototype.createEmptyCopy = function () {
            var copy = new ctor({
                serviceName: this.serviceName,
                metadataStore: this.metadataStore,
                queryOptions: this.queryOptions,
                adapters: core.extend({}, this.adapters),
                keyGeneratorCtor: this.keyGeneratorCtor
            });
            return copy;
        };

        /**
        Attaches an entity to this EntityManager with an  {{#crossLink "EntityState"}}{{/crossLink}} of 'Added'.
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var custType = em1.metadataStore.getEntityType("Customer");
            var cust1 = custType.createEntity();
            em1.addEntity(cust1);
        Note that this is the same as using 'attachEntity' with an {{#crossLink "EntityState"}}{{/crossLink}} of 'Added'.
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var custType = em1.metadataStore.getEntityType("Customer");
            var cust1 = custType.createEntity();
            em1.attachEntity(cust1, EntityState.Added);
        @method addEntity
        @param entity {Entity} The entity to add.
        @return {Entity} The added entity.
        **/
        ctor.prototype.addEntity = function (entity) {
            return this.attachEntity(entity, EntityState.Added);
        };

        /**
        Attaches an entity to this EntityManager with a specified {{#crossLink "EntityState"}}{{/crossLink}}.
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            var custType = em1.metadataStore.getEntityType("Customer");
            var cust1 = custType.createEntity();
            em1.attachEntity(cust1, EntityState.Added);
        @method attachEntity
        @param entity {Entity} The entity to add.
        @param [entityState] {EntityState} The EntityState of the newly attached entity. If omitted this defaults to EntityState.Unchanged.
        @return {Entity} The attached entity.
        **/
        ctor.prototype.attachEntity = function (entity, entityState) {
            core.assertParam(entity, "entity").isRequired().check();
            this.metadataStore._checkEntityType(entity);
            entityState = core.assertParam(entityState, "entityState").isEnumOf(EntityState).isOptional().check(EntityState.Unchanged);

            if (entity.entityType.metadataStore != this.metadataStore) {
                throw new Error("Cannot attach this entity because the EntityType and MetadataStore associated with this entity does not match this EntityManager's MetadataStore.");
            }
            var aspect = new EntityAspect(entity);
            var manager = aspect.entityManager;
            if (manager) {
                if (manager == this) {
                    return entity;
                } else {
                    throw new Error("This entity already belongs to another EntityManager");
                }
            }
            
            var that = this;
            core.using(this, "isLoading", true, function () {
                checkEntityKey(that, entity);
                attachEntityCore(that, entity, entityState);
                attachRelatedEntities(that, entity, entityState);
            });
            if (this.validationOptions.validateOnAttach) {
                entity.entityAspect.validateEntity();
            }
            if (!entityState.isUnchanged()) {
                this._notifyStateChange(entity, true);
            }
            this.entityChanged.publish({ entityAction: EntityAction.Attach, entity: entity });

            return entity;
        };
        
        

        /**
        Detaches an entity from this EntityManager.
        @example
            // assume em1 is an EntityManager containing a number of existing entities.
            // assume cust1 is a customer Entity previously attached to em1
            em1.detachEntity(cust1);
            // em1 will now no longer contain cust1 and cust1 will have an 
            // entityAspect.entityState of EntityState.Detached
        @method detachEntity
        @param entity {Entity} The entity to detach.
        @return {Boolean} Whether the entity could be detached. This will return false if the entity is already detached or was never attached.
        **/
        ctor.prototype.detachEntity = function (entity) {
            core.assertParam(entity, "entity").isEntity().check();
            var aspect = entity.entityAspect;
            if (!aspect) {
                // no aspect means in couldn't appear in any group
                return false;
            }
            var group = aspect.entityGroup;
            if (!group) {
                // no group === already detached.
                return false;
            }
            if (group.entityManager !== this) {
                throw new Error("This entity does not belong to this EntityManager.");
            }
            group.detachEntity(entity);
            aspect._removeFromRelations();
            this.entityChanged.publish({ entityAction: EntityAction.Detach, entity: entity });
            return true;
        };

        /**
        Fetches the metadata associated with the EntityManager's current 'serviceName'.  This call
        occurs internally before the first query to any service if the metadata hasn't already been
        loaded.
        @example
        Usually you will not actually process the results of a fetchMetadata call directly, but will instead
        ask for the metadata from the EntityManager after the fetchMetadata call returns.
        @example
             var em1 = new EntityManager( "api/NorthwindIBModel");
             em1.fetchMetadata()
                .then(function() {
                    var metadataStore = em1.metadataStore;
                    // do something with the metadata
                }
                .fail(function(exception) {
                    // handle exception here
                };
        @method fetchMetadata
        @async
        @param [callback] {Function} Function called on success.
        
            successFunction([schema])
            @param [callback.schema] {Object} The raw Schema object from metadata provider - Because this schema will differ depending on the metadata provider
            it is usually better to access metadata via the 'metadataStore' property of the EntityManager after this method's Promise or callback completes.
        @param [errorCallback] {Function} Function called on failure.
            
            failureFunction([error])
            @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.
        @return {Promise} Promise 
        **/
        ctor.prototype.fetchMetadata = function (callback, errorCallback) {
            core.assertParam(callback, "callback").isFunction().isOptional().check();
            core.assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();

            var promise = this.metadataStore.fetchMetadata(this.dataService);

            // TODO: WARNING: DO NOT LEAVE THIS CODE IN PRODUCTION.
            // TEST::: see if serialization actually works completely
//            var that = this;
//            promise = promise.then(function () {
//                var stringified = that.metadataStore.exportMetadata();
//                that.metadataStore = new MetadataStore();
//                that.metadataStore.importMetadata(stringified);
//            });

            return promiseWithCallbacks(promise, callback, errorCallback);
        };

        /**
        Executes the specified query.
        @example
        This method can be called using a 'promises' syntax ( recommended)
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery("Orders");
             em.executeQuery(query)
               .then( function(data) {
                   var orders = data.results;
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
        or with callbacks
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery("Orders");
             em.executeQuery(query,
                function(data) {
                   var orders = data.results;
                   ... query results processed here
                },
                function(err) {
                   ... query failure processed here
                });
        Either way this method is the same as calling the The {{#crossLink "EntityQuery"}}{{/crossLink}} 'execute' method.
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery("Orders").using(em);
             query.execute()
               .then( function(data) {
                   var orders = data.results;
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
         
        @method executeQuery
        @async
        @param query {EntityQuery|String}  The {{#crossLink "EntityQuery"}}{{/crossLink}} or OData query string to execute.
        @param [callback] {Function} Function called on success.
        
            successFunction([data])
            @param callback.data {Object} 
            @param callback.data.results {Array of Entity}
            @param callback.data.query {EntityQuery} The original query
            @param callback.data.XHR {XMLHttpRequest} The raw XMLHttpRequest returned from the server.

        @param [errorCallback] {Function} Function called on failure.
            
            failureFunction([error])
            @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.
            @param [errorCallback.error.query] The query that caused the error.
            @param [errorCallback.error.XHR] {XMLHttpRequest} The raw XMLHttpRequest returned from the server.

        @return {Promise} Promise
        **/
        ctor.prototype.executeQuery = function (query, callback, errorCallback) {
            // TODO: think about creating an executeOdataQuery or executeRawOdataQuery as a seperate method.
            core.assertParam(query, "query").isInstanceOf(EntityQuery).or().isString().check();
            core.assertParam(callback, "callback").isFunction().isOptional().check();
            core.assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
            var promise;
            if (this.metadataStore.hasMetadataFor(this.serviceName)) {
                promise = executeQueryCore(this, query);
            } else {
                var that = this;
                promise = this.fetchMetadata().then(function () {
                    return executeQueryCore(that, query);
                }).fail(function (error) {
                    return Q.reject(error);
                });
            }
            return promiseWithCallbacks(promise, callback, errorCallback);
        };

        /**
        Executes the specified query against this EntityManager's local cache.

        @example
        Because this method is executed immediately there is no need for a promise or a callback
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery("Orders");
             var orders = em.executeQueryLocally(query);
        Note that this can also be accomplished using the 'executeQuery' method with
        a FetchStrategy of FromLocalCache and making use of the Promise or callback
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery("Orders").using(FetchStrategy.FromLocalCache);
             em.executeQuery(query)
               .then( function(data) {
                   var orders = data.results;
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
        @method executeQueryLocally
        @param query {EntityQuery}  The {{#crossLink "EntityQuery"}}{{/crossLink}} to execute.
        @return  {Array of Entity}  Array of Entities
        **/
        ctor.prototype.executeQueryLocally = function (query) {
            core.assertParam(query, "query").isInstanceOf(EntityQuery).check();
            var result;
            var metadataStore = this.metadataStore;
            var entityType = query._getEntityType(metadataStore, true);
            // TODO: there may be multiple groups once we go further with inheritence
            var group = findOrCreateEntityGroup(this, entityType);
            // filter then order then skip then take
            var filterFunc = query._toFilterFunction(entityType);
        
            if (filterFunc) {
                var undeletedFilterFunc = function(entity) {
                    return ((!entity.entityAspect.entityState.isDeleted()) && filterFunc(entity));
                };
                result = group._entities.filter(undeletedFilterFunc);
            } else {
                result = group._entities.filter(function(entity) {
                    return !entity.entityAspect.entityState.isDeleted();
                });
            }
            
            var orderByComparer = query._toOrderByComparer(entityType);
            if (orderByComparer) {
                result.sort(orderByComparer);
            }
            var skipCount = query.skipCount;
            if (skipCount) {
                result = result.slice(skipCount);
            }
            var takeCount = query.takeCount;
            if (takeCount) {
                result = result.slice(0, takeCount);
            }
            return result;
        };

        /**
        Saves either a list of specified entities or all changed entities within this EntityManager. If there are no changes to any of the entities
        specified then there will be no server side call made but a valid 'empty' saveResult will still be returned.
        @example
        Often we will be saving all of the entities within an EntityManager that are either added, modified or deleted
        and we will let the 'saveChanges' call determine which entities these are. 
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            // This could include added, modified and deleted entities.
            em.saveChanges().then(function(saveResult) {
                var savedEntities = saveResult.entities;
                var keyMappings = saveResult.keyMappings;
            }).fail(function (e) {
                // e is any exception that was thrown.
            });
        But we can also control exactly which entities to save and can specify specific SaveOptions
        @example
            // assume entitiesToSave is an array of entities to save.
            var saveOptions = new SaveOptions({ allowConcurrentSaves: true });
            em.saveChanges(entitiesToSave, saveOptions).then(function(saveResult) {
                var savedEntities = saveResult.entities;
                var keyMappings = saveResult.keyMappings;
            }).fail(function (e) {
                // e is any exception that was thrown.
            });
        Callback methods can also be used
        @example
            em.saveChanges(entitiesToSave, null, 
                function(saveResult) {
                    var savedEntities = saveResult.entities;
                    var keyMappings = saveResult.keyMappings;
                }, function (e) {
                    // e is any exception that was thrown.
                }
            );
        @method saveChanges
        @async
        @param [entities] {Array of Entity} The list of entities to save.  All entities with changes 
        within this EntityManager will be saved if this parameter is omitted, null or empty.
        @param [saveOptions] {SaveOptions} {{#crossLink "SaveOptions"}}{{/crossLink}} for the save - will default to
        {{#crossLink "EntityManager/saveOptions"}}{{/crossLink}} if null.
        @param [callback] {Function} Function called on success.
        
            successFunction([saveResult])
            @param [callback.saveResult] {Object} 
            @param [callback.saveResult.entities] {Array of Entity} The saved entities - with any temporary keys converted into 'real' keys.  
            These entities are actually references to entities in the EntityManager cache that have been updated as a result of the
            save.
            @param [callback.saveResult.keyMappings] {Object} Map of OriginalEntityKey, NewEntityKey
            @param [callback.saveResult.XHR] {XMLHttpRequest} The raw XMLHttpRequest returned from the server.

        @param [errorCallback] {Function} Function called on failure.
            
            failureFunction([error])
            @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.
            @param [errorCallback.error.XHR] {XMLHttpRequest} The raw XMLHttpRequest returned from the server.
        @return {Promise} Promise
        **/
        ctor.prototype.saveChanges = function (entities, saveOptions, callback, errorCallback) {
            core.assertParam(entities, "entities").isOptional().isArray().isEntity().check();
            core.assertParam(saveOptions, "saveOptions").isInstanceOf(SaveOptions).isOptional().check();
            core.assertParam(callback, "callback").isFunction().isOptional().check();
            core.assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
            
            saveOptions = saveOptions || this.saveOptions || SaveOptions.defaultInstance;
            var isFullSave = entities == null;
            var entitiesToSave = getEntitiesToSave(this, entities);
            
            if (entitiesToSave.length == 0) {
                var saveResult =  { entities: [], keyMappings: [] };
                if (callback) callback(saveResult);
                return Q.resolve(saveResult);
            }
            
            if (!saveOptions.allowConcurrentSaves) {
                var anyPendingSaves = entitiesToSave.some(function (entity) {
                    return entity.entityAspect.isBeingSaved;
                });                
                if (anyPendingSaves) {
                    var err = new Error("ConcurrentSaves not allowed - SaveOptions.allowConcurrentSaves is false");
                    if (errorCallback) errorCallback(err);
                    return Q.reject(err);
                }
            }
            
            if (this.validationOptions.validateOnSave) {
                var failedEntities = entitiesToSave.filter(function (entity) {
                    var aspect = entity.entityAspect;
                    var isValid = aspect.entityState.isDeleted() || aspect.validateEntity();
                    return !isValid;
                });
                if (failedEntities.length > 0) {
                    var valError = new Error("Validation error");
                    valError.entitiesWithErrors = failedEntities;
                    if (errorCallback) errorCallback(valError);
                    return Q.reject(valError);
                }
            }
            
            updateConcurrencyProperties(entitiesToSave);

            // TODO: need to check that if we are doing a partial save that all entities whose temp keys 
            // are referenced are also in the partial save group

            var saveBundle = { entities: unwrapEntities(entitiesToSave, this.metadataStore), saveOptions: saveOptions};
            var saveBundleStringified = JSON.stringify(saveBundle);

            var deferred = Q.defer();
            this.dataServiceAdapterInstance.saveChanges(this, saveBundleStringified, deferred.resolve, deferred.reject);
            var that = this;
            return deferred.promise.then(function (rawSaveResult) {
                // HACK: simply to change the 'case' of properties in the saveResult
                // but KeyMapping properties are still ucase. ugh...
                var saveResult = { entities: rawSaveResult.Entities, keyMappings: rawSaveResult.KeyMappings, XHR: rawSaveResult.XHR };
                fixupKeys(that, saveResult.keyMappings);
                var queryContext = { query: null, entityManager: that, mergeStrategy: MergeStrategy.OverwriteChanges, refMap: {} };
                var savedEntities = saveResult.entities.map(function (rawEntity) {
                    return mergeEntity(rawEntity, queryContext, true);
                });
                markIsBeingSaved(entitiesToSave, false);
                // update _hasChanges after save.
                that._hasChanges = isFullSave ? false : that._hasChangesCore(); 
                saveResult.entities = savedEntities;
                if (callback) callback(saveResult);
                return Q.resolve(saveResult);
            }, function (error) {
                markIsBeingSaved(entitiesToSave, false);
                if (errorCallback) errorCallback(error);
                return Q.reject(error);
            });

        };

        // TODO: make this internal - no good reason to expose the EntityGroup to the external api yet.
        ctor.prototype.findEntityGroup = function (entityType) {
            core.assertParam(entityType, "entityType").isInstanceOf(EntityType).check();
            return this._entityGroupMap[entityType.name];
        };

        /**
        Attempts to locate an entity within this EntityManager by its  {{#crossLink "EntityKey"}}{{/crossLink}}.
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var employeeType = em1.metadataStore.getEntityType("Employee");
            var employeeKey = new EntityKey(employeeType, 1);
            var employee = em1.findEntityByKey(employeeKey);
            // employee will either be an entity or null.
        @method findEntityByKey
        @param entityKey {EntityKey} The  {{#crossLink "EntityKey"}}{{/crossLink}} of the Entity to be located.
        @return {Entity} An Entity or null;
        **/
        ctor.prototype.findEntityByKey = function (entityKey) {
            core.assertParam(entityKey, "entityKey").isInstanceOf(EntityKey).check();
            var group = this.findEntityGroup(entityKey.entityType);
            if (!group) {
                return null;
            }
            return group.findEntityByKey(entityKey);
        };

        /**
        Generates a temporary key for the specified entity.  This is used to insure that newly
        created entities have unique keys and to register that these keys are temporary and
        need to be automatically replaced with 'real' key values once these entities are saved.

        The EntityManager.keyGeneratorCtor property is used internally by this method to actually generate
        the keys - See the  {{#crossLink "~keyGenerator-interface"}}{{/crossLink}} interface description to see
        how a custom key generator can be plugged in.
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var custumer = custType.createEntity();
            var customerId = em.generateTempKeyValue(custumer);
            // The 'customer' entity 'CustomerID' property is now set to a newly generated unique id value
            // This property will change again after a successful save of the 'customer' entity.

            em1.saveChanges()
                .then( function( data) {
                    var sameCust1 = data.results[0];
                    // cust1 === sameCust1;
                    // but cust1.getProperty("CustomerId") != customerId
                    // because the server will have generated a new id 
                    // and the client will have been updated with this 
                    // new id.
                })

        @method generateTempKeyValue
        @param entity {Entity} The Entity to generate a key for.
        @return {Object} The new key value
        **/
        ctor.prototype.generateTempKeyValue = function (entity) {
            // TODO - check if this entity is attached to this EntityManager.
            core.assertParam(entity, "entity").isEntity().check();
            var entityType = entity.entityType;
            var nextKeyValue = this.keyGenerator.generateTempKeyValue(entityType);
            var keyProp = entityType.keyProperties[0];
            entity.setProperty(keyProp.name, nextKeyValue);
            entity.entityAspect.hasTempKey = true;
            return nextKeyValue;
        };
        
        /**
        Returns whether there are any changed entities of the specified {{#crossLink "EntityType"}}{{/crossLink}}s. A 'changed' Entity has
        has an {{#crossLink "EntityState"}}{{/crossLink}} of either Added, Modified or Deleted.
        @example
        This method can be used to determine if an EntityManager has any changes
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            if ( em1.hasChanges() {
               // do something interesting
            }
        or if it has any changes on to a specific {{#crossLink "EntityType"}}{{/crossLink}}
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            if ( em1.hasChanges(custType) {
               // do something interesting
            }
        or to a collection of {{#crossLink "EntityType"}}{{/crossLink}}s
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var orderType = em1.metadataStore.getEntityType("Order");
            if ( em1.hasChanges( [custType, orderType]) {
               // do something interesting
            }
        @method hasChanges
        @param [entityTypes] {EntityType|Array of EntityType} The {{#crossLink "EntityType"}}{{/crossLink}}s for which 'changed' entities will be found.
        If this parameter is omitted, all EntityTypes are searched.
        @return {Boolean} Whether there were any changed entities.
        **/
        //ctor.prototype.hasChanges = function (entityTypes) {
        //    if (!this._hasChanges) return false;
        //    if (entityTypes === undefined) return this._hasChanges;
        //    return this._hasChangesCore(entityTypes);
        //};
        
        /**
        An {{#crossLink "Event"}}{{/crossLink}} that fires whenever an EntityManager transitions to or from having changes. 
        @example                    
            var em = new EntityManager( {serviceName: "api/NorthwindIBModel" });
            em.hasChanges.subscribe(function(args) {
                var hasChanges = args.hasChanges;
                var entityManager = args.entityManager;
            });
        });
      
        @event hasChanges 
        @param entityManager {EntityManager} The EntityManager whose 'hasChanges' status has changed. 
        @param hasChanges {Boolean} Whether or not this EntityManager has changes.
        @readOnly
        **/
        
        
        // backdoor the "really" check for changes.
        ctor.prototype._hasChangesCore = function (entityTypes) {
            core.assertParam(entityTypes, "entityTypes").isOptional().isInstanceOf(EntityType).or().isNonEmptyArray().isInstanceOf(EntityType).check();
            var entityGroups = getEntityGroups(this, entityTypes);
            return entityGroups.some(function (eg) {
                return eg.hasChanges();
            });
        }
        
        /**
        Returns a array of all changed entities of the specified {{#crossLink "EntityType"}}{{/crossLink}}s. A 'changed' Entity has
        has an {{#crossLink "EntityState"}}{{/crossLink}} of either Added, Modified or Deleted.
        @example
        This method can be used to get all of the changed entities within an EntityManager
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var changedEntities = em1.getChanges();
        or you can specify that you only want the changes on a specific {{#crossLink "EntityType"}}{{/crossLink}}
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var changedCustomers = em1.getChanges(custType);
        or to a collection of {{#crossLink "EntityType"}}{{/crossLink}}s
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var orderType = em1.metadataStore.getEntityType("Order");
            var changedCustomersAndOrders = em1.getChanges([custType, orderType]);
        @method getChanges
        @param [entityTypes] {EntityType|Array of EntityType} The {{#crossLink "EntityType"}}{{/crossLink}}s for which 'changed' entities will be found.
        If this parameter is omitted, all EntityTypes are searched.
        @return {Array of Entity} Array of Entities
        **/
        ctor.prototype.getChanges = function (entityTypes) {
            core.assertParam(entityTypes, "entityTypes").isOptional().isInstanceOf(EntityType).or().isNonEmptyArray().isInstanceOf(EntityType).check();
            var entityStates = [EntityState.Added, EntityState.Modified, EntityState.Deleted];
            return this._getEntitiesCore(entityTypes, entityStates);
        };

        /**
        Rejects (reverses the effects) all of the additions, modifications and deletes from this EntityManager.
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities.
            var entities = em1.rejectChanges();
        
        @method rejectChanges
        @return {Array of Entity} The entities whose changes were rejected. These entities will all have EntityStates of 
        either 'Unchanged' or 'Detached'
        **/
        ctor.prototype.rejectChanges = function () {
            if (!this._hasChanges) return [];
            var entityStates = [EntityState.Added, EntityState.Modified, EntityState.Deleted];
            var changes = this._getEntitiesCore(null, entityStates);
            // next line stops individual reject changes from each calling _hasChangesCore
            this._hasChanges = false;
            changes.forEach(function(e) {
                e.entityAspect.rejectChanges();
            });
            this.hasChanges.publish({ entityManager: this, hasChanges: false });
            return changes;
        };
        
        /**
        Returns a array of all entities of the specified {{#crossLink "EntityType"}}{{/crossLink}}s with the specified {{#crossLink "EntityState"}}{{/crossLink}}s. 
        @example
        This method can be used to get all of the entities within an EntityManager
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var entities = em1.getEntities();
        or you can specify that you only want the changes on a specific {{#crossLink "EntityType"}}{{/crossLink}}
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var customers = em1.getEntities(custType);
        or to a collection of {{#crossLink "EntityType"}}{{/crossLink}}s
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var orderType = em1.metadataStore.getEntityType("Order");
            var customersAndOrders = em1.getChanges([custType, orderType]);
        You can also ask for entities with a particular {{#crossLink "EntityState"}}{{/crossLink}} or EntityStates.
        @example
            // assume em1 is an EntityManager containing a number of preexisting entities. 
            var custType = em1.metadataStore.getEntityType("Customer");
            var orderType = em1.metadataStore.getEntityType("Order");
            var addedCustomersAndOrders = em1.getEntities([custType, orderType], EntityState.Added);
        @method getEntities
        @param [entityTypes] {EntityType|Array of EntityType} The {{#crossLink "EntityType"}}{{/crossLink}}s for which entities will be found.
        If this parameter is omitted, all EntityTypes are searched.
        @param [entityState] {EntityState|Array of EntityState} The {{#crossLink "EntityState"}}{{/crossLink}}s for which entities will be found.
        If this parameter is omitted, entities of all EntityStates are returned.
        @return {Array of Entity} Array of Entities
        **/
        ctor.prototype.getEntities = function (entityTypes, entityStates) {
            core.assertParam(entityTypes, "entityTypes").isOptional().isInstanceOf(EntityType).or().isNonEmptyArray().isInstanceOf(EntityType).check();
            core.assertParam(entityStates, "entityStates").isOptional().isEnumOf(EntityState).or().isNonEmptyArray().isEnumOf(EntityState).check();
            if (entityStates) {
                entityStates = validateEntityStates(this, entityStates);
            }
            return this._getEntitiesCore(entityTypes, entityStates);
        };

        // protected methods

        ctor.prototype._notifyStateChange = function (entity, needsSave) {
            this.entityChanged.publish({ entityAction: EntityAction.EntityStateChange, entity: entity });

            if (needsSave) {
                if (!this._hasChanges) {
                    this._hasChanges = true;
                    this.hasChanges.publish({ entityManager: this, hasChanges: true });
                }
            } else {
                // called when rejecting a change or merging an unchanged record.
                if (this._hasChanges) {
                    // NOTE: this can be slow with lots of entities in the cache.
                    this._hasChanges = this._hasChangesCore();
                    if (!this._hasChanges) {
                        this.hasChanges.publish({ entityManager: this, hasChanges: false });
                    }
                }
            }
        };

        ctor.prototype._getEntitiesCore = function (entityTypes, entityStates) {
            var entityGroups = getEntityGroups(this, entityTypes);

            // TODO: think about writing a core.mapMany method if we see more of these.
            var selected;
            entityGroups.forEach(function (eg) {
                // eg may be undefined or null
                if (!eg) return;
                var entities = eg.getEntities(entityStates);
                if (!selected) {
                    selected = entities;
                } else {
                    selected.push.apply(selected, entities);
                }
            });
            return selected || [];
        };

        ctor.prototype._addUnattachedChild = function (parentEntityKey, navigationProperty, child) {
            var key = parentEntityKey.toString();
            var children = this._unattachedChildrenMap[key];
            if (!children) {
                children = [];
                this._unattachedChildrenMap[key] = children;
            }
            children.push(child);
        };

        
        ctor.prototype._linkRelatedEntities = function (entity) {
            var em = this;
            var entityAspect = entity.entityAspect;
            // we do not want entityState to change as a result of linkage.
            core.using(em, "isLoading", true, function () {

                var entityType = entity.entityType;
                var navigationProperties = entityType.navigationProperties;
                var unattachedMap = em._unattachedChildrenMap;

                navigationProperties.forEach(function (np) {
                    if (np.isScalar) {
                        var value = entity.getProperty(np.name);
                        // property is already linked up
                        if (value) return;
                    }

                    // first determine if np contains a parent or child
                    // having a parentKey means that this is a child
                    var parentKey = entityAspect.getParentKey(np);
                    if (parentKey) {
                        // check for empty keys - meaning that parent id's are not yet set.
                        if (parentKey._isEmpty()) return;
                        // if a child - look for parent in the em cache
                        var parent = em.findEntityByKey(parentKey);
                        if (parent) {
                            // if found hook it up
                            entity.setProperty(np.name, parent);
                        } else {
                            // else add parent to unresolvedParentMap;
                            unattachedMap.addChild(parentKey, np, entity);
                        }
                    } else {
                        // if a parent - look for unresolved children associated with this entity
                        // and hook them up.
                        var entityKey = entityAspect.getKey();
                        var inverseNp = np.inverse;
                        if (!inverseNp) return;
                        var unattachedChildren = unattachedMap.getChildren(entityKey, inverseNp);
                        if (!unattachedChildren) return;
                        if (np.isScalar) {
                            var onlyChild = unattachedChildren[0];
                            entity.setProperty(np.name, onlyChild);
                            onlyChild.setProperty(inverseNp.name, entity);
                        } else {
                            var currentChildren = entity.getProperty(np.name);
                            unattachedChildren.forEach(function (child) {
                                currentChildren.push(child);
                                child.setProperty(inverseNp.name, entity);
                            });
                        }
                        unattachedMap.removeChildren(entityKey, np);
                    }
                });
            });
        };

        // private fns
        
        
        function markIsBeingSaved(entities, flag) {
            entities.forEach(function(entity) {
                entity.entityAspect.isBeingSaved = flag;
            });
        }

        function exportEntityGroups(em, entities) {
            var entityGroupMap;
            if (entities) {
                // group entities by entityType and 
                // create 'groups' that look like entityGroups.
                entityGroupMap = {};
                entities.forEach(function (e) {
                    var group = entityGroupMap[e.entityType.name];
                    if (!group) {
                        group = {};
                        group.entityType = e.entityType;
                        group._entities = [];
                        entityGroupMap[e.entityType.name] = group;
                    }
                    group._entities.push(e);
                });
            } else {
                entityGroupMap = em._entityGroupMap;
            }

            var tempKeys = [];
            var newGroupMap = {};
            core.objectForEach(entityGroupMap, function (entityTypeName, entityGroup) {
                newGroupMap[entityTypeName] = exportEntityGroup(entityGroup, tempKeys);
            });

            return { entityGroupMap: newGroupMap, tempKeys: tempKeys };
        }

        function exportEntityGroup(entityGroup, tempKeys) {
            var resultGroup = {};
            var entityType = entityGroup.entityType;
            var dpNames = entityType.dataProperties.map(core.pluck("name"));
            resultGroup.dataPropertyNames = dpNames;
            resultGroup.entities = entityGroup._entities.map(function (e) {
                var rawEntity = [];
                dpNames.forEach(function (dpName) {
                    rawEntity.push(e.getProperty(dpName));
                });
                var aspect = e.entityAspect;
                var entityState = aspect.entityState;
                var newAspect = {
                    tempNavPropNames: exportTempKeyInfo(aspect, tempKeys),
                    entityState: entityState.name
                };
                if (entityState.isModified() || entityState.isDeleted()) {
                    newAspect.originalValuesMap = aspect.originalValues;
                };
                rawEntity.push(newAspect);
                return rawEntity;
            });
            return resultGroup;
        }

        function exportTempKeyInfo(entityAspect, tempKeys) {
            var entity = entityAspect.entity;
            if (entityAspect.hasTempKey) {
                tempKeys.push(entityAspect.getKey().toJSON());
            }
            // create map for this entity with foreignKeys that are 'temporary'
            // map -> key: tempKey, value: fkPropName
            var tempNavPropNames;
            entity.entityType.navigationProperties.forEach(function (np) {
                if (np.relatedDataProperties) {
                    var relatedValue = entity.getProperty(np.name);
                    if (relatedValue && relatedValue.entityAspect.hasTempKey) {
                        tempNavPropNames = tempNavPropNames || [];
                        tempNavPropNames.push(np.name);
                    }
                }
            });
            return tempNavPropNames;
        }

        function importEntityGroup(entityGroup, jsonGroup, config) {

            var tempKeyMap = config.tempKeyMap;

            var entityType = entityGroup.entityType;
            var shouldOverwrite = config.mergeStrategy === MergeStrategy.OverwriteChanges;
            var targetEntity = null;
            var dpNames = jsonGroup.dataPropertyNames;
            var keyIxs = entityType.keyProperties.map(function (kp) {
                return dpNames.indexOf(kp.name);
            });
            var lastIx = dpNames.length;
            var entityChanged = entityGroup.entityManager.entityChanged;
            jsonGroup.entities.forEach(function (rawEntity) {
                var newAspect = rawEntity[lastIx];
                var keyValues = keyIxs.map(function (ix) { return rawEntity[ix]; });
                var entityKey = new EntityKey(entityType, keyValues);
                var entityState = EntityState.fromName(newAspect.entityState);
                var newTempKeyValue;
                if (entityState.isAdded()) {
                    newTempKeyValue = tempKeyMap[entityKey.toString()];
                    if (newTempKeyValue === undefined) {
                        // merge added records with non temp keys
                        targetEntity = entityGroup.findEntityByKey(entityKey);
                    } else {
                        targetEntity = null;
                    }
                } else {
                    targetEntity = entityGroup.findEntityByKey(entityKey);
                }

                if (targetEntity) {
                    var wasUnchanged = targetEntity.entityAspect.entityState.isUnchanged();
                    if (shouldOverwrite || wasUnchanged) {
                        dpNames.forEach(function (dpName, ix) {
                            targetEntity.setProperty(dpName, rawEntity[ix]);
                        });
                        entityChanged.publish({ entityAction: EntityAction.MergeOnImport, entity: targetEntity });
                        if (wasUnchanged) {
                            if (!entityState.isUnchanged()) {
                                entityGroup.entityManager._notifyStateChange(targetEntity, true);
                            }
                        } else {
                            if (entityState.isUnchanged()) {
                                entityGroup.entityManager._notifyStateChange(targetEntity, false);
                            }
                        }
                    } else {
                        targetEntity = null;
                    }
                } else {
                    targetEntity = entityType._createEntity(true);
                    dpNames.forEach(function (dpName, ix) {
                        targetEntity.setProperty(dpName, rawEntity[ix]);
                    });
                    if (newTempKeyValue !== undefined) {
                        // fixup pk
                        targetEntity.setProperty(entityType.keyProperties[0].name, newTempKeyValue);

                        // fixup foreign keys
                        if (newAspect.tempNavPropNames) {
                            newAspect.tempNavPropNames.forEach(function (npName) {
                                var np = entityType.getNavigationProperty(npName);
                                var fkPropName = np.relatedDataProperties[0].name;
                                var oldFkValue = targetEntity.getProperty(fkPropName);
                                var fk = new EntityKey(np.entityType, [oldFkValue]);
                                var newFkValue = tempKeyMap[fk.toString()];
                                targetEntity.setProperty(fkPropName, newFkValue);
                            });
                        }
                    }
                    targetEntity.entityAspect._postInitialize();
                    targetEntity = entityGroup.attachEntity(targetEntity, entityState);
                    if (entityChanged) {
                        entityChanged.publish({ entityAction: EntityAction.AttachOnImport, entity: targetEntity });
                        if (!entityState.isUnchanged()) {
                            entityGroup.entityManager._notifyStateChange(targetEntity, true);
                        }
                    }
                }

                if (targetEntity) {
                    targetEntity.entityAspect.entityState = entityState;
                    if (entityState.isModified()) {
                        targetEntity.entityAspect.originalValuesMap = newAspect.originalValues;
                    }
                    entityGroup.entityManager._linkRelatedEntities( targetEntity);
                }
            });
        };

        function promiseWithCallbacks(promise, callback, errorCallback) {

            promise = promise.then(function (data) {
                if (callback) callback(data);
                return Q.resolve(data);
            }).fail(function (error) {
                if (errorCallback) errorCallback(error);
                return Q.reject(error);
            });
            return promise;
        }

        function getEntitiesToSave(em, entities) {
            var entitiesToSave;
            if (entities) {
                entitiesToSave = entities.filter(function (e) {
                    if (e.entityAspect.entityManager !== em) {
                        throw new Error("Only entities in this entityManager may be saved");
                    }
                    return !e.entityAspect.entityState.isDetached();
                });
            } else {
                entitiesToSave = em.getChanges();
            }
            return entitiesToSave;
        }

        function fixupKeys(em, keyMappings) {
            keyMappings.forEach(function (km) {
                var entityTypeName = EntityType._getNormalizedTypeName(km.EntityTypeName);
                var group = em._entityGroupMap[entityTypeName];
                group._fixupKey(km.TempValue, km.RealValue);
            });
        }

        function getEntityGroups(em, entityTypes) {
            var groupMap = em._entityGroupMap;
            if (entityTypes) {
                if (entityTypes instanceof EntityType) {
                    return [groupMap[entityTypes.name]];
                } else if (Array.isArray(entityTypes)) {
                    return entityTypes.map(function (et) {
                        if (et instanceof EntityType) {
                            return groupMap[et.name];
                        } else {
                            throw createError();
                        }
                    });
                } else {
                    throw createError();
                }
            } else {
                return core.getOwnPropertyValues(groupMap);
            }

            function createError() {
                return new Error("The EntityManager.getChanges() 'entityTypes' parameter must be either an entityType or an array of entityTypes or null");
            }
        }

        function checkEntityKey(em, entity) {
            var ek = entity.entityAspect.getKey();
            // return properties that are = to defaultValues
            var keyPropsWithDefaultValues = core.arrayZip(entity.entityType.keyProperties, ek.values, function (kp, kv) {
                return (kp.defaultValue === kv) ? kp : null;
            }).filter(function (kp) {
                return kp !== null;
            });
            if (keyPropsWithDefaultValues.length) {
                if (entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                    em.generateTempKeyValue(entity);
                } else {
                    // we will allow attaches of entities where only part of the key is set.
                    if (keyPropsWithDefaultValues.length === ek.values.length) {
                        throw new Error("Cannot attach an object to an EntityManager without first setting its key or setting its entityType 'AutoGeneratedKeyType' property to something other than 'None'");
                    }
                }
            }
        }

        function validateEntityStates(em, entityStates) {
            if (!entityStates) return null;
            if (EntityState.contains(entityStates)) {
                entityStates = [entityStates];
            } else if (Array.isArray(entityStates)) {
                entityStates.forEach(function (es) {
                    if (!EntityState.contains(es)) {
                        throw createError();
                    }
                });
            } else {
                throw createError();
            }
            return entityStates;

            function createError() {
                return new Error("The EntityManager.getChanges() 'entityStates' parameter must either be null, an entityState or an array of entityStates");
            }
        }

        function attachEntityCore(em, entity, entityState) {
            var group = findOrCreateEntityGroup(em, entity.entityType);
            group.attachEntity(entity, entityState);
            em._linkRelatedEntities(entity);
        }

        function attachRelatedEntities(em, entity, entityState) {
            var navProps = entity.entityType.navigationProperties;
            navProps.forEach(function (np) {
                var related = entity.getProperty(np.name);
                if (np.isScalar) {
                    if (!related) return;
                    em.attachEntity(related, entityState);
                } else {
                    related.forEach(function (e) {
                        em.attachEntity(e, entityState);
                    });
                }
            });
        }

        

        // returns a promise
        function executeQueryCore(em, query) {
            try {
                var metadataStore = em.metadataStore;
                if (metadataStore.isEmpty()) {
                    throw new Error("cannot execute _executeQueryCore until metadataStore is populated.");
                }
                var queryOptions = query.queryOptions || em.queryOptions || QueryOptions.defaultInstance;
                if (queryOptions.fetchStrategy == FetchStrategy.FromLocalCache) {
                    return Q.fcall(function () {
                        var results = em.executeQueryLocally(query);
                        return { results: results, query: query };
                    });
                }
                var odataQuery = toOdataQueryString(query, metadataStore);
                var queryContext = {
                     query: query, 
                     entityManager: em, 
                     mergeStrategy: queryOptions.mergeStrategy, 
                     refMap: {}, 
                     deferredFns: []
                };
                var deferred = Q.defer();
                var validateOnQuery = em.validationOptions.validateOnQuery;
                var promise = deferred.promise;
                
                em.dataServiceAdapterInstance.executeQuery(em, odataQuery, function (rawEntities) {
                    var result = core.wrapExecution(function () {
                        var state = { isLoading: em.isLoading };
                        em.isLoading = true;
                        em._pendingPubs = [];
                        return state;
                    }, function (state) {
                        em.isLoading = state.isLoading;
                        em._pendingPubs.forEach(function(fn) { fn(); });
                        em._pendingPubs = null;
                    }, function() {
                        var entities = rawEntities.map(function(rawEntity) {
                            // at the top level - mergeEntity will only return entities - at lower levels in the hierarchy 
                            // mergeEntity can return deferred functions.
                            var entity = mergeEntity(rawEntity, queryContext);
                            // anon types and simple types will not have an entityAspect.
                            if (validateOnQuery && entity.entityAspect) {
                                entity.entityAspect.validateEntity();
                            }
                            return entity;
                        });
                        if (queryContext.deferredFns.length > 0) {
                           queryContext.deferredFns.forEach(function(fn) {
                                fn();
                            });
                        }
                        return { results: entities, query: query, XHR: rawEntities.XHR };
                    });
                    deferred.resolve( result);
                }, function (e) {
                    if (e) {
                        e.query = query;
                    }
                    deferred.reject(e);
                });
                return promise;
            } catch (e) {
                if (e) {
                    e.query = query;
                }
                return Q.reject(e);
            }
        }

        function mergeEntity(rawEntity, queryContext, isSaving, isNestedInAnon) {
            
            var em = queryContext.entityManager;
            var mergeStrategy = queryContext.mergeStrategy;

            // resolveRefEntity will return one of 3 values;  a targetEntity, a null or undefined.
            // null and undefined have different meanings - null means a ref entity that cannot be resolved - usually an odata __deferred value
            // undefined means that this is not a ref entity.
            targetEntity = em.dataServiceAdapterInstance.resolveRefEntity(rawEntity, queryContext);
            if (targetEntity !== undefined) {
                return targetEntity;
            }

            
            var entityType =em.dataServiceAdapterInstance.getEntityType(rawEntity, em.metadataStore);

            if (entityType == null) {
                return processAnonType(rawEntity, queryContext, isSaving);
            }

            rawEntity.entityType = entityType;
            var entityKey = EntityKey._fromRawEntity(rawEntity, entityType);
            var targetEntity = em.findEntityByKey(entityKey);
            if (targetEntity) {
                if (isSaving && targetEntity.entityAspect.entityState.isDeleted()) {
                    em.detachEntity(targetEntity);
                    return targetEntity;
                }
                var targetEntityState = targetEntity.entityAspect.entityState;
                if (mergeStrategy === MergeStrategy.OverwriteChanges
                        || targetEntityState.isUnchanged()) {
                    updateEntity(targetEntity, rawEntity, queryContext);
                    targetEntity.entityAspect.wasLoaded = true;
                    
                    targetEntity.entityAspect.entityState = EntityState.Unchanged;
                    targetEntity.entityAspect.originalValues = {};
                    targetEntity.entityAspect.propertyChanged.publish({ entity: targetEntity, propertyName: null  });
                    var action = isSaving ? EntityAction.MergeOnSave : EntityAction.MergeOnQuery;
                    em.entityChanged.publish({ entityAction: action, entity: targetEntity });
                    // this is needed to handle an overwrite or a modified entity with an unchanged entity 
                    // which might in turn cause _hasChanges to change.
                    if (!targetEntityState.isUnchanged) {
                        em._notifyStateChange(targetEntity, false);
                    }
                } else {
                    // also called by setPropertiesEntity
                    updateCurrentRef(queryContext, targetEntity);
                }

            } else {
                targetEntity = entityType._createEntity(true);
                if (targetEntity.initializeFrom) {
                    // allows any injected post ctor activity to be performed by modelLibrary impl.
                    targetEntity.initializeFrom(rawEntity);
                }
                updateEntity(targetEntity, rawEntity, queryContext);
                targetEntity.entityAspect._postInitialize();
                attachEntityCore(em, targetEntity, EntityState.Unchanged);
                targetEntity.entityAspect.wasLoaded = true;
                em.entityChanged.publish({ entityAction: EntityAction.AttachOnQuery, entity: targetEntity });
            }
            return targetEntity;
        }
        
        // function isSelectQuery(query) {
        //    if (query == null) {
        //        return false;
        //    } else if (typeof query === 'string') {
        //        return query.indexOf("$select") >= 0;
        //    } else {
        //        return !!query.selectClause;
        //    }
        //}
        
        function processAnonType(rawEntity, queryContext, isSaving) {
            var em = queryContext.entityManager;
            var keyFn = em.metadataStore.namingConvention.serverPropertyNameToClient;
            if (typeof rawEntity !== 'object') {
                return rawEntity;
            }
            var result = { };
            core.objectForEach(rawEntity, function(key, value) {
                if (key == "__metadata") {
                    return;
                }
                // EntityKey properties can be produced by EDMX models
                if (key == "EntityKey" && value.$type && core.stringStartsWith(value.$type, "System.Data")) {
                    return;
                }
                var firstChar = key.substr(0, 1);
                if (firstChar == "$") {
                    if (key === "$id") {
                        queryContext.refMap[value] = result;
                    }
                    return;
                } 
                
                var newKey = keyFn(key);
                var refValue;
                // == is deliberate here instead of ===
                if (value == null) {
                    result[newKey] = value;
                } else if (Array.isArray(value)) {
                    result[newKey] = value.map(function(v, ix, arr) {
                        if (v == null) {
                            return v;
                        } else if (v.$type || v.__metadata) {
                            return mergeEntity(v, queryContext, isSaving, true);
                        } else if (v.$ref) {
                            refValue = em.dataServiceAdapterInstance.resolveRefEntity(v, queryContext);
                            if (typeof refValue == "function") {
                                queryContext.deferredFns.push(function () {
                                    arr[ix] = refValue();
                                });
                            }
                            return refValue;
                        } else {
                            return v;
                        }
                    });
                } else {
                    if (value.$type || value.__metadata) {
                        result[newKey] = mergeEntity(value, queryContext, isSaving, true);
                    } else if (value.$ref) {
                        refValue = em.dataServiceAdapterInstance.resolveRefEntity(value, queryContext);
                        if (typeof refValue == "function") {
                            queryContext.deferredFns.push(function () {
                                result[newKey] = refValue();
                            });
                        }
                        result[newKey] = refValue;
                    } else {
                        result[newKey] = value;
                    }
                }
            });
            return result;
        }
        

        function updateEntity(targetEntity, rawEntity, queryContext) {
            updateCurrentRef(queryContext, targetEntity);
            var entityType = targetEntity.entityType;
            var metadataStore = entityType.metadataStore;
            entityType.dataProperties.forEach(function (dp) {
                if (dp.isUnmapped) return;
                var val = rawEntity[dp.nameOnServer];
                if (dp.dataType === DataType.DateTime && val) {
                    if (!core.isDate(val)) {
                        // Does not work - returns time offset from GMT (i think)
                        // val = new Date(val);
                        val = core.dateFromIsoString(val);
                    }
                }
                targetEntity.setProperty(dp.name, val);
            });
            entityType.navigationProperties.forEach(function (np) {
                if (np.isScalar) {
                    mergeRelatedEntity(np, targetEntity, rawEntity, queryContext);
                } else {
                    mergeRelatedEntities(np, targetEntity, rawEntity, queryContext);
                }
            });
        }

        function updateCurrentRef(queryContext, targetEntity) {
            if (queryContext.refId !== undefined) {
                queryContext.refMap[queryContext.refId] = targetEntity;
            }
        }

        function mergeRelatedEntity(navigationProperty, targetEntity, rawEntity, queryContext) {
            var relatedRawEntity = rawEntity[navigationProperty.nameOnServer];
            if (!relatedRawEntity) return;
            var deferred = queryContext.entityManager.dataServiceAdapterInstance.getDeferredValue(relatedRawEntity);
            if (deferred) {
                return;
            }
            var relatedEntity = mergeEntity(relatedRawEntity, queryContext);
            if (typeof relatedEntity === 'function') {
                queryContext.deferredFns.push(function() {
                    relatedEntity = relatedEntity();
                    updateRelatedEntity(relatedEntity, targetEntity, navigationProperty);
                });
            } else {
                updateRelatedEntity(relatedEntity, targetEntity, navigationProperty);
            }
        }
        
        function updateRelatedEntity(relatedEntity, targetEntity, navigationProperty) {
            if (!relatedEntity) return;
            var propName = navigationProperty.name;
            var currentRelatedEntity = targetEntity.getProperty(propName);
            // check if the related entity is already hooked up
            if (currentRelatedEntity != relatedEntity) {
                // if not hook up both directions.
                targetEntity.setProperty(propName, relatedEntity);
                var inverseProperty = navigationProperty.inverse;
                if (!inverseProperty) return;
                if (inverseProperty.isScalar) {
                    relatedEntity.setProperty(inverseProperty.name, targetEntity);
                } else {
                    var collection = relatedEntity.getProperty(inverseProperty.name);
                    collection.push(targetEntity);
                }
            }
        }

        function mergeRelatedEntities(navigationProperty, targetEntity, rawEntity, queryContext) {
            var propName = navigationProperty.name;
            var relatedEntities = targetEntity.getProperty(propName);

            var inverseProperty = navigationProperty.inverse;
            if (!inverseProperty) return;
            var relatedRawEntities = rawEntity[navigationProperty.nameOnServer];

            if (!relatedRawEntities) return;
            var deferred = queryContext.entityManager.dataServiceAdapterInstance.getDeferredValue(relatedRawEntities);
            if (deferred) {
                return;
            }
            if (!Array.isArray(relatedRawEntities)) return;
            relatedEntities.wasLoaded = true;
            relatedRawEntities.forEach(function (relatedRawEntity) {
                var relatedEntity = mergeEntity(relatedRawEntity, queryContext);
                if (typeof relatedEntity === 'function') {
                    queryContext.deferredFns.push(function() {
                        relatedEntity = relatedEntity();
                        updateRelatedEntityInCollection(relatedEntity, relatedEntities, targetEntity, inverseProperty);
                    });
                } else {
                    updateRelatedEntityInCollection(relatedEntity, relatedEntities, targetEntity, inverseProperty);
                }
            });
        };
        
        function updateRelatedEntityInCollection(relatedEntity, relatedEntities, targetEntity, inverseProperty) {
            if (!relatedEntity) return;
            // check if the related entity is already hooked up
            var thisEntity = relatedEntity.getProperty(inverseProperty.name);
            if (thisEntity !== targetEntity) {
                // if not - hook it up.
                relatedEntities.push(relatedEntity);
                relatedEntity.setProperty(inverseProperty.name, targetEntity);
            }
        }

        function updateConcurrencyProperties(entities) {
            var candidates = entities.filter(function (e) {
                e.entityAspect.isBeingSaved = true;
                return e.entityAspect.entityState.isModified()
                    && e.entityType.concurrencyProperties.length > 0;

            });
            if (candidates.length === 0) return;
            candidates.forEach(function (c) {
                c.entityType.concurrencyProperties.forEach(function (cp) {
                    updateConcurrencyProperty(c, cp);
                });
            });
        }

        function updateConcurrencyProperty(entity, property) {
            // check if property has already been updated 
            if (entity.entityAspect.originalValues[property.name]) return;
            var value = entity.getProperty(property.name);
            if (!value) value = property.dataType.defaultValue;
            if (property.dataType.isNumeric) {
                entity.setProperty(property.name, value + 1);
            } else if (property.dataType === DataType.DateTime) {
                // use the current datetime but insure that it
                // is different from previous call.
                var dt = new Date();
                var dt2 = new Date();
                while (dt == dt2) {
                    dt2 = new Date();
                }
                entity.setProperty(property.name, dt2);
            } else if (property.dataType === DataType.Guid) {
                entity.setProperty(property.name, core.getUuid());
            } else if (property.datatype === DataType.Binary) {
                // best guess - that this is a timestamp column and is computed on the server during save 
                // - so no need to set it here.
                return;
            } else {
                // this just leaves DataTypes of Boolean, String and Byte - none of which should be the
                // type for a concurrency column.
                // NOTE: thought about just returning here but would rather be safe for now. 
                throw new Error("Unable to update the value of concurrency property before saving: " + property.name);
            }
        }

        function toOdataQueryString(query, metadataStore) {
            if (!query) {
                throw new Error("query cannot be empty");
            }
            if (typeof query === 'string') {
                return query;
            } else if (query instanceof EntityQuery) {
                return query._toUri(metadataStore);
            } else {
                throw new Error("unable to recognize query parameter as either a string or an EntityQuery");
            }
        }

        function findOrCreateEntityGroup(em, entityType) {
            var group = em._entityGroupMap[entityType.name];
            if (!group) {
                group = new EntityGroup(em, entityType);
                em._entityGroupMap[entityType.name] = group;
            }
            return group;
        }
        
        function unwrapEntities(entities, metadataStore) {
            var rawEntities = entities.map(function(e) {
                var rawEntity = { };
                e.entityType.dataProperties.forEach(function(dp) {
                    rawEntity[dp.nameOnServer] = e.getProperty(dp.name);
                });
                var autoGeneratedKey = null;
                if (e.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                    autoGeneratedKey = {
                        propertyName: e.entityType.keyProperties[0].nameOnServer,
                        autoGeneratedKeyType: e.entityType.autoGeneratedKeyType.name
                    };
                }
                
                var originalValuesOnServer = e.entityType._clientObjectToServer(e.entityAspect.originalValues);
                rawEntity.entityAspect = {
                    entityTypeName: e.entityType.name,
                    entityState: e.entityAspect.entityState.name,
                    originalValuesMap: originalValuesOnServer,
                    autoGeneratedKey: autoGeneratedKey
                };
                return rawEntity;
            });
            return rawEntities;
        }

        function UnattachedChildrenMap() {
            // key is EntityKey.toString(), value is array of { navigationProperty, children }
            this.map = {};
        }

        UnattachedChildrenMap.prototype.addChild = function (parentEntityKey, navigationProperty, child) {
            var tuple = this.getTuple(parentEntityKey, navigationProperty);
            if (!tuple) {
                var tuples = this.map[parentEntityKey.toString()];
                if (!tuples) {
                    tuples = [];
                    this.map[parentEntityKey.toString()] = tuples;
                }
                tuple = { navigationProperty: navigationProperty, children: [] };
                tuples.push(tuple);
            }
            tuple.children.push(child);
        };

        UnattachedChildrenMap.prototype.removeChildren = function (parentEntityKey, navigationProperty) {
            var tuples = this.map[parentEntityKey.toString()];
            if (!tuples) return;
            core.arrayRemoveItem(tuples, function (t) {
                return t.navigationProperty === navigationProperty;
            });
            if (!tuples.length) {
                delete this.map[parentEntityKey.toString()];
            }
        };

        UnattachedChildrenMap.prototype.getChildren = function (parentEntityKey, navigationProperty) {
            var tuple = this.getTuple(parentEntityKey, navigationProperty);
            if (tuple) {
                return tuple.children;
            } else {
                return null;
            }
        };

        UnattachedChildrenMap.prototype.getTuple = function (parentEntityKey, navigationProperty) {
            var tuples = this.map[parentEntityKey.toString()];
            if (!tuples) return null;
            var tuple = core.arrayFirst(tuples, function (t) {
                return t.navigationProperty === navigationProperty;
            });
            return tuple;
        };

        return ctor;
    })();

    var EntityGroup = (function () {

        var __changedFilter = getFilter([EntityState.Added, EntityState.Modified, EntityState.Deleted]);
        
        var ctor = function (entityManager, entityType) {
            this.entityManager = entityManager;
            this.entityType = entityType;
            this._indexMap = {};
            this._entities = [];
            this._emptyIndexes = [];
        };

        ctor.prototype.attachEntity = function (entity, entityState) {
            // entity should already have an aspect.
            var ix;
            var aspect = entity.entityAspect;
            var keyInGroup = aspect.getKey()._keyInGroup;
            ix = this._indexMap[keyInGroup];
            if (ix >= 0) {
                if (this._entities[ix] === entity) {
                    return entity;
                }
                throw new Error("This key is already attached: " + aspect.getKey());
            }

            if (this._emptyIndexes.length === 0) {
                ix = this._entities.push(entity) - 1;
            } else {
                ix = this._emptyIndexes.pop();
                this._entities[ix] = entity;
            }
            this._indexMap[keyInGroup] = ix;
            aspect.entityState = entityState;
            aspect.entityGroup = this;
            aspect.entityManager = this.entityManager;
            return entity;
        };

        ctor.prototype.detachEntity = function (entity) {
            // by this point we have already determined that this entity 
            // belongs to this group.
            var aspect = entity.entityAspect;
            var keyInGroup = aspect.getKey()._keyInGroup;
            var ix = this._indexMap[keyInGroup];
            if (ix === undefined) {
                // shouldn't happen.
                throw new Error("internal error - entity cannot be found in group");
            }
            delete this._indexMap[keyInGroup];
            this._emptyIndexes.push(ix);
            this._entities[ix] = null;
            aspect.entityState = EntityState.Detached;
            aspect.entityGroup = null;
            aspect.entityManager = null;
            return entity;
        };

        // returns entity based on an entity key defined either as an array of key values or an EntityKey
        ctor.prototype.findEntityByKey = function (entityKey) {
            var keyInGroup;
            if (entityKey instanceof EntityKey) {
                keyInGroup = entityKey._keyInGroup;
            } else {
                keyInGroup = EntityKey.createKeyString(entityKey);
            }
            var ix = this._indexMap[keyInGroup];
            // can't use just (ix) below because 0 is valid
            return (ix !== undefined) ? this._entities[ix] : null;
        };

        ctor.prototype.hasChanges = function() {
            return this._entities.some(__changedFilter);
        };

        ctor.prototype.getEntities = function (entityStates) {
            var filter = getFilter(entityStates);
            var changes = this._entities.filter(filter);
            return changes;
        };
        
        // do not expose this method. It is doing a special purpose INCOMPLETE fast detach operation
        // just for the entityManager clear method - the entityGroup will be in an inconsistent state
        // after this op, which is ok because it will be thrown away.
        ctor.prototype._clear = function() {
            this._entities.forEach(function(entity) {
                var aspect = entity.entityAspect;
                aspect.entityState = EntityState.Detached;
                aspect.entityGroup = null;
                aspect.entityManager = null;
            });
        };

        ctor.prototype._fixupKey = function (tempValue, realValue) {
            // single part keys appear directly in map
            var ix = this._indexMap[tempValue];
            if (ix === undefined) {
                throw new Error("Internal Error in key fixup - unable to locate entity");
            }
            var entity = this._entities[ix];
            var keyPropName = entity.entityType.keyProperties[0].name;
            // fks on related entities will automatically get updated by this as well
            entity.setProperty(keyPropName, realValue);
            delete entity.entityAspect.hasTempKey;
            delete this._indexMap[tempValue];
            this._indexMap[realValue] = ix;
        };

        ctor.prototype._replaceKey = function(oldKey, newKey) {
            var ix = this._indexMap[oldKey._keyInGroup];
            delete this._indexMap[oldKey._keyInGroup];
            this._indexMap[newKey._keyInGroup] = ix;
        };
        
        function getFilter(entityStates) {
            var filter;
            if (!entityStates) {
                return function (e) {
                    return !!e;
                };
            } else if (entityStates.length === 1) {
                var entityState = entityStates[0];
                return function (e) {
                    if (!e) return false;
                    return e.entityAspect.entityState === entityState;
                };
            } else {
                return function (e) {
                    if (!e) return false;
                    return entityStates.some(function (es) {
                        return e.entityAspect.entityState === es;
                    });
                };
            }
        }

        return ctor;

    })();

    /**
    MergeStrategy is an 'Enum' that determines how entities are merged into an EntityManager.

    @class MergeStrategy
    @static
    **/
    var MergeStrategy = new Enum("MergeStrategy");
    /**
    PreserveChanges is used to stop merging from occuring if the existing entity in an entityManager is already
    in a {{#crossLink "EntityState/Modified"}}{{/crossLink}} state. In this case, the existing entity in the 
    EntityManager is not replaced by the 'merging' entity.

    @property PreserveChanges {MergeStrategy}
    @final
    @static
    **/
    MergeStrategy.PreserveChanges = MergeStrategy.addSymbol();
    /**
    OverwriteChanges is used to allow merging to occur even if the existing entity in an entityManager is already
    in a {{#crossLink "EntityState/Modified"}}{{/crossLink}} state. In this case, the existing entity in the 
    EntityManager is replaced by the 'merging' entity.

    @property OverwriteChanges {MergeStrategy}
    @final
    @static
    **/
    MergeStrategy.OverwriteChanges = MergeStrategy.addSymbol();
    MergeStrategy.seal();

    /**
    FetchStrategy is an 'Enum' that determines how and where entities are retrieved from as a result of a query.

    @class FetchStrategy
    @static
    **/
    var FetchStrategy = new Enum("FetchStrategy");
    /**
    FromServer is used to tell the query to execute the query against a remote data source on the server.
    @property FromServer {MergeStrategy}
    @final
    @static
    **/
    FetchStrategy.FromServer = FetchStrategy.addSymbol();
    /**
    FromLocalCache is used to tell the query to execute the query against a local EntityManager instead of going to a remote server.
    @property FromLocalCache {MergeStrategy}
    @final
    @static
    **/
    FetchStrategy.FromLocalCache = FetchStrategy.addSymbol();
    FetchStrategy.seal();


    var QueryOptions = (function () {
        /**
        A QueryOptions instance is used to specify the 'options' under which a query will occur.

        @class QueryOptions
        **/
        
        /**
        QueryOptions constructor
        @example
            var newQo = new QueryOptions( { mergeStrategy: MergeStrategy.OverwriteChanges });
            // assume em1 is a preexisting EntityManager
            em1.setProperties( { queryOptions: newQo });
        @method <ctor> QueryOptions
        @param [config] {Object}
        @param [config.fetchStrategy=FetchStrategy.FromServer] {FetchStrategy}  
        @param [config.mergeStrategy=MergeStrategy.PreserveChanges] {MergeStrategy}  
        **/
        var ctor = function (config) {
            this.fetchStrategy = FetchStrategy.FromServer;
            this.mergeStrategy = MergeStrategy.PreserveChanges;
            updateWithConfig(this, config);
        };
        
     

        /**
        A {{#crossLink "FetchStrategy"}}{{/crossLink}}
        __readOnly__
        @property fetchStrategy {FetchStrategy}
        **/

        /**
        A {{#crossLink "MergeStrategy"}}{{/crossLink}}
        __readOnly__
        @property mergeStrategy {MergeStrategy}
        **/

        ctor.prototype._$typeName = "QueryOptions";

        /**
        The default value whenever QueryOptions are not specified.
        @property defaultInstance {QueryOptions}
        @static
        **/
        ctor.defaultInstance = new ctor();

        /**
        Returns a copy of this QueryOptions with the specified {{#crossLink "MergeStrategy"}}{{/crossLink}} 
        or {{#crossLink "FetchStrategy"}}{{/crossLink}} applied.
        @example
            var queryOptions = em1.defaultQueryOptions.using(MergeStrategy.PreserveChanges);
        or
        @example
            var queryOptions = em1.defaultQueryOptions.using(FetchStrategy.FromLocalCache);
        or
        @example
            var queryOptions = em1.defaultQueryOptions.using( { mergeStrategy: OverwriteChanges });
        @method using
        @param config {Configuration Object|MergeStrategy|FetchStrategy} The object to apply to create a new QueryOptions.
        @return {QueryOptions}
        @chainable
        **/
        ctor.prototype.using = function(config) {
            var result = new QueryOptions(this);
            if (MergeStrategy.contains(config)) {
                config = { mergeStrategy: config };
            } else if (FetchStrategy.contains(config)) {
                config = { fetchStrategy: config };
            } 
            return updateWithConfig(result, config);
        };
        
        /**
        Makes this instance the default instance.
        @method setAsDefault
        @example
            var newQo = new QueryOptions( { mergeStrategy: MergeStrategy.OverwriteChanges });
            newQo.setAsDefault();
        @chainable
        **/
        ctor.prototype.setAsDefault = function() {
            ctor.defaultInstance = this;
            return this;
        };

        ctor.prototype.toJSON = function () {
            return {
                fetchStrategy: this.fetchStrategy.name,
                mergeStrategy: this.mergeStrategy.name
            };
        };

        ctor.fromJSON = function (json) {
            return new QueryOptions({
                fetchStrategy: FetchStrategy.fromName(json.fetchStrategy),
                mergeStrategy: MergeStrategy.fromName(json.mergeStrategy)
            });
        };
        
        function updateWithConfig( obj, config ) {
            if (config) {
                assertConfig(config)
                    .whereParam("fetchStrategy").isEnumOf(FetchStrategy).isOptional()
                    .whereParam("mergeStrategy").isEnumOf(MergeStrategy).isOptional()
                    .applyAll(obj);
            }
            return obj;
        }
       
        return ctor;
    })();

    var SaveOptions = (function () {
        /**
        A SaveOptions instance is used to specify the 'options' under which a save will occur.

        @class SaveOptions
        **/
        
        /**
        @method <ctor> SaveOptions
        @param config {Object}
        @param [config.allowConcurrentSaves] {Boolean}
        **/
        var ctor = function (config) {
            config = config || {};
            assertConfig(config)
                .whereParam("allowConcurrentSaves").isBoolean().isOptional().withDefault(false)
                .applyAll(this);
                        
        };
        ctor.prototype._$typeName = "SaveOptions";
        
        /**
        Makes this instance the default instance.
        @method setAsDefault
        @chainable
        **/
        ctor.prototype.setAsDefault = function() {
            ctor.defaultInstance = this;
            return this;
        };
        
        /**
        Whether another save can be occuring at the same time as this one - default is false.

        __readOnly__
        @property allowConcurrentSaves {Boolean}
        **/

        /**
        The default value whenever SaveOptions are not specified.
        @property defaultInstance {SaveOptions}
        @static
        **/
        ctor.defaultInstance = new ctor();
        return ctor;
    })();

    var ValidationOptions = (function () {

        /**
        A ValidationOptions instance is used to specify the conditions under which validation will be executed.

        @class ValidationOptions
        **/
        
        /**
        ValidationOptions constructor
        @example
            var newVo = new ValidationOptions( { validateOnSave: false, validateOnAttach: false });
            // assume em1 is a preexisting EntityManager
            em1.setProperties( { validationOptions: newVo });
        @method <ctor> ValidationOptions
        @param [config] {Object}
        @param [config.validateOnAttach=true] {Boolean}
        @param [config.validateOnSave=true] {Boolean}
        @param [config.validateOnQuery=false] {Boolean}
        @param [config.validateOnPropertyChange=true] {Boolean}
        **/
        var ctor = function (config) {
            this.validateOnAttach = true;
            this.validateOnSave = true;
            this.validateOnQuery = false;
            this.validateOnPropertyChange = true;
            updateWithConfig(this, config);
        };

        /**
        Whether entity and property level validation should occur when entities are attached to the EntityManager other than via a query.

        __readOnly__
        @property validateOnAttach {Boolean}
        **/

        /**
        Whether entity and property level validation should occur before entities are saved. A failed validation will force the save to fail early.

        __readOnly__
        @property validateOnSave {Boolean}
        **/

        /**
        Whether entity and property level validation should occur after entities are queried from a remote server.

        __readOnly__
        @property validateOnQuery {Boolean}
        **/

        /**
        Whether property level validation should occur after entities are modified.

        __readOnly__
        @property validateOnPropertyChange {Boolean}
        **/

        ctor.prototype._$typeName = "ValidationOptions";
        
        /**
        Returns a copy of this ValidationOptions with changes to the specified config properties.
        @example
            var validationOptions = new ValidationOptions();
            var newOptions = validationOptions.using( { validateOnQuery: true, validateOnSave: false} );
        @method using
        @param config {Object} The object to apply to create a new QueryOptions.
        @param [config.validateOnAttach] {Boolean}
        @param [config.validateOnSave] {Boolean}
        @param [config.validateOnQuery] {Boolean}
        @param [config.validateOnPropertyChange] {Boolean}
        @return {ValidationOptions}
        @chainable
        **/
        ctor.prototype.using = function(config) {
            var result = new ValidationOptions(this);
            updateWithConfig(result, config);
            return result;
        };

        /**
        Makes this instance the default instance.
        @example
            var validationOptions = new ValidationOptions()
            var newOptions = validationOptions.using( { validateOnQuery: true, validateOnSave: false} );
            var newOptions.setAsDefault();
        @method setAsDefault
        @chainable
        **/
        ctor.prototype.setAsDefault = function() {
            ctor.defaultInstance = this;
            return this;
        };

        /**
        The default value whenever ValidationOptions are not specified.
        @property defaultInstance {ValidationOptions}
        @static
        **/
        ctor.defaultInstance = new ctor();
        
        function updateWithConfig( obj, config ) {
            if (config) {
              assertConfig(config)
                .whereParam("validateOnAttach").isBoolean().isOptional()
                .whereParam("validateOnSave").isBoolean().isOptional()
                .whereParam("validateOnQuery").isBoolean().isOptional()
                .whereParam("validateOnPropertyChange").isBoolean().isOptional()
                .applyAll(obj);
            }
            return obj;
        }
        return ctor;
    })();

    // Extensions to the EntityQuery class - must be done here because some of the types used are not yet avail
    // when the EntityQuery file is processed.

    EntityQuery.prototype.using = function(obj) {
        var eq = this._clone();
        if (obj instanceof EntityManager) {
            eq.entityManager = obj;
        } else if (MergeStrategy.contains(obj) || FetchStrategy.contains(obj)) {
            var queryOptions = this.queryOptions || QueryOptions.defaultInstance;
            eq.queryOptions = queryOptions.using(obj);
        } else {
            throw new Error("EntityQuery.using parameter must be either an EntityManager, a Query Strategy or a FetchStrategy");
        }
        return eq;
    };

    EntityQuery.prototype.execute = function(callback, errorCallback) {
        if (!this.entityManager) {
            throw new Error("An EntityQuery must have its EntityManager property set before calling 'execute'");
        }
        return this.entityManager.executeQuery(this, callback, errorCallback);
    };
    
    EntityQuery.prototype.executeLocally = function() {
        if (!this.entityManager) {
            throw new Error("An EntityQuery must have its EntityManager property set before calling 'executeLocally'");
        }
        return this.entityManager.executeQueryLocally(this);
    };

    // expose

    return {
        EntityManager: EntityManager,
        QueryOptions: QueryOptions,
        SaveOptions: SaveOptions,
        ValidationOptions: ValidationOptions,
        FetchStrategy: FetchStrategy,
        MergeStrategy: MergeStrategy
    };


});


