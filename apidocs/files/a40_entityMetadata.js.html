<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>a40_entityMetadata.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>
<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze_large.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://stackoverflow.com/questions/tagged/breeze?sort=newest" target="_blank">Forum</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>	
		
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/ComplexAspect.html">ComplexAspect</a></li>
            
                <li><a href="..&#x2F;classes/ComplexType.html">ComplexType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataService.html">DataService</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/JsonResultsAdapter.html">JsonResultsAdapter</a></li>
            
                <li><a href="..&#x2F;classes/LocalQueryComparisonOptions.html">LocalQueryComparisonOptions</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/Promise.html">Promise</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_keyGenerator_interface.html">ↈ_keyGenerator_interface</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_relationArray_.html">ↈ_relationArray_</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/breeze.html">breeze</a></li>
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: a40_entityMetadata.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿&#x2F;**
@module breeze
**&#x2F;

var Q = __requireLib(&quot;Q&quot;, &quot;See https:&#x2F;&#x2F;github.com&#x2F;kriskowal&#x2F;q &quot;);

&#x2F;&#x2F; TODO: still need to handle inheritence here.

var LocalQueryComparisonOptions = (function () {

    &#x2F;**
    A LocalQueryComparisonOptions instance is used to specify the &quot;comparison rules&quot; used when performing &quot;local queries&quot; in order 
    to match the semantics of these same queries when executed against a remote service.  These options should be set based on the 
    manner in which your remote service interprets certain comparison operations.
    
    The default LocalQueryComparisonOptions stipulates &#x27;caseInsensitive&quot; queries with ANSI SQL rules regarding comparisons of unequal
    length strings. 
    
    @class LocalQueryComparisonOptions
    **&#x2F;

    &#x2F;**
    LocalQueryComparisonOptions constructor
    @example
        &#x2F;&#x2F; create a &#x27;caseSensitive - non SQL&#x27; instance.
        var lqco = new LocalQueryComparisonOptions({
            name: &quot;caseSensitive-nonSQL&quot;
            isCaseSensitive: true;
            usesSql92CompliantStringComparison: false;
        });
        &#x2F;&#x2F; either apply it globally
        lqco.setAsDefault();
        &#x2F;&#x2F; or to a specific MetadataStore
        var ms = new MetadataStore({ localQueryComparisonOptions: lqco });
        var em = new EntityManager( { metadataStore: ms });
    
    @method &lt;ctor&gt; LocalQueryComparisonOptions
    @param config {Object}
    @param [config.name] {String}
    @param [config.isCaseSensitive] {Boolean} Whether predicates that involve strings will be interpreted in a &quot;caseSensitive&quot; manner. Default is &#x27;false&#x27;
    @param [config.usesSql92CompliantStringComparison] {Boolean} Whether of not to enforce the ANSI SQL standard 
        of padding strings of unequal lengths before comparison with spaces. Note that per the standard, padding only occurs with equality and 
        inequality predicates, and not with operations like &#x27;startsWith&#x27;, &#x27;endsWith&#x27; or &#x27;contains&#x27;.  Default is true.
    **&#x2F;

    var ctor = function (config) {
        assertConfig(config || {})
            .whereParam(&quot;name&quot;).isOptional().isString()
            .whereParam(&quot;isCaseSensitive&quot;).isOptional().isBoolean()
            .whereParam(&quot;usesSql92CompliantStringComparison&quot;).isBoolean()
            .applyAll(this);
        if (!this.name) {
            this.name = __getUuid();
        }
        __config._storeObject(this, proto._$typeName, this.name);
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;LocalQueryComparisonOptions&quot;;
        
    &#x2F;&#x2F; 
    &#x2F;**
    Case insensitive SQL compliant options - this is also the default unless otherwise changed.
    @property caseInsensitiveSQL {LocalQueryComparisonOptions}
    @static
    **&#x2F;
    ctor.caseInsensitiveSQL = new ctor({
        name: &quot;caseInsensitiveSQL&quot;,
        isCaseSensitive: false,
        usesSql92CompliantStringComparison: true
    });

    &#x2F;**
    The default value whenever LocalQueryComparisonOptions are not specified. By default this is &#x27;caseInsensitiveSQL&#x27;.
    @property defaultInstance {LocalQueryComparisonOptions}
    @static
    **&#x2F;
    ctor.defaultInstance = new ctor(ctor.caseInsensitiveSQL);

    &#x2F;**
    Sets the &#x27;defaultInstance&#x27; by creating a copy of the current &#x27;defaultInstance&#x27; and then applying all of the properties of the current instance. 
    The current instance is returned unchanged.
    @method setAsDefault
    @example
        var lqco = new LocalQueryComparisonOptions({
            isCaseSensitive: false;
            usesSql92CompliantStringComparison: true;
        });
        lqco.setAsDefault();
    @chainable
    **&#x2F;
    proto.setAsDefault = function () {
        return __setAsDefault(this, ctor);
    };


    return ctor;
})();
    
var NamingConvention = (function () {
    &#x2F;**
    A NamingConvention instance is used to specify the naming conventions under which a MetadataStore 
    will translate property names between the server and the javascript client. 
    
    The default NamingConvention does not perform any translation, it simply passes property names thru unchanged.
    
    @class NamingConvention
    **&#x2F;
        
    &#x2F;**
    NamingConvention constructor

    @example
        &#x2F;&#x2F; A naming convention that converts the first character of every property name to uppercase on the server
        &#x2F;&#x2F; and lowercase on the client.
        var namingConv = new NamingConvention({
            serverPropertyNameToClient: function(serverPropertyName) {
                return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);
            },
            clientPropertyNameToServer: function(clientPropertyName) {
                return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);
            }            
        });
    var ms = new MetadataStore({ namingConvention: namingConv });
    var em = new EntityManager( { metadataStore: ms });
    @method &lt;ctor&gt; NamingConvention
    @param config {Object}
    @param config.serverPropertyNameToClient {Function} Function that takes a server property name add converts it into a client side property name.  
    @param config.clientPropertyNameToServer {Function} Function that takes a client property name add converts it into a server side property name.  
    **&#x2F;
    var ctor = function(config) {
        assertConfig(config || {})
            .whereParam(&quot;name&quot;).isOptional().isString()
            .whereParam(&quot;serverPropertyNameToClient&quot;).isFunction()
            .whereParam(&quot;clientPropertyNameToServer&quot;).isFunction()
            .applyAll(this);
        if (!this.name) {
            this.name = __getUuid();
        }
        __config._storeObject(this, proto._$typeName, this.name);
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;NamingConvention&quot;;
        
    &#x2F;**
    The function used to convert server side property names to client side property names.

    @method serverPropertyNameToClient
    @param serverPropertyName {String}
    @param [property] {DataProperty|NavigationProperty} The actual DataProperty or NavigationProperty corresponding to the property name.
    @return {String} The client side property name.
    **&#x2F;

    &#x2F;**
    The function used to convert client side property names to server side property names.

    @method clientPropertyNameToServer
    @param clientPropertyName {String}
    @param [property] {DataProperty|NavigationProperty} The actual DataProperty or NavigationProperty corresponding to the property name.
    @return {String} The server side property name.
    **&#x2F;
        
    &#x2F;**
    A noop naming convention - This is the default unless another is specified.
    @property none {NamingConvention}
    @static
    **&#x2F;
    ctor.none = new ctor({
        name: &quot;noChange&quot;,
        serverPropertyNameToClient: function(serverPropertyName) {
            return serverPropertyName;
        },
        clientPropertyNameToServer: function(clientPropertyName) {
            return clientPropertyName;
        }
    });
        
    &#x2F;**
    The &quot;camelCase&quot; naming convention - This implementation only lowercases the first character of the server property name
    but leaves the rest of the property name intact.  If a more complicated version is needed then one should be created via the ctor.
    @property camelCase {NamingConvention}
    @static
    **&#x2F;
    ctor.camelCase = new ctor({
        name: &quot;camelCase&quot;,
        serverPropertyNameToClient: function (serverPropertyName) {
            return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);
        },
        clientPropertyNameToServer: function (clientPropertyName) {
            return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);
        }
    });
        
    &#x2F;**
    The default value whenever NamingConventions are not specified.
    @property defaultInstance {NamingConvention}
    @static
    **&#x2F;
    ctor.defaultInstance = new ctor(ctor.none);
        
    &#x2F;**
    Sets the &#x27;defaultInstance&#x27; by creating a copy of the current &#x27;defaultInstance&#x27; and then applying all of the properties of the current instance. 
    The current instance is returned unchanged.
    @method setAsDefault
    @example
        var namingConv = new NamingConvention({
            serverPropertyNameToClient: function(serverPropertyName) {
                return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);
            },
            clientPropertyNameToServer: function(clientPropertyName) {
                return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);
            }            
        });
        namingConv.setAsDefault();
    @chainable
    **&#x2F;
    proto.setAsDefault = function () {
        return __setAsDefault(this, ctor);
    };
        
    return ctor;
})();
    
var MetadataStore = (function () {

    &#x2F;**
    An instance of the MetadataStore contains all of the metadata about a collection of {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}}&#x27;s.
    MetadataStores may be shared across {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}}&#x27;s.  If an EntityManager is created without an
    explicit MetadataStore, the MetadataStore from the MetadataStore.defaultInstance property will be used.
    @class MetadataStore
    **&#x2F;

    var __id = 0;
        
    &#x2F;**
    Constructs a new MetadataStore.  
    @example
        var ms = new MetadataStore();
    The store can then be associated with an EntityManager
    @example
        var entityManager = new EntityManager( {
            serviceName: &quot;api&#x2F;NorthwindIBModel&quot;, 
            metadataStore: ms 
        });
    or for an existing EntityManager
    @example
        &#x2F;&#x2F; Assume em1 is an existing EntityManager
        em1.setProperties( { metadataStore: ms });
    @method &lt;ctor&gt; MetadataStore
    @param [config] {Object} Configuration settings .
    @param [config.namingConvention=NamingConvention.defaultInstance] {NamingConvention} NamingConvention to be used in mapping property names
    between client and server. Uses the NamingConvention.defaultInstance if not specified.
    @param [config.localQueryComparisonOptions=LocalQueryComparisonOptions.defaultInstance] {LocalQueryComparisonOptions} The LocalQueryComparisonOptions to be
    used when performing &quot;local queries&quot; in order to match the semantics of queries against a remote service. 
    **&#x2F;
    var ctor = function (config) {
        config = config || { };
        assertConfig(config)
            .whereParam(&quot;namingConvention&quot;).isOptional().isInstanceOf(NamingConvention).withDefault(NamingConvention.defaultInstance)
            .whereParam(&quot;localQueryComparisonOptions&quot;).isOptional().isInstanceOf(LocalQueryComparisonOptions).withDefault(LocalQueryComparisonOptions.defaultInstance)
            .applyAll(this);
        this.dataServices = []; &#x2F;&#x2F; array of dataServices;
        this._resourceEntityTypeMap = {}; &#x2F;&#x2F; key is resource name - value is qualified entityType name
        this._structuralTypeMap = {}; &#x2F;&#x2F; key is qualified structuraltype name - value is structuralType. ( structural = entityType or complexType).
        this._shortNameMap = {}; &#x2F;&#x2F; key is shortName, value is qualified name - does not need to be serialized.
        this._ctorRegistry = {}; &#x2F;&#x2F; key is either short or qual type name - value is ctor;
        this._incompleteTypeMap = {}; &#x2F;&#x2F; key is entityTypeName; value is map where key is assocName and value is navProp
        this._id = __id++;
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;MetadataStore&quot;;
    ctor.ANONTYPE_PREFIX = &quot;_IB_&quot;;

    &#x2F;**
    Adds a DataService to this MetadataStore. If a DataService with the same serviceName is already
    in the MetadataStore an exception will be thrown. 
    @method addDataService
    @param dataService {DataService} The DataService to add
    **&#x2F;
        
    proto.addDataService = function(dataService, shouldOverwrite) {
        assertParam(dataService, &quot;dataService&quot;).isInstanceOf(DataService).check();
        assertParam(shouldOverwrite, &quot;shouldOverwrite&quot;).isBoolean().isOptional().check();
        var ix = this._getDataServiceIndex(dataService.serviceName);
        if (ix &gt;= 0) {
            if (!!shouldOverwrite) {
                this.dataServices[ix] = dataService;
            } else {
                throw new Error(&quot;A dataService with this name &#x27;&quot; + dataService.serviceName + &quot;&#x27; already exists in this MetadataStore&quot;);
            }
        } else {
            this.dataServices.push(dataService);
        }
    };

    proto._getDataServiceIndex = function (serviceName) {
        return __arrayIndexOf(this.dataServices, function(ds) {
            return ds.serviceName === serviceName;
        });
    };

    &#x2F;**
    Adds an EntityType to this MetadataStore.  No additional properties may be added to the EntityType after its has
    been added to the MetadataStore.
    @method addEntityType
    @param structuralType {EntityType|ComplexType} The EntityType or ComplexType to add
    **&#x2F;
    proto.addEntityType = function (structuralType) {
        structuralType.metadataStore = this;
        &#x2F;&#x2F; don&#x27;t register anon types
        if (!structuralType.isAnonymous) {
            this._structuralTypeMap[structuralType.name] = structuralType;
            this._shortNameMap[structuralType.shortName] = structuralType.name;
        }
        structuralType._fixup();
                                  
        structuralType.getProperties().forEach(function (property) {
            if (!property.isUnmapped) {
                structuralType._mappedPropertiesCount++;
            }
        });
        checkTypeRegistry(this, structuralType);
    };
        
    &#x2F;**
    The  {{#crossLink &quot;NamingConvention&quot;}}{{&#x2F;crossLink}} associated with this MetadataStore.

    __readOnly__
    @property namingConvention {NamingConvention}
    **&#x2F;
        
    &#x2F;**
    Exports this MetadataStore to a serialized string appropriate for local storage.   This operation is also called 
    internally when exporting an EntityManager. 
    @example
        &#x2F;&#x2F; assume ms is a previously created MetadataStore
        var metadataAsString = ms.exportMetadata();
        window.localStorage.setItem(&quot;metadata&quot;, metadataAsString);
        &#x2F;&#x2F; and later, usually in a different session imported
        var metadataFromStorage = window.localStorage.getItem(&quot;metadata&quot;);
        var newMetadataStore = new MetadataStore();
        newMetadataStore.importMetadata(metadataFromStorage);
    @method exportMetadata
    @return {String} A serialized version of this MetadataStore that may be stored locally and later restored. 
    **&#x2F;
    proto.exportMetadata = function () {
        var result = JSON.stringify({
            &quot;metadataVersion&quot;: breeze.metadataVersion,
            &quot;namingConvention&quot;: this.namingConvention.name,
            &quot;localQueryComparisonOptions&quot;: this.localQueryComparisonOptions.name,
            &quot;dataServices&quot;: this.dataServices,
            &quot;structuralTypeMap&quot;: this._structuralTypeMap,
            &quot;resourceEntityTypeMap&quot;: this._resourceEntityTypeMap,
        }, __config.stringifyPad);
        return result;
    };

    &#x2F;**
    Imports a previously exported serialized MetadataStore into this MetadataStore.
    @example
        &#x2F;&#x2F; assume ms is a previously created MetadataStore
        var metadataAsString = ms.exportMetadata();
        window.localStorage.setItem(&quot;metadata&quot;, metadataAsString);
        &#x2F;&#x2F; and later, usually in a different session
        var metadataFromStorage = window.localStorage.getItem(&quot;metadata&quot;);
        var newMetadataStore = new MetadataStore();
        newMetadataStore.importMetadata(metadataFromStorage);
    @method importMetadata
    @param exportedMetadata {String|JSON Object} A previously exported MetadataStore.
    @return {MetadataStore} This MetadataStore.
    @chainable
    **&#x2F;
    proto.importMetadata = function (exportedMetadata) {
        var json = (typeof (exportedMetadata) === &quot;string&quot;) ? JSON.parse(exportedMetadata) : exportedMetadata;
        if (json.metadataVersion &amp;&amp; json.metadataVersion !== breeze.metadataVersion) {
            var msg = __formatString(&quot;Cannot import metadata with a different &#x27;metadataVersion&#x27; (%1) than the current &#x27;breeze.metadataVersion&#x27; (%2) &quot;,
                json.metadataVersion, breeze.metadataVersion);
            throw new Error(msg);
        }

        var ncName = json.namingConvention;
        var lqcoName = json.localQueryComparisonOptions;
        if (this.isEmpty()) {
            this.namingConvention = __config._fetchObject(NamingConvention, ncName) || NamingConvention.defaultInstance
            this.localQueryComparisonOptions = __config._fetchObject(LocalQueryComparisonOptions, lqcoName) || LocalQueryComparisonOptions.defaultInstance;
        } else {
            if (ncName &amp;&amp; this.namingConvention.name !== ncName) {
                throw new Error(&quot;Cannot import metadata with a different &#x27;namingConvention&#x27; from the current MetadataStore&quot;);
            }
            if (lqcoName &amp;&amp; this.localQueryComparisonOptions.name !== lqcoName) {
                throw new Error(&quot;Cannot import metadata with different &#x27;localQueryComparisonOptions&#x27; from the current MetadataStore&quot;);
            }
        }
        
        var that = this;
        
        json.dataServices &amp;&amp; json.dataServices.forEach(function (ds) {
            ds = DataService.fromJSON(ds);
            that.addDataService(ds, true);
        });
        var structuralTypeMap = this._structuralTypeMap;
        __objectForEach(json.structuralTypeMap, function (key, value) {
            structuralTypeMap[key] = structuralTypeFromJson(that, value);
        });
        __extend(this._resourceEntityTypeMap, json.resourceEntityTypeMap);
        __extend(this._incompleteTypeMap, json.incompleteTypeMap);
       
        return this;
    };       

    &#x2F;**
    Creates a new MetadataStore from a previously exported serialized MetadataStore
    @example
        &#x2F;&#x2F; assume ms is a previously created MetadataStore
        var metadataAsString = ms.exportMetadata();
        window.localStorage.setItem(&quot;metadata&quot;, metadataAsString);
        &#x2F;&#x2F; and later, usually in a different session
        var metadataFromStorage = window.localStorage.getItem(&quot;metadata&quot;);
        var newMetadataStore = MetadataStore.importMetadata(metadataFromStorage);
    @method importMetadata
    @static
    @param exportedString {String} A previously exported MetadataStore.
    @return {MetadataStore} A new MetadataStore.
        
    **&#x2F;
    ctor.importMetadata = function(exportedString) {
        var ms = new MetadataStore();
        ms.importMetadata(exportedString);
        return ms;
    };

    &#x2F;**
    Returns whether Metadata has been retrieved for a specified service name.
    @example
        &#x2F;&#x2F; Assume em1 is an existing EntityManager.
        if (!em1.metadataStore.hasMetadataFor(&quot;api&#x2F;NorthwindIBModel&quot;))) {
            &#x2F;&#x2F; do something interesting
        }
    @method hasMetadataFor
    @param serviceName {String} The service name.
    @return {Boolean}
    **&#x2F;
    proto.hasMetadataFor = function(serviceName) {
        return !!this.getDataService(serviceName);
    };
        
    &#x2F;**
    Returns the DataService for a specified service name
    @example
        &#x2F;&#x2F; Assume em1 is an existing EntityManager.
        var ds = em1.metadataStore.getDataService(&quot;api&#x2F;NorthwindIBModel&quot;);
        var adapterName = ds.adapterName; &#x2F;&#x2F; may be null
           
    @method getDataService
    @param serviceName {String} The service name.
    @return {Boolean}
    **&#x2F;
    proto.getDataService = function (serviceName) {
        assertParam(serviceName, &quot;serviceName&quot;).isString().check();

        serviceName = DataService._normalizeServiceName(serviceName);
        return __arrayFirst(this.dataServices, function (ds) {
            return ds.serviceName === serviceName;
        });
    };

    &#x2F;**
    Fetches the metadata for a specified &#x27;service&#x27;. This method is automatically called 
    internally by an EntityManager before its first query against a new service.  

    @example
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    @example
        var ms = new MetadataStore();
        &#x2F;&#x2F; or more commonly
        &#x2F;&#x2F; var ms = anEntityManager.metadataStore;
        ms.fetchMetadata(&quot;api&#x2F;NorthwindIBModel&quot;)
        .then(function(rawMetadata) {
            &#x2F;&#x2F; do something with the metadata
        }
        .fail(function(exception) {
            &#x2F;&#x2F; handle exception here
        };
    @method fetchMetadata
    @async
    @param dataService {DataService|String}  Either a DataService or just the name of the DataService to fetch metadata for.
        
    @param [callback] {Function} Function called on success.
        
        successFunction([data])
        @param [callback.data] {rawMetadata} 
  
    @param [errorCallback] {Function} Function called on failure.

        failureFunction([error])
        @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.

    @return {Promise} Promise
    **&#x2F;
    proto.fetchMetadata = function (dataService, callback, errorCallback) {
        assertParam(dataService, &quot;dataService&quot;).isString().or().isInstanceOf(DataService).check();
        assertParam(callback, &quot;callback&quot;).isFunction().isOptional().check();
        assertParam(errorCallback, &quot;errorCallback&quot;).isFunction().isOptional().check();
            
        if (typeof dataService === &quot;string&quot;) {
            &#x2F;&#x2F; use the dataService with a matching name or create a new one.
            dataService = this.getDataService(dataService) || new DataService({ serviceName: dataService });
        }
           
        if (this.hasMetadataFor(dataService.serviceName)) {
            throw new Error(&quot;Metadata for a specific serviceName may only be fetched once per MetadataStore. ServiceName: &quot; + dataService.serviceName);
        }
            

        var deferred = Q.defer();
        dataService.adapterInstance.fetchMetadata(this, dataService, deferred.resolve, deferred.reject);
        return deferred.promise.then(function (rawMetadata) {
            if (callback) callback(rawMetadata);
            return Q.resolve(rawMetadata);
        }, function (error) {
            if (errorCallback) errorCallback(error);
            return Q.reject(error);
        });
    };


    &#x2F;**
    Used to register a constructor for an EntityType that is not known via standard Metadata discovery; 
    i.e. an unmapped type.  

    @method trackUnmappedType
    @param entityCtor {Function} The constructor for the &#x27;unmapped&#x27; type. 
    @param [interceptor] {Function} A function
    **&#x2F;
    proto.trackUnmappedType = function (entityCtor, interceptor) {
        assertParam(entityCtor, &quot;entityCtor&quot;).isFunction().check();
        assertParam(interceptor, &quot;interceptor&quot;).isFunction().isOptional().check();
        &#x2F;&#x2F; TODO: think about adding this to the MetadataStore.
        var entityType = new EntityType(this);
        entityType._setCtor(entityCtor, interceptor);
    };

    &#x2F;**
    Provides a mechanism to register a &#x27;custom&#x27; constructor to be used when creating new instances
    of the specified entity type.  If this call is not made, a default constructor is created for
    the entity as needed.
    This call may be made before or after the corresponding EntityType has been discovered via
    Metadata discovery.
    @example
        var Customer = function () {
            this.miscData = &quot;asdf&quot;;
        };
        Customer.prototype.doFoo() {
            ...
        }
        &#x2F;&#x2F; assume em1 is a preexisting EntityManager;
        em1.metadataStore.registerEntityTypeCtor(&quot;Customer&quot;, Customer);
        &#x2F;&#x2F; any queries or EntityType.create calls from this point on will call the Customer constructor
        &#x2F;&#x2F; registered above.
    @method registerEntityTypeCtor
    @param structuralTypeName {String} The name of the EntityType o0r ComplexType.
    @param aCtor {Function}  The constructor for this EntityType or ComplexType; may be null if all you want to do is set the next parameter. 
    @param [initializationFn] {Function} A function or the name of a function on the entity that is to be executed immediately after the entity has been created
    and populated with any initial values.
            
    initializationFn(entity)
    @param initializationFn.entity {Entity} The entity being created or materialized.
    **&#x2F;
    proto.registerEntityTypeCtor = function (structuralTypeName, aCtor, initializationFn) {
        assertParam(structuralTypeName, &quot;structuralTypeName&quot;).isString().check();
        assertParam(aCtor, &quot;aCtor&quot;).isFunction().isOptional().check();
        assertParam(initializationFn, &quot;initializationFn&quot;).isOptional().isFunction().or().isString().check();
        if (!aCtor) {
            aCtor = createEmptyCtor();
        }
        var qualifiedTypeName = getQualifiedTypeName(this, structuralTypeName, false);
        var typeName;
        if (qualifiedTypeName) {
            var stype = this._structuralTypeMap[qualifiedTypeName];
            if (stype) {
                stype._setCtor(aCtor);
            }
            typeName = qualifiedTypeName;
        } else {
            typeName = structuralTypeName;
        }
        aCtor.prototype._$typeName = typeName;
        this._ctorRegistry[typeName] = aCtor;
        if (initializationFn) {
            aCtor._$initializationFn = initializationFn;
        }
    };
    
    proto.toQueryString = function(query) {
        if (!query) {
            throw new Error(&quot;query cannot be empty&quot;);
        }
        if (typeof query === &#x27;string&#x27;) {
            return query;
        } else if (query instanceof EntityQuery) {
            return query._toUri(this);
        } else {
            throw new Error(&quot;unable to recognize query parameter as either a string or an EntityQuery&quot;);
        }
    }
      
    function createEmptyCtor() {
        return function() {};
    }
        
    &#x2F;**
    Returns whether this MetadataStore contains any metadata yet.
    @example
        &#x2F;&#x2F; assume em1 is a preexisting EntityManager;
        if (em1.metadataStore.isEmpty()) {
            &#x2F;&#x2F; do something interesting
        }
    @method isEmpty
    @return {Boolean}
    **&#x2F;
    proto.isEmpty = function () {
        return __isEmpty(this._structuralTypeMap);
    };


    &#x2F;**
    Returns an  {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} or a {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}} given its name.
    @example
        &#x2F;&#x2F; assume em1 is a preexisting EntityManager
        var odType = em1.metadataStore.getEntityType(&quot;OrderDetail&quot;);
    or to throw an error if the type is not found
    @example
        var badType = em1.metadataStore.getEntityType(&quot;Foo&quot;, false);
        &#x2F;&#x2F; badType will not get set and an exception will be thrown.
    @method getEntityType
    @param structuralTypeName {String}  Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown. 
    @param [okIfNotFound=false] {Boolean} Whether to throw an error if the specified EntityType is not found.
    @return {EntityType|ComplexType} The EntityType. ComplexType or &#x27;undefined&#x27; if not not found.
    **&#x2F;
    proto.getEntityType = function (structuralTypeName, okIfNotFound) {
        assertParam(structuralTypeName, &quot;structuralTypeName&quot;).isString().check();
        assertParam(okIfNotFound, &quot;okIfNotFound&quot;).isBoolean().isOptional().check(false);
        return getTypeFromMap(this, this._structuralTypeMap, structuralTypeName, okIfNotFound);
    };

    &#x2F;**
    Returns an array containing all of the  {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}}s or {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}}s in this MetadataStore.
    @example
        &#x2F;&#x2F; assume em1 is a preexisting EntityManager
        var allTypes = em1.metadataStore.getEntityTypes();
    @method getEntityTypes
    @return {Array of EntityType|ComplexType}
    **&#x2F;
    proto.getEntityTypes = function () {
        return getTypesFromMap(this._structuralTypeMap);
    };
        
        
    function getTypeFromMap(metadataStore, typeMap, typeName, okIfNotFound) {
            
        var qualTypeName = getQualifiedTypeName(metadataStore, typeName, false);
        var type = typeMap[qualTypeName];
        if (!type) {
            if (okIfNotFound) return null;
            throw new Error(&quot;Unable to locate a &#x27;Type&#x27; by the name: &quot; + typeName);
        }
        if (type.length) {
            var typeNames = type.join(&quot;,&quot;);
            throw new Error(&quot;There are multiple types with this &#x27;shortName&#x27;: &quot; + typeNames);
        }
        return type;
    };
        
    function getTypesFromMap(typeMap) {
        var types = [];
        for (var key in typeMap) {
            var value = typeMap[key];
            &#x2F;&#x2F; skip &#x27;shortName&#x27; entries
            if (key === value.name) {
                types.push(typeMap[key]);
            }
        }
        return types;
    }

    proto.getIncompleteNavigationProperties = function() {
        return __objectMapToArray(this._structuralTypeMap, function (key, value) {
            if (value instanceof ComplexType) return null;
            var badProps = value.navigationProperties.filter(function(np) {
                return !np.entityType;
            });
            return badProps.length === 0 ? null : badProps;
        });
    };


    &#x2F;**
    Returns a fully qualified entityTypeName for a specified resource name.  The reverse of this operation
    can be obtained via the  {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} &#x27;defaultResourceName&#x27; property
    @method getEntityTypeNameForResourceName
    @param resourceName {String}
    **&#x2F;
    proto.getEntityTypeNameForResourceName = function (resourceName) {
        assertParam(resourceName, &quot;resourceName&quot;).isString().check();
        return this._resourceEntityTypeMap[resourceName];
    };

    &#x2F;**
    Associates a resourceName with an entityType. 

    This method is only needed in those cases where multiple resources return the same
    entityType.  In this case Metadata discovery will only determine a single resource name for 
    each entityType.
    @method setEntityTypeForResourceName
    @param resourceName {String}
    @param entityTypeOrName {EntityType|String} If passing a string either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown. If the entityType has not yet been discovered then a fully qualified name must be used.
    **&#x2F;
    proto.setEntityTypeForResourceName = function (resourceName, entityTypeOrName) {
        assertParam(resourceName, &quot;resourceName&quot;).isString().check();
        assertParam(entityTypeOrName, &quot;entityTypeOrName&quot;).isInstanceOf(EntityType).or().isString().check();
        
        var entityTypeName;
        if (entityTypeOrName instanceof EntityType) {
            entityTypeName = entityTypeOrName.name;
        } else {
            entityTypeName = getQualifiedTypeName(this, entityTypeOrName, true);
        }

        this._resourceEntityTypeMap[resourceName] = entityTypeName;
        var entityType = this.getEntityType(entityTypeName, true);
        if (entityType &amp;&amp; !entityType.defaultResourceName) {
            entityType.defaultResourceName = resourceName;
        }
    };

    &#x2F;&#x2F; protected methods

    
        
    proto._checkEntityType = function(entity) {
        if (entity.entityType) return;
        var typeName = entity.prototype._$typeName;
        if (!typeName) {
            throw new Error(&quot;This entity has not been registered. See the MetadataStore.registerEntityTypeCtor method&quot;);
        }
        var entityType = this.getEntityType(typeName);
        if (entityType) {
            entity.entityType = entityType;
        }
    };
       
    proto._parseODataMetadata = function (serviceName, schemas) {
        var that = this;
            
        toArray(schemas).forEach(function (schema) {
            if (schema.cSpaceOSpaceMapping) {
                &#x2F;&#x2F; Web api only - not avail in OData.
                var mappings = JSON.parse(schema.cSpaceOSpaceMapping);
                var newMap = {};
                mappings.forEach(function(mapping) {
                    newMap[mapping[0]] = mapping[1];
                });
                schema.cSpaceOSpaceMapping = newMap;
            }
            var entityTypeDefaultResourceNameMap = {};
            if (schema.entityContainer) {
                toArray(schema.entityContainer).forEach(function (container) {
                    toArray(container.entitySet).forEach(function (entitySet) {
                        var entityTypeName = normalizeTypeName(entitySet.entityType, schema).typeName;
                        that.setEntityTypeForResourceName(entitySet.name, entityTypeName);
                        entityTypeDefaultResourceNameMap[entityTypeName] = entitySet.name;
                    });
                });
            }
               
            &#x2F;&#x2F; process complextypes before entity types.
            if (schema.complexType) {
                toArray(schema.complexType).forEach(function (ct) {
                    var complexType = convertFromODataComplexType(ct, schema, that);
                });
            }
            if (schema.entityType) {
                toArray(schema.entityType).forEach(function (et) {
                    var entityType = convertFromODataEntityType(et, schema, that);
                    entityType.defaultResourceName = entityTypeDefaultResourceNameMap[entityType.name];
                });
            }

        });
        var badNavProps = this.getIncompleteNavigationProperties();
        if (badNavProps.length &gt; 0) {
            throw new Error(&quot;Bad nav properties&quot;);
        }
    };

    function structuralTypeFromJson(metadataStore, json) {
        var typeName = qualifyTypeName(json.shortName, json.namespace);
        var stype = metadataStore.getEntityType(typeName, true);
        if (stype) return stype;
        var config = {
            shortName: json.shortName,
            namespace: json.namespace
        };
        var isEntityType = !json.isComplexType;
        stype = isEntityType ? new EntityType(config) : new ComplexType(config);

        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }

        if (json.dataProperties) {
            json.dataProperties = json.dataProperties.map(function(dp) {
                return DataProperty.fromJSON(dp, stype);
            });
        }
        
        if (isEntityType) {
            json.autoGeneratedKeyType = AutoGeneratedKeyType.fromName(json.autoGeneratedKeyType);
            if (json.navigationProperties) {
                json.navigationProperties = json.navigationProperties.map(function(np) {
                    return NavigationProperty.fromJSON(np, stype);
                });
            }
        }
        stype = __extend(stype, json);
        metadataStore.addEntityType(stype);
        return stype;
    };
        
    function checkTypeRegistry(metadataStore, structuralType) {
        structuralType.defaultResourceName &amp;&amp; metadataStore.setEntityTypeForResourceName(structuralType.defaultResourceName, structuralType.name);
        &#x2F;&#x2F; check if this structural type&#x27;s name, short version or qualified version has a registered ctor.
        var typeCtor = metadataStore._ctorRegistry[structuralType.name] || metadataStore._ctorRegistry[structuralType.shortName];
        if (typeCtor) {
            &#x2F;&#x2F; next line is in case the entityType was originally registered with a shortname.
            typeCtor.prototype._$typeName = structuralType.name;
            structuralType._setCtor(typeCtor);
        }
    }

    function getQualifiedTypeName(metadataStore, structTypeName, throwIfNotFound) {
        if (isQualifiedTypeName(structTypeName)) return structTypeName;
        var result = metadataStore._shortNameMap[structTypeName];
        if (!result &amp;&amp; throwIfNotFound) {
            throw new Error(&quot;Unable to locate &#x27;entityTypeName&#x27; of: &quot; + structTypeName);
        }
        return result;
    }

    function convertFromODataEntityType(odataEntityType, schema, metadataStore) {
        var shortName = odataEntityType.name;
        var ns = getNamespaceFor(shortName, schema);
        var entityType = new EntityType({
            shortName: shortName,
            namespace: ns
        });
        var keyNamesOnServer = toArray(odataEntityType.key.propertyRef).map(__pluck(&quot;name&quot;));
        toArray(odataEntityType.property).forEach(function (prop) {
            convertFromODataDataProperty(entityType, prop, schema, keyNamesOnServer);
        });
            
        toArray(odataEntityType.navigationProperty).forEach(function (prop) {
            convertFromODataNavProperty(entityType, prop, schema);
        });
        metadataStore.addEntityType(entityType);
        return entityType;
    }
        
      
    function convertFromODataComplexType(odataComplexType, schema, metadataStore) {
        var shortName = odataComplexType.name;
        var ns = getNamespaceFor(shortName, schema);
        var complexType = new ComplexType({
            shortName: shortName,
            namespace: ns
        });
            
        toArray(odataComplexType.property).forEach(function (prop) {
            convertFromODataDataProperty(complexType, prop, schema);
        });
            
        metadataStore.addEntityType(complexType);
        return complexType;
    }
        

    function convertFromODataDataProperty(parentType, odataProperty, schema, keyNamesOnServer) {
        var dp;
        var typeParts = odataProperty.type.split(&quot;.&quot;);
        if (typeParts.length == 2) {
            dp = convertFromODataSimpleProperty(parentType, odataProperty, keyNamesOnServer);
        } else {
            if (isEnumType(odataProperty, schema)) {
                dp = convertFromODataSimpleProperty(parentType, odataProperty, keyNamesOnServer);
                if (dp) {
                    dp.enumType = odataProperty.type;
                }
            } else {
                dp = convertFromODataComplexProperty(parentType, odataProperty, schema);
            }
        }
        if (dp) {
            parentType.addProperty(dp);
            addValidators(dp);
        }
        return dp;
    }
        
    function isEnumType(odataProperty, schema) {
        if (!schema.enumType) return false;
        var enumTypes = toArray(schema.enumType);
        var typeParts = odataProperty.type.split(&quot;.&quot;);
        var baseTypeName = typeParts[typeParts.length - 1];
        return enumTypes.some(function(enumType) {
            return enumType.name === baseTypeName;
        });
    }

    function convertFromODataSimpleProperty(parentType, odataProperty, keyNamesOnServer) {
            var dataType = DataType.fromEdmDataType(odataProperty.type);
            if (dataType == null) {
                parentType.warnings.push(&quot;Unable to recognize DataType for property: &quot; + odataProperty.name + &quot; DateType: &quot; + odataProperty.type);
                return null;
            }
            var isNullable = odataProperty.nullable === &#x27;true&#x27; || odataProperty.nullable == null;
            &#x2F;&#x2F; var fixedLength = odataProperty.fixedLength ? odataProperty.fixedLength === true : undefined;
            var isPartOfKey = keyNamesOnServer!=null &amp;&amp; keyNamesOnServer.indexOf(odataProperty.name) &gt;= 0;
            if (parentType.autoGeneratedKeyType == AutoGeneratedKeyType.None) {
                if (isIdentityProperty(odataProperty)) {
                    parentType.autoGeneratedKeyType = AutoGeneratedKeyType.Identity;
                }
            }
            &#x2F;&#x2F; TODO: nit - don&#x27;t set maxLength if null;
            var maxLength = odataProperty.maxLength;
            maxLength = (maxLength == null || maxLength===&quot;Max&quot;) ? null : parseInt(maxLength);
            &#x2F;&#x2F; can&#x27;t set the name until we go thru namingConventions and these need the dp.
            var dp = new DataProperty({
                nameOnServer: odataProperty.name,
                dataType: dataType,
                isNullable: isNullable,
                isPartOfKey: isPartOfKey,
                maxLength: maxLength,
                &#x2F;&#x2F; fixedLength: fixedLength,
                concurrencyMode: odataProperty.concurrencyMode
            });
            if (dataType === DataType.Undefined) {
                dp.rawTypeName = odataProperty.type;
            }
        return dp;
    }
        
    function convertFromODataComplexProperty(parentType, odataProperty, schema) {
            
        &#x2F;&#x2F; Complex properties are never nullable ( per EF specs)
        &#x2F;&#x2F; var isNullable = odataProperty.nullable === &#x27;true&#x27; || odataProperty.nullable == null;
        &#x2F;&#x2F; var complexTypeName = odataProperty.type.split(&quot;Edm.&quot;)[1];
        var complexTypeName = normalizeTypeName(odataProperty.type, schema).typeName;
        &#x2F;&#x2F; can&#x27;t set the name until we go thru namingConventions and these need the dp.
        var dp = new DataProperty({
            nameOnServer: odataProperty.name,
            complexTypeName: complexTypeName,
            isNullable: false
        });
            
        return dp;
    }

    function addValidators(dataProperty) {
        var typeValidator;
        if (!dataProperty.isNullable) {
            dataProperty.validators.push(Validator.required());
        }

        if (dataProperty.isComplexProperty) return;

        if (dataProperty.dataType === DataType.String) {
            if (dataProperty.maxLength) {
                var validatorArgs = { maxLength: dataProperty.maxLength };
                typeValidator = Validator.maxLength(validatorArgs);
            } else {
                typeValidator = Validator.string();
            }
        } else {
            typeValidator = dataProperty.dataType.validatorCtor();
        }

        dataProperty.validators.push(typeValidator);

    }

    function convertFromODataNavProperty(entityType, odataProperty, schema) {
        var association = getAssociation(odataProperty, schema);
        var toEnd = __arrayFirst(association.end, function (assocEnd) {
            return assocEnd.role === odataProperty.toRole;
        });
            
        var isScalar = !(toEnd.multiplicity === &quot;*&quot;);
        var dataType = normalizeTypeName(toEnd.type, schema).typeName;
        var fkNamesOnServer = [];
        if (toEnd &amp;&amp; isScalar) {
            var constraint = association.referentialConstraint;
            if (constraint) {
                var principal = constraint.principal;
                var dependent = constraint.dependent;
                var propRefs;
                if (odataProperty.fromRole === principal.role) {
                    propRefs = toArray(principal.propertyRef);
                } else {
                    propRefs = toArray(dependent.propertyRef);
                }
                &#x2F;&#x2F; will be used later by np._update
                fkNamesOnServer = propRefs.map(__pluck(&quot;name&quot;));
            }
        }
        var np = new NavigationProperty({
            nameOnServer: odataProperty.name,
            entityTypeName: dataType,
            isScalar: isScalar,
            associationName: association.name,
            foreignKeyNamesOnServer: fkNamesOnServer
        });
        entityType.addProperty(np);
       
        return np;
    }
        
    function isIdentityProperty(odataProperty) {
        &#x2F;&#x2F; see if web api feed
        var propName = __arrayFirst(Object.keys(odataProperty), function (pn) {
            return pn.indexOf(&quot;StoreGeneratedPattern&quot;) &gt;= 0;
        });
        if (propName) {
            return (odataProperty[propName] === &quot;Identity&quot;);
        } else {
            &#x2F;&#x2F; see if Odata feed
            var extensions = odataProperty.extensions;
            if (!extensions) {
                return false;
            }
            var identityExtn = __arrayFirst(extensions, function (extension) {
                return extension.name === &quot;StoreGeneratedPattern&quot; &amp;&amp; extension.value === &quot;Identity&quot;;
            });
            return !!identityExtn;
        }
    }

    
    &#x2F;&#x2F; Fast version
    &#x2F;&#x2F; np: schema.entityType[].navigationProperty.relationship -&gt; schema.association
    &#x2F;&#x2F;   match( shortName(np.relationship) == schema.association[].name
    &#x2F;&#x2F;      --&gt; association

    &#x2F;&#x2F; Correct version
    &#x2F;&#x2F; np: schema.entityType[].navigationProperty.relationship -&gt; schema.association
    &#x2F;&#x2F;   match( np.relationship == schema.entityContainer[0].associationSet[].association )
    &#x2F;&#x2F;      -&gt; associationSet.name
    &#x2F;&#x2F;   match ( associationSet.name == schema.association[].name )
    &#x2F;&#x2F;      -&gt; association

    function getAssociation(odataNavProperty, schema) {
        var assocName = normalizeTypeName(odataNavProperty.relationship, schema).shortTypeName;
        var assocs = schema.association;
        if (!assocs) return null;
        if (!Array.isArray(assocs)) {
            assocs = [assocs];
        }
        var association = __arrayFirst(assocs, function (assoc) {
            return assoc.name === assocName;
        });
        return association;
    }

    function toArray(item) {
        if (!item) {
            return [];
        } else if (Array.isArray(item)) {
            return item;
        } else {
            return [item];
        }
    }
        

    return ctor;
})();

var DataService = (function () {
        
    &#x2F;**
    A DataService instance is used to encapsulate the details of a single &#x27;service&#x27;; this includes a serviceName, a dataService adapterInstance, 
    and whether the service has server side metadata.  

    You can construct an EntityManager with either a serviceName or a DataService instance, if you use a serviceName then a DataService 
    is constructed for you.  (It can also be set via the EntityManager.setProperties method).

    The same applies to the MetadataStore.fetchMetadata method, i.e. it takes either a serviceName or a DataService instance.

    Each metadataStore contains a list of DataServices, each accessible via its ‘serviceName’. 
    ( see MetadataStore.getDataService and MetadataStore.addDataService).  The ‘addDataService’ method is called internally 
    anytime a MetadataStore.fetchMetadata call occurs with a new dataService ( or service name).
    @class DataService
    **&#x2F;

    &#x2F;**
    DataService constructor

    @example
        &#x2F;&#x2F; 
        var dataService = new DataService({
            serviceName: altServiceName,
            hasServerMetadata: false
        });

        var metadataStore = new MetadataStore({
            namingConvention: NamingConvention.camelCase
        });

        return new EntityManager({
            dataService: dataService,
            metadataStore: metadataStore
        });
            
    @method &lt;ctor&gt; DataService
    @param config {Object}
    @param config.serviceName {String} The name of the service. 
    @param [config.adapterName] {String} The name of the dataServiceAdapter to be used with this service. 
    @param [config.hasServerMetadata] {bool} Whether the server can provide metadata for this service.
    @param [config.jsonResultsAdapter] {JsonResultsAdapter}  The JsonResultsAdapter used to process the results of any query against this service.
    **&#x2F;
        
    var ctor = function(config) {
        if (arguments.length != 1) {
            throw new Error(&quot;The DataService ctor should be called with a single argument that is a configuration object.&quot;);
        }

        assertConfig(config)
            .whereParam(&quot;serviceName&quot;).isNonEmptyString()
            .whereParam(&quot;adapterName&quot;).isString().isOptional().withDefault(null)
            .whereParam(&quot;hasServerMetadata&quot;).isBoolean().isOptional().withDefault(true)
            .whereParam(&quot;jsonResultsAdapter&quot;).isInstanceOf(JsonResultsAdapter).isOptional().withDefault(null)
            .applyAll(this);
        this.serviceName = DataService._normalizeServiceName(this.serviceName);
        this.adapterInstance = __config.getAdapterInstance(&quot;dataService&quot;, this.adapterName);
            
        if (!this.jsonResultsAdapter) {
            this.jsonResultsAdapter = this.adapterInstance.jsonResultsAdapter;
        }
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;DataService&quot;;
        
    &#x2F;**
    The serviceName for this DataService.

    __readOnly__
    @property serviceName {String}
    **&#x2F;
        
    &#x2F;**
    The adapter name for the dataServiceAdapter to be used with this service.

    __readOnly__
    @property adapterName {String}
    **&#x2F;
        
    &#x2F;**
    The &quot;dataService&quot; adapter implementation instance associated with this EntityManager.

    __readOnly__
    @property adapterInstance {an instance of the &quot;dataService&quot; adapter interface}
    **&#x2F;

    &#x2F;**
    Whether the server can provide metadata for this service.

    __readOnly__
    @property hasServerMetadata {Boolean}
    **&#x2F;
        
    &#x2F;**
    The JsonResultsAdapter used to process the results of any query against this DataService.

    __readOnly__
    @property jsonResultsAdapter {Boolean}
    **&#x2F;
        
    ctor._normalizeServiceName = function(serviceName) {
        serviceName = serviceName.trim();
        if (serviceName.substr(-1) !== &quot;&#x2F;&quot;) {
            return serviceName + &#x27;&#x2F;&#x27;;
        } else {
            return serviceName;
        }
    };
        
    proto.toJSON = function () {
        return __toJson(this, {
            serviceName: null,
            adapterName: null,
            hasServerMetadata: true,
            jsonResultsAdapter: function(v) { return v &amp;&amp; v.name; }
        });
        
    };

    ctor.fromJSON = function(json) {
        json.jsonResultsAdapter = __config._fetchObject(JsonResultsAdapter, json.jsonResultsAdapter);
        return new DataService(json);
    };

    return ctor;
})();
    
var JsonResultsAdapter = (function () {

    &#x2F;**
    A JsonResultsAdapter instance is used to provide custom extraction and parsing logic on the json results returned by any web service. 
    This facility makes it possible for breeze to talk to virtually any web service and return objects that will be first class &#x27;breeze&#x27; citizens. 

    @class JsonResultsAdapter
    **&#x2F;

    &#x2F;**
    JsonResultsAdapter constructor

    @example
        &#x2F;&#x2F; 
        var jsonResultsAdapter = new JsonResultsAdapter({
            name: &quot;test1e&quot;,
            extractResults: function(json) {
                return json.results;
            },
            visitNode: function(node, queryContext, nodeContext) {
                var entityTypeName = normalizeTypeName(node.$type);
                var entityType = entityTypeName &amp;&amp; queryContext.entityManager.metadataStore.getEntityType(entityTypeName, true);
                var propertyName = nodeContext.propertyName;
                var ignore = propertyName &amp;&amp; propertyName.substr(0, 1) === &quot;$&quot;;

                return {
                    entityType: entityType,
                    nodeId: node.$id,
                    nodeRefId: node.$ref,
                    ignore: ignore
                };
            }
        });

        var dataService = new DataService( {
                serviceName: &quot;api&#x2F;foo&quot;,
                jsonResultsAdapter: jsonResultsAdapter
        });

        var entityManager = new EntityManager( {
            dataService: dataService
        });
            
    @method &lt;ctor&gt; JsonResultsAdapter
    @param config {Object}
    @param config.name {String} The name of this adapter.  This name is used to uniquely identify and locate this instance when an &#x27;exported&#x27; JsonResultsAdapter is later imported.
    @param [config.extractResults] {Function} Called once per service operation to extract the &#x27;payload&#x27; from any json received over the wire. 
    This method has a default implementation which to simply return the &quot;results&quot; property from any json returned as a result of executing the query.
    @param config.visitNode {Function} A visitor method that will be called on each node of the returned payload. 
    **&#x2F;
    var ctor = function (config) {
        if (arguments.length != 1) {
            throw new Error(&quot;The JsonResultsAdapter ctor should be called with a single argument that is a configuration object.&quot;);
        }

        assertConfig(config)
            .whereParam(&quot;name&quot;).isNonEmptyString()
            .whereParam(&quot;extractResults&quot;).isFunction().isOptional().withDefault(extractResultsDefault)
            .whereParam(&quot;visitNode&quot;).isFunction()
            .applyAll(this);
        __config._storeObject(this, proto._$typeName, this.name);
    };
        
    var proto = ctor.prototype;
    proto._$typeName = &quot;JsonResultsAdapter&quot;;
        
    function extractResultsDefault(data) {
        return data.results;
    }
        
    return ctor;
})();

var EntityType = (function () {
    &#x2F;**
    Container for all of the metadata about a specific type of Entity.
    @class EntityType
    **&#x2F;
    var __nextAnonIx = 0;
        

    &#x2F;** 
    @example                    
        var entityType = new EntityType( {
            shortName: &quot;person&quot;,
            namespace: &quot;myAppNamespace&quot;
            });
    @method &lt;ctor&gt; EntityType
    @param config {Object|MetadataStore} Configuration settings or a MetadataStore.  If this parameter is just a MetadataStore
    then what will be created is an &#x27;anonymous&#x27; type that will never be communicated to or from the server. It is purely for
    client side use and will be given an automatically generated name. Normally, however, you will use a configuration object.
    @param config.shortName {String}
    @param [config.namespace=&quot;&quot;] {String}
    @param [config.autogeneratedKeyType] {AutoGeneratedKeyType}
    @param [config.defaultResourceName] { String}
    **&#x2F;
    var ctor = function (config) {
        if (arguments.length &gt; 1) {
            throw new Error(&quot;The EntityType ctor has a single argument that is either a &#x27;MetadataStore&#x27; or a configuration object.&quot;);
        }
        if  (config._$typeName === &quot;MetadataStore&quot;) {
            this.metadataStore = config;
            this.shortName = &quot;Anon_&quot; + ++__nextAnonIx;
            this.namespace = &quot;&quot;;
            this.isAnonymous = true;
        } else {
            assertConfig(config)
                .whereParam(&quot;shortName&quot;).isNonEmptyString()
                .whereParam(&quot;namespace&quot;).isString().isOptional().withDefault(&quot;&quot;)
                .whereParam(&quot;autoGeneratedKeyType&quot;).isEnumOf(AutoGeneratedKeyType).isOptional().withDefault(AutoGeneratedKeyType.None)
                .whereParam(&quot;defaultResourceName&quot;).isNonEmptyString().isOptional().withDefault(null)
                .applyAll(this);
        }

        this.name = qualifyTypeName(this.shortName, this.namespace);
            
        &#x2F;&#x2F; the defaultResourceName may also be set up either via metadata lookup or first query or via the &#x27;setProperties&#x27; method
            
        this.dataProperties = [];
        this.navigationProperties = [];
        this.complexProperties = [];
        this.keyProperties = [];
        this.foreignKeyProperties = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = []; &#x2F;&#x2F; will be updated later.
        this.validators = [];
        this.warnings = [];
        this._mappedPropertiesCount = 0;
            
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;EntityType&quot;;
        
        
    &#x2F;**
    The {{#crossLink &quot;MetadataStore&quot;}}{{&#x2F;crossLink}} that contains this EntityType

    __readOnly__
    @property metadataStore {MetadataStore}
    **&#x2F;
            
    &#x2F;**
    The DataProperties (see {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}}) associated with this EntityType.

    __readOnly__
    @property dataProperties {Array of DataProperty} 
    **&#x2F;
            
    &#x2F;**
    The NavigationProperties  (see {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}) associated with this EntityType.

    __readOnly__
    @property navigationProperties {Array of NavigationProperty} 
    **&#x2F;
        
    &#x2F;**
    The DataProperties for this EntityType that contain instances of a ComplexType (see {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}}).

    __readOnly__
    @property complexProperties {Array of DataProperty} 
    **&#x2F;
            
    &#x2F;**
    The DataProperties associated with this EntityType that make up it&#x27;s {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}}.

    __readOnly__
    @property keyProperties {Array of DataProperty} 
    **&#x2F;
            
    &#x2F;**
    The DataProperties associated with this EntityType that are foreign key properties.

    __readOnly__
    @property foreignKeyProperties {Array of DataProperty} 
    **&#x2F;
            
    &#x2F;**
    The DataProperties associated with this EntityType that are concurrency properties.

    __readOnly__
    @property concurrencyProperties {Array of DataProperty} 
    **&#x2F;

    &#x2F;**
    The DataProperties associated with this EntityType that are not mapped to any backend datastore. These are effectively free standing
    properties.

    __readOnly__
    @property unmappedProperties {Array of DataProperty} 
    **&#x2F;
            
    &#x2F;**
    The default resource name associated with this EntityType.  An EntityType may be queried via a variety of &#x27;resource names&#x27; but this one 
    is used as the default when no resource name is provided.  This will occur when calling {{#crossLink &quot;EntityAspect&#x2F;loadNavigationProperty&quot;}}{{&#x2F;crossLink}}
    or when executing any {{#crossLink &quot;EntityQuery&quot;}}{{&#x2F;crossLink}} that was created via an {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}}.

    __readOnly__
    @property defaultResourceName {String} 
    **&#x2F;

    &#x2F;**
    The fully qualifed name of this EntityType.

    __readOnly__
    @property name {String} 
    **&#x2F;

    &#x2F;**
    The short, unqualified, name for this EntityType.

    __readOnly__
    @property shortName {String} 
    **&#x2F;

    &#x2F;**
    The namespace for this EntityType.

    __readOnly__
    @property namespace {String} 
    **&#x2F;

    &#x2F;**
    The {{#crossLink &quot;AutoGeneratedKeyType&quot;}}{{&#x2F;crossLink}} for this EntityType.
        
    __readOnly__
    @property autoGeneratedKeyType {AutoGeneratedKeyType} 
    @default AutoGeneratedKeyType.None
    **&#x2F;

    &#x2F;**
    The entity level validators associated with this EntityType. Validators can be added and
    removed from this collection.

    __readOnly__
    @property validators {Array of Validator} 
    **&#x2F;

    &#x2F;**
    General purpose property set method
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        custType.setProperties( {
            autoGeneratedKeyType: AutoGeneratedKeyType.Identity;
            defaultResourceName: &quot;CustomersAndIncludedOrders&quot;
        )};
    @method setProperties
    @param config [object]
        @param [config.autogeneratedKeyType] {AutoGeneratedKeyType}
        @param [config.defaultResourceName] {String}
    **&#x2F;
    proto.setProperties = function (config) {
        assertConfig(config)
            .whereParam(&quot;autoGeneratedKeyType&quot;).isEnumOf(AutoGeneratedKeyType).isOptional()
            .whereParam(&quot;defaultResourceName&quot;).isString().isOptional()
            .applyAll(this);
        if (config.defaultResourceName) {
            this.defaultResourceName = config.defaultResourceName;
        }
    };

    &#x2F;**
    Adds a  {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} or a {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}} to this EntityType.
    @example
        &#x2F;&#x2F; assume myEntityType is a newly constructed EntityType. 
        myEntityType.addProperty(dataProperty1);
        myEntityType.addProperty(dataProperty2);
        myEntityType.addProperty(navigationProperty1);
    @method addProperty
    @param property {DataProperty|NavigationProperty}
    **&#x2F;
    proto.addProperty = function (property) {
        assertParam(property, &quot;dataProperty&quot;).isInstanceOf(DataProperty).or().isInstanceOf(NavigationProperty).check();
        if (this.metadataStore &amp;&amp; !property.isUnmapped) {
            throw new Error(&quot;The &#x27;&quot; + this.name + &quot;&#x27; EntityType has already been added to a MetadataStore and therefore no additional properties may be added to it.&quot;);
        }
        if (property.parentType) {
            if (property.parentType !== this) {
                throw new Error(&quot;This dataProperty has already been added to &quot; + property.parentType.name);
            } else {
                return this;
            }
        }
        property.parentType = this;
        if (property.isDataProperty) {
            this._addDataProperty(property);
        } else {
            this._addNavigationProperty(property);
        }
        return this;
    };
        


    &#x2F;**
    Create a new entity of this type.
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var cust1 = custType.createEntity();
        em1.addEntity(cust1);
    @method createEntity
    @param [initialValues] {Config object} - Configuration object of the properties to set immediately after creation.
    @return {Entity} The new entity.
    **&#x2F;
    proto.createEntity = function (initialValues) {
        var instance = this._createEntityCore();
            
        if (initialValues) {
            __objectForEach(initialValues, function(key, value) {
                instance.setProperty(key, value);
            });
        }
            
        instance.entityAspect._postInitialize();
        return instance;
    };

    proto._createEntityCore = function() {
        var aCtor = this.getEntityCtor();
        var instance = new aCtor();
        new EntityAspect(instance);
        return instance;
    };

    &#x2F;**
    Returns the constructor for this EntityType.
    @method getEntityCtor
    @return {Function} The constructor for this EntityType.
    **&#x2F;
    proto.getEntityCtor = function () {
        if (this._ctor) return this._ctor;
        var ctorRegistry = this.metadataStore._ctorRegistry;
        var aCtor = ctorRegistry[this.name] || ctorRegistry[this.shortName];
        if (!aCtor) {
            var createCtor = __modelLibraryDef.getDefaultInstance().createCtor;
            if (createCtor) {
                aCtor = createCtor(this);
            } else {
                aCtor = createEmptyCtor();
            }
        }
        this._setCtor(aCtor);
        return aCtor;
    };
        
    function createEmptyCtor() {
        return function() { };
    }

    &#x2F;&#x2F; May make public later.
    proto._setCtor = function (aCtor, interceptor) {
        var instance = new aCtor();
        var proto = aCtor.prototype;
            
        if (this._$typeName == &quot;EntityType&quot;) {
            &#x2F;&#x2F; insure that all of the properties are on the &#x27;template&#x27; instance before watching the class.
            calcUnmappedProperties(this, instance);
            proto.entityType = this;
        } else {
            calcUnmappedProperties(this, instance);
            proto.complexType = this;
        }

        if (interceptor) {
            proto._$interceptor = interceptor;
        } else {
            proto._$interceptor = defaultPropertyInterceptor;
        }

        __modelLibraryDef.getDefaultInstance().initializeEntityPrototype(proto);

        this._ctor = aCtor;
    };

    &#x2F;**
    Adds either an entity or property level validator to this EntityType.  
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var countryProp = custType.getProperty(&quot;Country&quot;);
        var valFn = function (v) {
            if (v == null) return true;
            return (core.stringStartsWith(v, &quot;US&quot;));
        };
        var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, 
            { displayName: &quot;Country&quot;, messageTemplate: &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot; });
        custType.addValidator(countryValidator, countryProp);
    This is the same as adding an entity level validator via the &#x27;validators&#x27; property of DataProperty or NavigationProperty
    @example
        countryProp.validators.push(countryValidator);
    Entity level validators can also be added by omitting the &#x27;property&#x27; parameter.
    @example
        custType.addValidator(someEntityLevelValidator);
    or
    @example
        custType.validators.push(someEntityLevelValidator);
    @method addValidator
    @param validator {Validator} Validator to add.
    @param [property] Property to add this validator to.  If omitted, the validator is assumed to be an
    entity level validator and is added to the EntityType&#x27;s &#x27;validators&#x27;.
    **&#x2F;
    proto.addValidator = function (validator, property) {
        assertParam(validator, &quot;validator&quot;).isInstanceOf(Validator).check();
        assertParam(property, &quot;property&quot;).isOptional().isString().or().isEntityProperty().check();
        if (property) {
            if (typeof (property) === &#x27;string&#x27;) {
                property = this.getProperty(property, true);
            }
            property.validators.push(validator);
        } else {
            this.validators.push(validator);
        }
    };

    &#x2F;**
    Returns all of the properties ( dataProperties and navigationProperties) for this EntityType.
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var arrayOfProps = custType.getProperties();
    @method getProperties
    @return {Array of DataProperty|NavigationProperty} Array of Data and Navigation properties.
    **&#x2F;
    proto.getProperties = function () {
        return this.dataProperties.concat(this.navigationProperties);
    };

    &#x2F;**
    Returns all of the property names ( for both dataProperties and navigationProperties) for this EntityType.
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var arrayOfPropNames = custType.getPropertyNames();
    @method getPropertyNames
    @return {Array of String}
    **&#x2F;
    proto.getPropertyNames = function () {
        return this.getProperties().map(__pluck(&#x27;name&#x27;));
    };

    &#x2F;**
    Returns a data property with the specified name or null.
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var customerNameDataProp = custType.getDataProperty(&quot;CustomerName&quot;);
    @method getDataProperty
    @param propertyName {String}
    @return {DataProperty} Will be null if not found.
    **&#x2F;
    proto.getDataProperty = function (propertyName, isServerName) {
        var propName = isServerName ? &quot;nameOnServer&quot; : &quot;name&quot;;
        return __arrayFirst(this.dataProperties, __propEq(propName, propertyName));
    };

    &#x2F;**
    Returns a navigation property with the specified name or null.
    @example
        &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var customerOrdersNavProp = custType.getDataProperty(&quot;Orders&quot;);
    @method getNavigationProperty
    @param propertyName {String}
    @return {NavigationProperty} Will be null if not found.
    **&#x2F;
    proto.getNavigationProperty = function (propertyName, isServerName) {
        var propName = isServerName ? &quot;nameOnServer&quot; : &quot;name&quot;;
        return __arrayFirst(this.navigationProperties, __propEq(propName, propertyName));
    };

    &#x2F;**
    Returns either a DataProperty or a NavigationProperty with the specified name or null.  

    This method also accepts a &#x27;.&#x27; delimited property path and will return the &#x27;property&#x27; at the 
    end of the path.
    @example
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var companyNameProp = custType.getProperty(&quot;CompanyName&quot;);
    This method can also walk a property path to return a property
    @example
        var orderDetailType = em1.metadataStore.getEntityType(&quot;OrderDetail&quot;);
        var companyNameProp2 = orderDetailType.getProperty(&quot;Order.Customer.CompanyName&quot;);
        &#x2F;&#x2F; companyNameProp === companyNameProp2 
    @method getProperty
    @param propertyPath {String}
    @param [throwIfNotFound=false] {Boolean} Whether to throw an exception if not found.
    @return {DataProperty|NavigationProperty} Will be null if not found.
    **&#x2F;
    proto.getProperty = function (propertyPath, throwIfNotFound) {
        throwIfNotFound = throwIfNotFound || false;
        var propertyNames = (Array.isArray(propertyPath)) ? propertyPath : propertyPath.trim().split(&#x27;.&#x27;);
        var propertyName = propertyNames[0];
        var prop = __arrayFirst(this.getProperties(), __propEq(&quot;name&quot;, propertyName));
        if (propertyNames.length === 1) {
            if (prop) {
                return prop;
            } else if (throwIfNotFound) {
                throw new Error(&quot;unable to locate property: &quot; + propertyName + &quot; on entityType: &quot; + this.name);
            } else {
                return null;
            }
        } else {
            if (prop) {
                propertyNames.shift();
                &#x2F;&#x2F; dataType is line below will be a complexType
                var nextParentType = prop.isNavigationProperty ? prop.entityType : prop.dataType;
                if (nextParentType) {
                    return nextParentType.getProperty(propertyNames, throwIfNotFound);
                } else {
                    throw new Error(&quot;should not get here - unknown property type for: &quot; + prop.name);
                }
            } else {
                if (throwIfNotFound) {
                    throw new Error(&quot;unable to locate property: &quot; + propertyName + &quot; on type: &quot; + this.name);
                } else {
                    return null;
                }
            }
        }
    };

    &#x2F;**
    Returns a string representation of this EntityType.
    @method toString
    @return {String}
    **&#x2F;
    proto.toString = function () {
        return this.name;
    };

    proto.toJSON = function () {
        return __toJson(this, {
            shortName: null,
            namespace: null,
            autoGeneratedKeyType: null, &#x2F;&#x2F; do not suppress default value
            defaultResourceName: null,
            dataProperties: null,
            navigationProperties: null,
            validators: null
        });
    };

    &#x2F;&#x2F; fromJSON is handled by structuralTypeFromJson function.
        
    proto._clientPropertyPathToServer = function (propertyPath) {
        var fn = this.metadataStore.namingConvention.clientPropertyNameToServer;
        var that = this;
        var serverPropPath = propertyPath.split(&quot;.&quot;).map(function (propName) {
            var prop = that.getProperty(propName);
            return fn(propName, prop);
        }).join(&quot;&#x2F;&quot;);
        return serverPropPath;
    };

    proto._updateProperty = function (property) {
        var nc = this.metadataStore.namingConvention;
        var serverName = property.nameOnServer;
        var clientName, testName;
        if (serverName) {
            clientName = nc.serverPropertyNameToClient(serverName, property);
            testName = nc.clientPropertyNameToServer(clientName, property);
            if (serverName !== testName) {
                throw new Error(&quot;NamingConvention for this server property name does not roundtrip properly:&quot; + serverName + &quot;--&gt;&quot; + testName);
            }
            property.name = clientName;
        } else {
            clientName = property.name;
            serverName = nc.clientPropertyNameToServer(clientName, property);
            testName = nc.serverPropertyNameToClient(serverName, property);
            if (clientName !== testName) {
                throw new Error(&quot;NamingConvention for this client property name does not roundtrip properly:&quot; + clientName + &quot;--&gt;&quot; + testName);
            }
            property.nameOnServer = serverName;
        }
            
        if (property.isComplexProperty) {
            &#x2F;&#x2F; Not ok to not find it. - all complex types should be resolved before they are ref&#x27;d.
            var targetComplexType = this.metadataStore.getEntityType(property.complexTypeName, false);
            if (targetComplexType &amp;&amp; targetComplexType instanceof ComplexType) {
                property.dataType = targetComplexType;
                property.defaultValue = null;
            } else {
                throw new Error(&quot;Unable to resolve ComplexType with the name: &quot; + property.complexTypeName + &quot; for the property: &quot; + property.name);
            }
        } else if (property.isNavigationProperty) {
            &#x2F;&#x2F; sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty
            resolveFks(property);
            &#x2F;&#x2F; Tries to set - these two may get set later
            &#x2F;&#x2F; this.inverse
            &#x2F;&#x2F; this.entityType
            updateCrossEntityRelationship(property);
                
        }
    };

    ctor._getNormalizedTypeName = __memoize(function (rawTypeName) {
        return rawTypeName &amp;&amp; normalizeTypeName(rawTypeName).typeName;
    });
    &#x2F;&#x2F; for debugging use the line below instead.
    &#x2F;&#x2F;ctor._getNormalizedTypeName = function (rawTypeName) { return normalizeTypeName(rawTypeName).typeName; };

    proto._checkNavProperty = function (navigationProperty) {
        if (navigationProperty.isNavigationProperty) {
            if (navigationProperty.parentType != this) {
                throw new Error(__formatString(&quot;The navigationProperty &#x27;%1&#x27; is not a property of entity type &#x27;%2&#x27;&quot;,
                        navigationProperty.name, this.name));
            }
            return navigationProperty;
        }

        if (typeof (navigationProperty) === &#x27;string&#x27;) {
            var np = this.getProperty(navigationProperty);
            if (np &amp;&amp; np.isNavigationProperty) return np;
        }
        throw new Error(&quot;The &#x27;navigationProperty&#x27; parameter must either be a NavigationProperty or the name of a NavigationProperty&quot;);
    };
        
    proto._addDataProperty = function (dp) {

        this.dataProperties.push(dp);
            
        if (dp.isPartOfKey) {
            this.keyProperties.push(dp);
        };
            
        if (dp.isComplexProperty) {
            this.complexProperties.push(dp);
        }

        if (dp.concurrencyMode &amp;&amp; dp.concurrencyMode !== &quot;None&quot;) {
            this.concurrencyProperties.push(dp);
        };

        if (dp.isUnmapped) {
            this.unmappedProperties.push(dp);
        }

    };

    proto._addNavigationProperty = function (np) {

        this.navigationProperties.push(np);

        if (!isQualifiedTypeName(np.entityTypeName)) {
            np.entityTypeName = qualifyTypeName(np.entityTypeName, this.namespace);
        }
    };

    proto._fixup = function () {
        var that = this;
        this.getProperties().forEach(function (property) {
            that._updateProperty(property);
        });
        updateIncomplete(this, true);
    };
    
    function resolveFks(np) {
        if (np.foreignKeyProperties) return;
        var fkProps = getFkProps(np);
        &#x2F;&#x2F; returns null if can&#x27;t yet finish
        if (!fkProps) return;

        fkProps.forEach(function (dp) {
            dp.relatedNavigationProperty = np;
            np.parentType.foreignKeyProperties.push(dp);
            if (np.relatedDataProperties) {
                np.relatedDataProperties.push(dp);
            } else {
                np.relatedDataProperties = [dp];
            }
        });
    };



    &#x2F;&#x2F; returns null if can&#x27;t yet finish
    function getFkProps(np) {
        var fkNames = np.foreignKeyNames;
        var isNameOnServer = fkNames.length == 0;
        if (isNameOnServer) {
            fkNames = np.foreignKeyNamesOnServer;
            if (fkNames.length == 0) {
                np.foreignKeyProperties = [];
                return np.foreignKeyProperties;
            }
        }
        var ok = true;
        var parentEntityType = np.parentType;
        var fkProps = fkNames.map(function (fkName) {
            var fkProp = parentEntityType.getDataProperty(fkName, isNameOnServer);
            ok = ok &amp;&amp; !!fkProp;
            return fkProp;
        });

        if (ok) {
            if (isNameOnServer) {
                np.foreignKeyNames = fkProps.map(__pluck(&quot;name&quot;));
            }
            np.foreignKeyProperties = fkProps;
            return fkProps;
        } else {
            return null;
        }
    }
    
    function updateIncomplete(entityType) {
        var incompleteTypeMap = entityType.metadataStore._incompleteTypeMap;
        var assocMap = incompleteTypeMap[entityType.name];

        assocMap &amp;&amp; __objectForEach(assocMap, function(assocName, np) {
            if (np.entityTypeName === entityType.name) {
                np.entityType = entityType;
                deleteIncomplete(incompleteTypeMap, entityType.name, assocName);
                
                var altAssocMap = incompleteTypeMap[np.parentType.name];
                altAssocMap &amp;&amp; __objectForEach(altAssocMap, function(altAssocName, altNp) {
                    if (altAssocName === assocName) {
                        deleteIncomplete(incompleteTypeMap, np.parentType.name, assocName);
                    }
                });
            }
        });
    }

    function updateCrossEntityRelationship(np) {
        var metadataStore = np.parentType.metadataStore;
        var incompleteTypeMap = metadataStore._incompleteTypeMap;

        &#x2F;&#x2F; ok to not find it yet
        var targetEntityType = metadataStore.getEntityType(np.entityTypeName, true);
        if (targetEntityType) {
            np.entityType = targetEntityType;
        }

        var assocMap = incompleteTypeMap[np.entityTypeName];
        if (!assocMap) {
            addToIncompleteMap(incompleteTypeMap, np);
        } else {
            var inverse = assocMap[np.associationName];
            if (inverse) {
                removeFromIncompleteMap(incompleteTypeMap, np, inverse);
            } else {
                addToIncompleteMap(incompleteTypeMap, np);
            }
        }
    };

    function addToIncompleteMap(incompleteTypeMap, np) {
        if (!np.entityType) {
            &#x2F;&#x2F; Fixed based on this: http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;14329352&#x2F;bad-navigation-property-one-to-zero-or-one-relationship&#x2F;14384399#14384399
            var assocMap = incompleteTypeMap[np.entityTypeName];
            if (!assocMap) {
                assocMap = {};
                incompleteTypeMap[np.entityTypeName] = assocMap;
            }
            assocMap[np.associationName] = np;
                
        }

        var altAssocMap = incompleteTypeMap[np.parentType.name];
        if (!altAssocMap) {
            altAssocMap = {};
            incompleteTypeMap[np.parentType.name] = altAssocMap;
        }
        altAssocMap[np.associationName] = np;
    }

    function removeFromIncompleteMap(incompleteTypeMap, np, inverse) {
        np.inverse = inverse;
        deleteIncomplete(incompleteTypeMap, np.entityTypeName, np.associationName);
        
        if (!inverse.inverse) {
            inverse.inverse = np;
            &#x2F;&#x2F; not sure if these are needed
            if (inverse.entityType == null) {
                inverse.entityType = np.parentType;
            }
            deleteIncomplete(incompleteTypeMap, np.parentType.name, np.associationName);
        }
    }
    
    function deleteIncomplete(incompleteTypeMap, typeName, assocName) {
        var assocMap = incompleteTypeMap[typeName];
        if (!assocMap) return null;
        delete assocMap[assocName];
        if (__isEmpty(assocMap)) {
            delete incompleteTypeMap[typeName];
            return null;
        } else {
            return assocMap;
        }
    }
    
    
    function calcUnmappedProperties(entityType, instance) {
        var metadataPropNames = entityType.getPropertyNames();
        var trackablePropNames = __modelLibraryDef.getDefaultInstance().getTrackablePropertyNames(instance);
        trackablePropNames.forEach(function (pn) {
            if (metadataPropNames.indexOf(pn) == -1) {
                var newProp = new DataProperty({
                    name: pn,
                    dataType: DataType.Undefined,
                    isNullable: true,
                    isUnmapped: true
                });
                entityType.addProperty(newProp);
            }
        });
    }

    return ctor;
})();
    
var ComplexType = (function () {
    &#x2F;**
    Container for all of the metadata about a specific type of Complex object.
    @class ComplexType
    **&#x2F;
        
    &#x2F;** 
    @example                    
        var complexType = new ComplexType( {
            shortName: &quot;address&quot;,
            namespace: &quot;myAppNamespace&quot;
            });
    @method &lt;ctor&gt; ComplexType
    @param config {Object} Configuration settings
    @param config.shortName {String}
    @param [config.namespace=&quot;&quot;] {String}
    **&#x2F;

    var ctor = function (config) {
        if (arguments.length &gt; 1) {
            throw new Error(&quot;The ComplexType ctor has a single argument that is a configuration object.&quot;);
        }

        assertConfig(config)
            .whereParam(&quot;shortName&quot;).isNonEmptyString()
            .whereParam(&quot;namespace&quot;).isString().isOptional().withDefault(&quot;&quot;)
            .applyAll(this);

        this.name = qualifyTypeName(this.shortName, this.namespace);
        this.isComplexType = true;
        this.dataProperties = [];
        this.complexProperties = [];
        this.validators = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = [];
    };
    var proto = ctor.prototype;
    &#x2F;**
    The DataProperties (see {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}}) associated with this ComplexType.

    __readOnly__
    @property dataProperties {Array of DataProperty} 
    **&#x2F;

    &#x2F;**
    The DataProperties for this ComplexType that contain instances of a ComplexType (see {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}}).

    __readOnly__
    @property complexProperties {Array of DataProperty} 
    **&#x2F;

    &#x2F;**
    The DataProperties associated with this ComplexType that are not mapped to any backend datastore. These are effectively free standing
    properties.

    __readOnly__
    @property unmappedProperties {Array of DataProperty} 
    **&#x2F;

    &#x2F;**
    The fully qualifed name of this ComplexType.

    __readOnly__
    @property name {String} 
    **&#x2F;

    &#x2F;**
    The short, unqualified, name for this ComplexType.

    __readOnly__
    @property shortName {String} 
    **&#x2F;

    &#x2F;**
    The namespace for this ComplexType.

    __readOnly__
    @property namespace {String} 
    **&#x2F;
        
    &#x2F;**
    The entity level validators associated with this ComplexType. Validators can be added and
    removed from this collection.

    __readOnly__
    @property validators {Array of Validator} 
    **&#x2F;


    &#x2F;**
    Creates a new non-attached instance of this ComplexType.
    @method createInstance
    @param initialValues {Object} Configuration object containing initial values for the instance. 
    **&#x2F;
    proto.createInstance = function (initialValues) {
        var instance = this._createInstanceCore();

        if (initialValues) {
            __objectForEach(initialValues, function (key, value) {
                instance.setProperty(key, value);
            });
        }

        instance.complexAspect._postInitialize();
        return instance;
    };

    proto._createInstanceCore = function (parent, parentProperty ) {
        var aCtor = this.getCtor();
        var instance = new aCtor();
        new ComplexAspect(instance, parent, parentProperty);
        if (parent) {
            instance.complexAspect._postInitialize();
        }
        return instance;
    };
        

    proto.addProperty = function (dataProperty) {
        assertParam(dataProperty, &quot;dataProperty&quot;).isInstanceOf(DataProperty).check();
        if (this.metadataStore &amp;&amp; ! dataProperty.isUnmapped) {
            throw new Error(&quot;The &#x27;&quot; + this.name + &quot;&#x27; ComplexType has already been added to a MetadataStore and therefore no additional properties may be added to it.&quot;);
        }
        if (dataProperty.parentType) {
            if (dataProperty.parentType !== this) {
                throw new Error(&quot;This dataProperty has already been added to &quot; + property.parentType.name);
            } else {
                return this;
            }
        }
        this._addDataProperty(dataProperty);

        return this;
    };
        
    proto.getProperties = function () {
        return this.dataProperties;
    };       

    &#x2F;**
    See  {{#crossLink &quot;EntityType.addValidator&quot;}}{{&#x2F;crossLink}}
    @method addValidator
    @param validator {Validator} Validator to add.
    @param [property] Property to add this validator to.  If omitted, the validator is assumed to be an
    entity level validator and is added to the EntityType&#x27;s &#x27;validators&#x27;.
    **&#x2F;
        
    &#x2F;**
    See  {{#crossLink &quot;EntityType.getProperty&quot;}}{{&#x2F;crossLink}}
    @method getProperty
    **&#x2F;
        
    &#x2F;**
    See  {{#crossLink &quot;EntityType.getPropertyNames&quot;}}{{&#x2F;crossLink}}
    @method getPropertyNames
    **&#x2F;
        
    &#x2F;**
    See  {{#crossLink &quot;EntityType.getEntityCtor&quot;}}{{&#x2F;crossLink}}
    @method getCtor
    **&#x2F;

    proto.addValidator = EntityType.prototype.addValidator;
    proto.getProperty = EntityType.prototype.getProperty;
    proto.getPropertyNames = EntityType.prototype.getPropertyNames;
    proto._addDataProperty = EntityType.prototype._addDataProperty;
    proto._updateProperty = EntityType.prototype._updateProperty;
    &#x2F;&#x2F; note the name change.
    proto.getCtor = EntityType.prototype.getEntityCtor;
    proto._setCtor = EntityType.prototype._setCtor;
        
    proto.toJSON = function () {
        return __toJson(this, {
            shortName: null,
            namespace: null,
            isComplexType: null,
            dataProperties: null,
            validators: null
        });
    };
       
    proto._fixup = function () {
        var that = this;
        this.dataProperties.forEach(function (property) {
            that._updateProperty(property);
        });
    };

    proto._$typeName = &quot;ComplexType&quot;;

    return ctor;
})();
    
var DataProperty = (function () {

    &#x2F;**
    A DataProperty describes the metadata for a single property of an  {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} that contains simple data. 

    Instances of the DataProperty class are constructed automatically during Metadata retrieval. However it is also possible to construct them
    directly via the constructor.
    @class DataProperty
    **&#x2F;
        
    &#x2F;** 
    @example                    
        var lastNameProp = new DataProperty( {
            name: &quot;lastName&quot;,
            dataType: DataType.String,
            isNullable: true,
            maxLength: 20
        });
        &#x2F;&#x2F; assuming personEntityType is a newly constructed EntityType
        personEntityType.addProperty(lastNameProperty);
    @method &lt;ctor&gt; DataProperty
    @param config {configuration Object} 
    @param [config.name] {String}  The name of this property. 
    @param [config.nameOnServer] {String} Same as above but the name is that defined on the server.
    Either this or the &#x27;name&#x27; above must be specified. Whichever one is specified the other will be computed using
    the NamingConvention on the MetadataStore associated with the EntityType to which this will be added.
    @param [config.dataType=DataType.String] {DataType}
    @param [config.complexTypeName] {String}
    @param [config.isNullable=true] {Boolean}
    @param [config.defaultValue] {Any}
    @param [config.isPartOfKey=false] {Boolean}
    @param [config.isUnmapped=false] {Boolean}
    @param [config.concurrencyMode] {String}
    @param [config.maxLength] {Integer} Only meaningfull for DataType.String
    @param [config.validators] {Array of Validator}
    **&#x2F;
    var ctor = function(config) {
        assertConfig(config)
            .whereParam(&quot;name&quot;).isString().isOptional()
            .whereParam(&quot;nameOnServer&quot;).isString().isOptional()
            .whereParam(&quot;dataType&quot;).isEnumOf(DataType).isOptional().or().isInstanceOf(ComplexType)
            .whereParam(&quot;complexTypeName&quot;).isOptional()
            .whereParam(&quot;isNullable&quot;).isBoolean().isOptional().withDefault(true)
            .whereParam(&quot;defaultValue&quot;).isOptional()
            .whereParam(&quot;isPartOfKey&quot;).isBoolean().isOptional()
            .whereParam(&quot;isUnmapped&quot;).isBoolean().isOptional()
            .whereParam(&quot;concurrencyMode&quot;).isString().isOptional()
            .whereParam(&quot;maxLength&quot;).isNumber().isOptional()
            .whereParam(&quot;validators&quot;).isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .whereParam(&quot;enumType&quot;).isOptional()
            .whereParam(&quot;rawTypeName&quot;).isOptional() &#x2F;&#x2F; occurs with undefined datatypes
            .applyAll(this);
        var hasName = !!(this.name || this.nameOnServer);
        if (!hasName) {
            throw new Error(&quot;A DataProperty must be instantiated with either a &#x27;name&#x27; or a &#x27;nameOnServer&#x27; property&quot;);
        }
        &#x2F;&#x2F; name&#x2F;nameOnServer is resolved later when a metadataStore is available.
            
        if (this.complexTypeName) {
            this.isComplexProperty = true;
            this.dataType = null;
        } else if (!this.dataType) {
            this.dataType = DataType.String;
        }
            
        &#x2F;&#x2F; == as opposed to === is deliberate here.
        if (this.defaultValue == null) {
            if (this.isNullable) {
                this.defaultValue = null;
            } else {
                if (this.isComplexProperty) {
                    &#x2F;&#x2F; what to do? - shouldn&#x27;t happen from EF - but otherwise ???
                } else if (this.dataType === DataType.Binary) {
                    this.defaultValue = &quot;AAAAAAAAJ3U=&quot;; &#x2F;&#x2F; hack for all binary fields but value is specifically valid for timestamp fields - arbitrary valid 8 byte base64 value.
                } else {
                    this.defaultValue = this.dataType.defaultValue;
                    if (this.defaultValue == null) {
                        throw new Error(&quot;A nonnullable DataProperty cannot have a null defaultValue. Name: &quot; + this.name);
                    }
                }
            }
        }
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;DataProperty&quot;;

    &#x2F;**
    The name of this property

    __readOnly__
    @property name {String}
    **&#x2F;

    &#x2F;**
    The parent type that this property belongs to - will be either a {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} or a {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}}.

    __readOnly__
    @property parentType {EntityType|ComplexType}
    **&#x2F;

    &#x2F;**
    The {{#crossLink &quot;DataType&quot;}}{{&#x2F;crossLink}} of this property.

    __readOnly__
    @property dataType {DataType}
    **&#x2F;

    &#x2F;**
    The name of the {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}} associated with this property; may be null. 

    __readOnly__
    @property complexTypeName {String}
    **&#x2F;

    &#x2F;**
    Whether the contents of this property is an instance of a {{#crossLink &quot;ComplexType&quot;}}{{&#x2F;crossLink}}.

    __readOnly__
    @property isComplexProperty {bool}
    **&#x2F;

    &#x2F;**
    Whether this property is nullable. 

    __readOnly__
    @property isNullable {Boolean}
    **&#x2F;

    &#x2F;**
    Whether this property is a &#x27;key&#x27; property. 

    __readOnly__
    @property isPartOfKey {Boolean}
    **&#x2F;

    &#x2F;**
    Whether this property is an &#x27;unmapped&#x27; property. 

    __readOnly__
    @property isUnmapped {Boolean}
    **&#x2F;

    &#x2F;**
    __Describe this__

    __readOnly__
    @property concurrencyMode {String}
    **&#x2F;

    &#x2F;**
    The maximum length for the value of this property.

    __readOnly__
    @property maxLength {Number}
    **&#x2F;

    &#x2F;**
    The {{#crossLink &quot;Validator&quot;}}{{&#x2F;crossLink}}s that are associated with this property. Validators can be added and
    removed from this collection.

    __readOnly__
    @property validators {Array of Validator}
    **&#x2F;

    &#x2F;**
    The default value for this property.

    __readOnly__
    @property defaultValue {any}
    **&#x2F;

    &#x2F;**
    The navigation property related to this property.  Will only be set if this is a foreign key property. 

    __readOnly__
    @property relatedNavigationProperty {NavigationProperty}
    **&#x2F;
        
    &#x2F;**
    Is this a DataProperty? - always true here 
    Allows polymorphic treatment of DataProperties and NavigationProperties.

    __readOnly__
    @property isDataProperty {Boolean}
    **&#x2F;

    &#x2F;**
    Is this a NavigationProperty? - always false here 
    Allows polymorphic treatment of DataProperties and NavigationProperties.

    __readOnly__
    @property isNavigationProperty {Boolean}
    **&#x2F;

    proto.isDataProperty = true;
    proto.isNavigationProperty = false;

    proto.toJSON = function () {
        &#x2F;&#x2F; do not serialize dataTypes that are complexTypes
        return __toJson(this, {
            name: null,
            dataType: function (v) { return (v &amp;&amp; v.parentEnum) ? v.name : undefined;  }, &#x2F;&#x2F; do not serialize dataTypes that are complexTypes
            complexTypeName: null,
            isNullable: true,
            defaultValue: null,
            isPartOfKey: false,
            isUnmapped: false,
            concurrencyMode: null,
            maxLength: null,
            validators: null,
            enumType: null,
            rawTypeName: null
        });
        
        
    };

    ctor.fromJSON = function(json, parentEntityType) {
        json.dataType = DataType.fromName(json.dataType);
        &#x2F;&#x2F; dateTime instances require &#x27;extra&#x27; work to deserialize properly.
        if (json.defaultValue &amp;&amp; json.dataType &amp;&amp; json.dataType.isDate) {
            json.defaultValue = new Date(Date.parse(json.defaultValue));
        }
        
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }

        var dp = new DataProperty(json);
        parentEntityType.addProperty(dp);
        return dp;
    };

    return ctor;
})();
  
var NavigationProperty = (function () {

    &#x2F;**
    A NavigationProperty describes the metadata for a single property of an  {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} that return instances of other EntityTypes. 
    
    Instances of the NavigationProperty class are constructed automatically during Metadata retrieval.   However it is also possible to construct them
    directly via the constructor.
    @class NavigationProperty
    **&#x2F;
        
    &#x2F;** 
    @example                    
        var homeAddressProp = new NavigationProperty( {
            name: &quot;homeAddress&quot;,
            entityTypeName: &quot;Address:#myNamespace&quot;,
            isScalar: true,
            associationName: &quot;address_person&quot;,
            foreignKeyNames: [&quot;homeAddressId&quot;]
        });
        var homeAddressIdProp = new DataProperty( {
            name: &quot;homeAddressId&quot;
            dataType: DataType.Integer
        });
        &#x2F;&#x2F; assuming personEntityType is a newly constructed EntityType
        personEntityType.addProperty(homeAddressProp);
        personEntityType.addProperty(homeAddressIdProp);
    @method &lt;ctor&gt; NavigationProperty
    @param config {configuration Object} 
    @param [config.name] {String}  The name of this property.
    @param [config.nameOnServer] {String} Same as above but the name is that defined on the server.
    Either this or the &#x27;name&#x27; above must be specified. Whichever one is specified the other will be computed using
    the NamingConvention on the MetadataStore associated with the EntityType to which this will be added.
    @param config.entityTypeName {String} The fully qualified name of the type of entity that this property will return.  This type
    need not yet have been created, but it will need to get added to the relevant MetadataStore before this EntityType will be &#x27;complete&#x27;.
    The entityType name is constructed as: {shortName} + &quot;:#&quot; + {namespace}
    @param [config.isScalar] {Boolean}
    @param [config.associationName] {String} A name that will be used to connect the two sides of a navigation. May be omitted for unidirectional navigations.
    @param [config.foreignKeyNames] {Array of String} An array of foreign key names. The array is needed to support the possibility of multipart foreign keys.
    Most of the time this will be a single foreignKeyName in an array.
    @param [config.foreignKeyNamesOnServer] {Array of String} Same as above but the names are those defined on the server. Either this or &#x27;foreignKeyNames&#x27; must
    be specified, if there are foreignKeys. Whichever one is specified the other will be computed using
    the NamingConvention on the MetadataStore associated with the EntityType to which this will be added.
    @param [config.validators] {Array of Validator}
    **&#x2F;
    var ctor = function(config) {
        assertConfig(config)
            .whereParam(&quot;name&quot;).isString().isOptional()
            .whereParam(&quot;nameOnServer&quot;).isString().isOptional()
            .whereParam(&quot;entityTypeName&quot;).isString()
            .whereParam(&quot;isScalar&quot;).isBoolean()
            .whereParam(&quot;associationName&quot;).isString().isOptional()
            .whereParam(&quot;foreignKeyNames&quot;).isArray().isString().isOptional().withDefault([])
            .whereParam(&quot;foreignKeyNamesOnServer&quot;).isArray().isString().isOptional().withDefault([])
            .whereParam(&quot;validators&quot;).isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .applyAll(this);
        var hasName = !!(this.name || this.nameOnServer);
                                                              
        if (!hasName) {
            throw new Error(&quot;A Navigation property must be instantiated with either a &#x27;name&#x27; or a &#x27;nameOnServer&#x27; property&quot;);
        }
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;NavigationProperty&quot;;
        
    &#x2F;**
    The {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} that this property belongs to.
    __readOnly__
    @property parentEntityType {EntityType}
    **&#x2F;

    &#x2F;**
    The name of this property

    __readOnly__
    @property name {String}
    **&#x2F;

    &#x2F;**
    The {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} returned by this property.

    __readOnly__
    @property entityType {EntityType}
    **&#x2F;

    &#x2F;**
    Whether this property returns a single entity or an array of entities.

    __readOnly__
    @property isScalar {Boolean}
    **&#x2F;

    &#x2F;**
    The name of the association to which that this property belongs.  This associationName will be shared with this 
    properties &#x27;inverse&#x27;.

    __readOnly__
    @property associationName {String}
    **&#x2F;

    &#x2F;**
    The names of the foreign key DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated 
    with a Navigation property except in the case of entities with multipart keys.

    __readOnly__
    @property foreignKeyNames {Array of String}
    **&#x2F;

    &#x2F;**
    The &#x27;foreign key&#x27; DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated 
    with a Navigation property except in the case of entities with multipart keys.

    __readOnly__
    @property relatedDataProperties {Array of DataProperty}
    **&#x2F;

    &#x2F;**
    The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction
    to this NavigationProperty.

    __readOnly__
    @property inverse {NavigationProperty}
    **&#x2F;

    &#x2F;**
    The {{#crossLink &quot;Validator&quot;}}{{&#x2F;crossLink}}s that are associated with this property. Validators can be added and
    removed from this collection.

    __readOnly__
    @property validators {Array of Validator}
    **&#x2F;

    &#x2F;**
    Is this a DataProperty? - always false here 
    Allows polymorphic treatment of DataProperties and NavigationProperties.

    __readOnly__
    @property isDataProperty {Boolean}
    **&#x2F;
        
    &#x2F;**
    Is this a NavigationProperty? - always true here 
    Allows polymorphic treatment of DataProperties and NavigationProperties.

    __readOnly__
    @property isNavigationProperty {Boolean}
    **&#x2F;
        
    proto.isDataProperty = false;
    proto.isNavigationProperty = true;

    proto.toJSON = function () {
        return __toJson(this, {
            name: null,
            entityTypeName: null,
            isScalar: null,
            associationName: null,
            validators: null,
            foreignKeyNames: null
        });
    };

    ctor.fromJSON = function (json, parentEntityType) {
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }
        var np = new NavigationProperty(json);
        parentEntityType.addProperty(np);
        return np;
    };
    
    return ctor;
})();
    
var AutoGeneratedKeyType = function () {
    &#x2F;**
    AutoGeneratedKeyType is an &#x27;Enum&#x27; containing all of the valid states for an automatically generated key.
    @class AutoGeneratedKeyType
    @static
    @final
    **&#x2F;
    var ctor = new Enum(&quot;AutoGeneratedKeyType&quot;);
    &#x2F;**
    This entity does not have an autogenerated key. 
    The client must set the key before adding the entity to the EntityManager
    @property None {AutoGeneratedKeyType}
    @final
    @static
    **&#x2F;
    ctor.None = ctor.addSymbol();
    &#x2F;**
    This entity&#x27;s key is an Identity column and is set by the backend database. 
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their &#x27;real&#x27; versions.
    @property Identity {AutoGeneratedKeyType}
    @final
    @static
    **&#x2F;
    ctor.Identity = ctor.addSymbol();
    &#x2F;**
    This entity&#x27;s key is generated by a KeyGenerator and is set by the backend database. 
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their &#x27;real&#x27; versions.
    @property KeyGenerator {AutoGeneratedKeyType}
    @final
    @static
    **&#x2F;
    ctor.KeyGenerator = ctor.addSymbol();
    ctor.seal();

    return ctor;
}();

&#x2F;&#x2F; mixin methods
(function() {
   
    var proto = Param.prototype;

    proto.isEntity = function() {
        return this._addContext({
            fn: isEntity,
            msg: &quot; must be an entity&quot;
        });
    };

    function isEntity(context, v) {
        if (v == null) return false;
        return (v.entityType !== undefined);
    }

    proto.isEntityProperty = function() {
        return this._addContext({
            fn: isEntityProperty,
            msg: &quot; must be either a DataProperty or a NavigationProperty&quot;
        });
    };

    function isEntityProperty(context, v) {
        if (v == null) return false;
        return (v.isDataProperty || v.isNavigationProperty);
    }
})();

function isQualifiedTypeName(entityTypeName) {
    return entityTypeName.indexOf(&quot;:#&quot;) &gt;= 0;
}
    
function qualifyTypeName(shortName, namespace) {
    return shortName + &quot;:#&quot; + namespace;
}

&#x2F;&#x2F; schema is only needed for navProperty type name
function normalizeTypeName(entityTypeName, schema) {
    if (!entityTypeName) {
        return null;
    }
    if (__stringStartsWith(entityTypeName, MetadataStore.ANONTYPE_PREFIX)) {
        return {
            shortTypeName: entityTypeName,
            namespace: &quot;&quot;,
            typeName: entityTypeName,
            isAnon: true
        };
    }
    var entityTypeNameNoAssembly = entityTypeName.split(&quot;,&quot;)[0];
    var nameParts = entityTypeNameNoAssembly.split(&quot;.&quot;);
    if (nameParts.length &gt; 1) {
            
        var shortName = nameParts[nameParts.length - 1];

        var ns;
        if (schema) {
            ns = getNamespaceFor(shortName, schema);
        } else {
            var namespaceParts = nameParts.slice(0, nameParts.length - 1);
            ns = namespaceParts.join(&quot;.&quot;);
        }
        return {
            shortTypeName: shortName,
            namespace: ns,
            typeName: qualifyTypeName(shortName, ns)
        };
    } else {
        return {
            shortTypeName: entityTypeName,
            namespace: &quot;&quot;,
            typeName: entityTypeName
        };
    }
}
    
function getNamespaceFor(shortName, schema) {
    var ns;
    var mapping = schema.cSpaceOSpaceMapping;
    if (mapping) {
        var fullName = mapping[schema.namespace + &quot;.&quot; + shortName];
        ns = fullName &amp;&amp; fullName.substr(0, fullName.length - (shortName.length + 1));
    }
    return ns || schema.namespace;
}


breeze.MetadataStore= MetadataStore;
breeze.DataService= DataService;
breeze.JsonResultsAdapter = JsonResultsAdapter;
breeze.EntityType = EntityType;
breeze.ComplexType = ComplexType;
breeze.DataProperty= DataProperty;
breeze.NavigationProperty = NavigationProperty;
breeze.DataType = DataType;
breeze.AutoGeneratedKeyType = AutoGeneratedKeyType;
breeze.NamingConvention = NamingConvention;



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://stackoverflow.com/questions/tagged/breeze?sort=newest" target="_blank">Forum</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
