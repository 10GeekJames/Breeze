<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>entityQuery.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34729465-1']);
  _gaq.push(['_setDomainName', 'breezejs.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<script type="text/javascript">
    var _elqQ = _elqQ || [];
    _elqQ.push(['elqSetSiteId', '1020']);
    _elqQ.push(['elqTrackPageView']);
    
    (function () {
        function async_load() {
            var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true;
            s.src = '//img.en25.com/i/elqCfg.min.js';
            var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x);
        }
        if (window.addEventListener) window.addEventListener('DOMContentLoaded', async_load, false);
        else if (window.attachEvent) window.attachEvent('onload', async_load); 
    })();
</script>






<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/Promise.html">Promise</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_keyGenerator_interface.html">ↈ_keyGenerator_interface</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_relationArray_.html">ↈ_relationArray_</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
                <li><a href="..&#x2F;modules/entityModel.html">entityModel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: entityQuery.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿define([&quot;core&quot;, &quot;entityMetadata&quot;, &quot;entityAspect&quot;],
function (core, m_entityMetadata, m_entityAspect) {
    &quot;use strict&quot;;
    &#x2F;**
    @module entityModel
    **&#x2F;

    var Enum = core.Enum;
    var assertParam = core.assertParam;
    
    var MetadataStore = m_entityMetadata.MetadataStore;
    var NavigationProperty = m_entityMetadata.NavigationProperty;
    var EntityType = m_entityMetadata.EntityType;
    
    var EntityAspect = m_entityAspect.EntityAspect;
    var EntityKey = m_entityAspect.EntityKey;
    
    
    var EntityQuery = (function () {
        &#x2F;**
        An EntityQuery instance is used to query entities either from a remote datasource or from a local {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}}. 

        EntityQueries are immutable - this means that all EntityQuery methods that return an EntityQuery actually create a new EntityQuery.  This means that 
        EntityQueries can be &#x27;modified&#x27; without affecting any current instances.

        @class EntityQuery
        **&#x2F;
            
        &#x2F;**
        @example                    
            var query = new EntityQuery(&quot;Customers&quot;)

        Usually this constructor will be followed by calls to filtering, ordering or selection methods
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
               .orderBy(&quot;Region&quot;);

        @method &lt;ctor&gt; EntityQuery 
        @param [resourceName] {String}
        **&#x2F;
        var ctor = function (resourceName) {
            assertParam(resourceName, &quot;resourceName&quot;).isOptional().isString().check();
            this.resourceName = normalizeResourceName(resourceName);
            this.entityType = null;
            this.wherePredicate = null;
            this.orderByClause = null;
            this.selectClause = null;
            this.skipCount = null;
            this.takeCount = null;
            this.expandClause = null;
            &#x2F;&#x2F; default is to get queryOptions from the entityManager.
            this.queryOptions = null;
            this.entityManager = null;                 
        };

        &#x2F;**
        The resource name used by this query.

        __readOnly__
        @property resourceName {String}
        **&#x2F;

        &#x2F;**
        The &#x27;where&#x27; predicate used by this query.

        __readOnly__
        @property wherePredicate {Predicate} 
        **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;OrderByClause&quot;}}{{&#x2F;crossLink}} used by this query.

        __readOnly__
        @property orderByClause {OrderByClause}
        **&#x2F;

        &#x2F;**
        The number of entities to &#x27;skip&#x27; for this query.

        __readOnly__
        @property skipCount {Integer}
        **&#x2F;

        &#x2F;**
        The number of entities to &#x27;take&#x27; for this query.

        __readOnly__
        @property takeCount {Integer}
        **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;QueryOptions&quot;}}{{&#x2F;crossLink}} for this query.

        __readOnly__
        @property queryOptions {QueryOptions}
        **&#x2F;
        
        &#x2F;**
        The {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}} for this query. This may be null and can be set via the &#x27;using&#x27; method.

        __readOnly__
        @property entityManager {EntityManager}
        **&#x2F;

        &#x2F;*
        Made internal for now.
        @method getEntityType
        @param metadataStore {MetadataStore} The {{#crossLink &quot;MetadataStore&quot;}}{{&#x2F;crossLink}} in which to locate the 
        {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} returned by this query. 
        @param [throwErrorIfNotFound = false] {Boolean} Whether or not to throw an error if an EntityType cannot be found.
        @return {EntityType} Will return a null if the resource has not yet been resolved and throwErrorIfNotFound is false. 
        *&#x2F;
        ctor.prototype._getEntityType = function (metadataStore, throwErrorIfNotFound) {
            assertParam(metadataStore, &quot;metadataStore&quot;).isInstanceOf(MetadataStore).check();
            assertParam(throwErrorIfNotFound, &quot;throwErrorIfNotFound&quot;).isBoolean().isOptional().check();
            var entityType = this.entityType;
            if (!entityType) {
                var resourceName = this.resourceName;
                if (!resourceName) {
                    throw new Error(&quot;There is no resourceName for this query&quot;);
                }
                if (metadataStore.isEmpty()) {
                    return null;
                }
                var entityTypeName = metadataStore._getEntityTypeNameForResourceName(resourceName);
                if (!entityTypeName) {
                    if (throwErrorIfNotFound) {
                        throw new Error(&quot;Cannot find resourceName of: &quot; + resourceName);
                    } else {
                        return null;
                    }
                }
                entityType = metadataStore.getEntityType(entityTypeName);
                if (!entityType) {
                    if (throwErrorIfNotFound) {
                        throw new Error(&quot;Cannot find an entityType for an entityTypeName of: &quot; + entityTypeName);
                    } else {
                        return null;
                    }
                }
                this.entityType = entityType;
            }
            return entityType;
        };

        &#x2F;**
        Specifies the resource to query for this EntityQuery.
        @example                    
            var query = new EntityQuery()
                .from(&quot;Customers&quot;);
        is the same as 
        @example
            var query = new EntityQuery(&quot;Customers&quot;);
        @method from
        @param resourceName {String} The resource to query.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.from = function (resourceName) {
            &#x2F;&#x2F; TODO: think about allowing entityType as well 
            assertParam(resourceName, &quot;resourceName&quot;).isString().check();
            resourceName = normalizeResourceName(resourceName);
            var currentName = this.resourceName;
            if (currentName &amp;&amp; currentName !== resourceName) {
                throw new Error(&quot;This query already has an resourceName - the resourceName may only be set once per query&quot;);
            }
            var eq = this._clone();
            eq.resourceName = resourceName;
            return eq;
        };
        
        &#x2F;**
        This is a static version of the &quot;from&quot; method and it creates a &#x27;base&#x27; entityQuery for the specified resource name. 
        @example                    
            var query = EntityQuery.from(&quot;Customers&quot;);
        is the same as 
        @example
            var query = new EntityQuery(&quot;Customers&quot;);
        @method from
        @static
        @param resourceName {String} The resource to query.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.from = function (resourceName) {
            assertParam(resourceName, &quot;resourceName&quot;).isString().check();
            return new EntityQuery(resourceName);
        };


        &#x2F;**
        Adds a filter to the query. Can be called multiple times which means to &#x27;and&#x27; with any existing Predicate.
        @example                    
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;);
        This can also be expressed using an explicit {{#crossLink &quot;FilterQueryOp&quot;}}{{&#x2F;crossLink}} as
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, FilterQueryOp.StartsWith, &quot;C&quot;);
        or a preconstructed {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} may be used
        @example
            var pred = new Predicate(&quot;CompanyName&quot;, FilterQueryOp.StartsWith, &quot;C&quot;);
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(pred);
        Predicates are often useful when you want to combine multiple conditions in a single filter, such as
        @example
            var pred = Predicate.create(&quot;CompanyName&quot;, &quot;startswith&quot;, &quot;C&quot;).and(&quot;Region&quot;, FilterQueryOp.Equals, null);
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(pred);
        @example
        More complicated queries can make use of nested property paths
        @example
            var query = new EntityQuery(&quot;Products&quot;)
                .where(&quot;Category.CategoryName&quot;, &quot;startswith&quot;, &quot;S&quot;);
        or OData functions - A list of valid OData functions can be found within the {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} documentation.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;toLower(CompanyName)&quot;, &quot;startsWith&quot;, &quot;c&quot;);
        or to be even more baroque
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;toUpper(substring(CompanyName, 1, 2))&quot;, FilterQueryOp.Equals, &quot;OM&quot;);
        @method where
        @param predicate {Predicate|property|property path, operator, value} Can be either
        
        - a single {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}}

        - or the parameters to create a &#x27;simple&#x27; Predicate

            - a property name, a property path with &#x27;.&#x27; as path seperators or a property expression {String}
            - an operator {FilterQueryOp|String} Either a  {{#crossLink &quot;FilterQueryOp&quot;}}{{&#x2F;crossLink}} or it&#x27;s string representation. Case is ignored
            when if a string is provided and any string that matches one of the FilterQueryOp aliases will be accepted.
            - a value    
   
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.where = function (predicate) {
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.wherePredicate = null;
                return eq;
            }
            var pred;
            if (Predicate.isPredicate(predicate)) {
                pred = predicate;
            } else {
                pred = Predicate.create(Array.prototype.slice.call(arguments));
            }
            if (eq.entityType) pred.validate(eq.entityType);
            if (eq.wherePredicate) {
                eq.wherePredicate = new CompositePredicate(&#x27;and&#x27;, [eq.wherePredicate, pred]);
            } else {
                eq.wherePredicate = pred;
            }
            return eq;
        };

        &#x2F;**
        Returns a query that orders the results of the query by property name.  By default sorting occurs is ascending order, but sorting in descending order is supported as well. 
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderBy(&quot;CompanyName&quot;);

        or to sort across multiple properties
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderBy(&quot;Region, CompanyName&quot;);

        Nested property paths are also supported
        @example
             var query = new EntityQuery(&quot;Products&quot;)
                .orderBy(&quot;Category.CategoryName&quot;);

        Sorting in descending order is supported via the addition of &#x27; desc&#x27; to the end of any property path.
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                .orderBy(&quot;CompanyName desc&quot;);

        or
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                .orderBy(&quot;Region desc, CompanyName desc&quot;);
        @method orderBy
        @param propertyPaths {String} A list of property paths seperated by &#x27;,&#x27;. Each property path can optionally end with &quot; desc&quot; to force a descending sort order.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.orderBy = function (propertyPaths) {
            core.assertParam(propertyPaths, &quot;propertyNames&quot;).isString();
            &#x2F;&#x2F; deliberately don&#x27;t pass in isDesc
            return orderByCore(this, propertyPaths);
        };

        &#x2F;**
        Returns a query that orders the results of the query by property name in descending order.
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderByDesc(&quot;CompanyName&quot;);

        or to sort across multiple properties
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderByDesc(&quot;Region, CompanyName&quot;);

        Nested property paths are also supported
        @example
             var query = new EntityQuery(&quot;Products&quot;)
                .orderByDesc(&quot;Category.CategoryName&quot;);

        @method orderByDesc
        @param propertyPaths {String} A list of property paths seperated by &#x27;,&#x27;.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.orderByDesc = function (propertyPaths) {
            core.assertParam(propertyPaths, &quot;propertyNames&quot;).isString();
            return orderByCore(this, propertyPaths, true);
        };
        
        &#x2F;**
        Returns a query that selects a list of properties from the results of the original query and returns the values of just these properties. This
        will be referred to as a projection. 
        If the result of this selection &quot;projection&quot; contains entities, these entities will automatically be added to EntityManager&#x27;s cache and will 
        be made &#x27;observable&#x27;.
        Any simple properties, i.e. strings, numbers or dates within a projection will not be cached are will NOT be made &#x27;observable&#x27;.
        
        @example
        Simple data properties can be projected
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;CompanyName&quot;);
        This will return an array of objects each with a single &quot;CompanyName&quot; property of type string.
        A similar query could return a navigation property instead
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;Orders&quot;);
        where the result would be an array of objects each with a single &quot;Orders&quot; property that would itself be an array of &quot;Order&quot; entities.
        Composite projections are also possible:
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;CompanyName, Orders&quot;);
        As well as projections involving nested property paths
        @example
            var query = EntityQuery(&quot;Orders&quot;)
                .where(&quot;Customer.CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)         
                .select(&quot;Customer.CompanyName, Customer, OrderDate&quot;);
        @method select
        @param propertyPaths {String} A list of property paths seperated by &#x27;,&#x27;.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.select = function (propertyPaths) {
            core.assertParam(propertyPaths, &quot;propertyPaths&quot;).isString();
            return selectCore(this, propertyPaths);
        };

        &#x2F;**
        Returns a query that skips the specified number of entities when returning results.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
               .skip(5);
        @method skip
        @param count {Number} The number of entities to return. If omitted this clears the 
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.skip = function (count) {
            assertParam(count, &quot;count&quot;).isOptional().isNumber().check();
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.skipCount = null;
            } else {
                eq.skipCount = count;
            }
            return eq;
        };
        
        &#x2F;**
        Returns a query that returns only the specified number of entities when returning results. - Same as &#x27;take&#x27;.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .top(5);
        @method top
        @param count {Number} The number of entities to return.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.top = function(count) {
            return this.take(count);
        };

        &#x2F;**
        Returns a query that returns only the specified number of entities when returning results - Same as &#x27;top&#x27;
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .take(5);
        @method take
        @param count {Number} The number of entities to return.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.take = function (count) {
            assertParam(count, &quot;count&quot;).isOptional().isNumber().check();
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.takeCount = null;
            } else {
                eq.takeCount = count;
            }
            return eq;
        };
        
        &#x2F;**
        Returns a query that will return related entities nested within its results. The expand method allows you to identify related entities, via navigation property
        names such that a graph of entities may be retrieved with a single request. Any filtering occurs before the results are &#x27;expanded&#x27;.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .expand(&quot;Orders&quot;);
        will return the filtered customers each with its &quot;Orders&quot; properties fully resolved.
        Multiple paths may be specified by separating the paths by a &#x27;,&#x27;
        @example
            var query = new EntityQuery(&quot;Orders&quot;)
                .expand(&quot;Customer, Employee&quot;)
        and nested property paths my be specified as well
        @example
            var query = new EntityQuery(&quot;Orders&quot;)
                .expand(&quot;Customer, OrderDetails, OrderDetails.Product&quot;)
        @method expand
        @param propertyPaths {String} A comma-separated list of navigation property names. Each Navigation Property name can be followed
        by a &#x27;.&#x27; and another navigation property name to enable identifying a multi-level relationship
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.prototype.expand = function (propertyPaths) {
            assertParam(propertyPaths, &quot;propertyPaths&quot;).isString().check();
            return expandCore(this, propertyPaths);
        };

         &#x2F;&#x2F; Implementations found in EntityManager
        &#x2F;**
        Returns a copy of this EntityQuery with the specified {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}}, {{#crossLink &quot;MergeStrategy&quot;}}{{&#x2F;crossLink}} 
        or {{#crossLink &quot;FetchStrategy&quot;}}{{&#x2F;crossLink}} applied.
        @example
        &#x27;using&#x27; can be used to return a new query with a specified EntityManager.
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;)
                 .using(em);
        or with a specified {{#crossLink &quot;MergeStrategy&quot;}}{{&#x2F;crossLink}} 
        @example
            var em = new EntityManager(serviceName);
            var query = new EntityQuery(&quot;Orders&quot;)
                .using(MergeStrategy.PreserveChanges);
        or with a specified {{#crossLink &quot;FetchStrategy&quot;}}{{&#x2F;crossLink}} 
        @example
            var em = new EntityManager(serviceName);
            var query = new EntityQuery(&quot;Orders&quot;)
                .using(FetchStrategy.FromLocalCache);
        @example
        @method using
        @param obj {EntityManager|MergeStrategy|FetchStrategy} The object to update in creating a new EntityQuery from an existing one.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        
        &#x2F;&#x2F; Implementations found in EntityManager
        &#x2F;**
        Executes this query.  This method requires that an EntityManager have been previously specified via the &quot;using&quot; method.
        @example
        This method can be called using a &#x27;promises&#x27; syntax ( recommended)
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;).using(em);
             query.execute()
               .then( function(data) {
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
        or with callbacks
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;).using(em);
             query.execute(
                function(data) {
                   var orders = data.results;
                   ... query results processed here
                },
                function(err) {
                   ... query failure processed here
                });
        Either way this method is the same as calling the EntityManager &#x27;execute&#x27; method.
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;);
             em.executeQuery(query)
               .then( function(data) {
                   var orders = data.results;
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
         
        @method execute
        @async
        
        @param callback {Function} Function called on success.
        
            successFunction([data])
            @param [callback.data] {Object} 
            @param callback.data.results {Array of Entity}
            @param callback.data.query {EntityQuery} The original query

        @param errorCallback {Function} Function called on failure.
            
            failureFunction([error])
            @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.
            @param [errorCallback.error.query] The query that caused the error.

        @return {Promise}
        **&#x2F;
        
        &#x2F;**
        Executes this query against the local cahce.  This method requires that an EntityManager have been previously specified via the &quot;using&quot; method.
        @example
            &#x2F;&#x2F; assume em is an entityManager already filled with order entities;
            var query = new EntityQuery(&quot;Orders&quot;).using(em);
            var orders = query.executeLocally();
        
        Note that calling this method is the same as calling {{#crossLink &quot;EntityManager&#x2F;executeQueryLocally&quot;}}{{&#x2F;crossLink}}.
      
        @method executeLocally
        **&#x2F;

        &#x2F;**
        Static method tht creates an EntityQuery that will allow &#x27;requerying&#x27; an entity or a collection of entities by primary key. This can be useful
        to force a requery of selected entities, or to restrict an existing collection of entities according to some filter.
        @example
            &#x2F;&#x2F; assuming &#x27;customers&#x27; is an array of &#x27;Customer&#x27; entities retrieved earlier.
            var customersQuery = EntityQuery.fromEntities(customers);
        The resulting query can, of course, be extended
        @example
            &#x2F;&#x2F; assuming &#x27;customers&#x27; is an array of &#x27;Customer&#x27; entities retrieved earlier.
            var customersQuery = EntityQuery.fromEntities(customers)
                .where(&quot;Region&quot;, FilterQueryOp.NotEquals, null);
        Single entities can requeried as well.
        @example
            &#x2F;&#x2F; assuming &#x27;customer&#x27; is a &#x27;Customer&#x27; entity retrieved earlier.
            var customerQuery = EntityQuery.fromEntities(customer);
        will create a query that will return an array containing a single customer entity.
        @method fromEntities
        @static
        @param entities {Entity|Array of Entity} The entities for which we want to create an EntityQuery.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntities = function (entities) {
            assertParam(entities, &quot;entities&quot;).isEntity().or().isNonEmptyArray().isEntity().check();
            if (!Array.isArray(entities)) {
                entities = Array.prototype.slice.call(arguments);
            }
            var firstEntity = entities[0];
            var q = new EntityQuery(firstEntity.entityType.defaultResourceName);
            var preds = entities.map(function (entity) {
                return buildPredicate(entity);
            });
            var pred = Predicate.or(preds);
            q = q.where(pred);
            var em = firstEntity.entityAspect.entityManager;
            if (em) {
                q = q.using(em);
            }
            return q;
        };

        &#x2F;**
        Creates an EntityQuery for the specified {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}}.
        @example
            var empType = metadataStore.getEntityType(&quot;Employee&quot;);
            var entityKey = new EntityKey(empType, 1);
            var query = EntityQuery.fromEntityKey(entityKey);
        or
        @example
            &#x2F;&#x2F; &#x27;employee&#x27; is a previously queried employee
            var entityKey = employee.entityAspect.getKey();
            var query = EntityQuery.fromEntityKey(entityKey);
        @method fromEntityKey
        @static
        @param entityKey {EntityKey} The {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}} for which a query will be created.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntityKey = function (entityKey) {
            assertParam(entityKey, &quot;entityKey&quot;).isInstanceOf(EntityKey).check();
            var q = new EntityQuery(entityKey.entityType.defaultResourceName);
            var pred = buildKeyPredicate(entityKey);
            q = q.where(pred);
            return q;
        };

        &#x2F;**
        Creates an EntityQuery for the specified entity and {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}.
        @example
            &#x2F;&#x2F; &#x27;employee&#x27; is a previously queried employee
            var ordersNavProp = employee.entityType.getProperty(&quot;Orders&quot;);
            var query = EntityQuery.fromEntityNavigation(employee, ordersNavProp);
        will return a query for the &quot;Orders&quot; of the specified &#x27;employee&#x27;.
        @method fromEntityNavigation
        @static
        @param entity {Entity} The Entity whose navigation property will be queried.
        @param navigationProperty {NavigationProperty} The {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}} to be queried.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntityNavigation = function (entity, navigationProperty) {
            assertParam(entity, &quot;entity&quot;).isEntity().check();
            assertParam(navigationProperty, &quot;navigationProperty&quot;).isInstanceOf(NavigationProperty).check();
            var navProperty = entity.entityType._checkNavProperty(navigationProperty);
            var q = new EntityQuery(navProperty.entityType.defaultResourceName);
            var pred = buildNavigationPredicate(entity, navProperty);
            q = q.where(pred);
            var em = entity.entityAspect.entityManager;
            if (em) {
                q = q.using(em);
            }
            return q;
        };


        &#x2F;&#x2F; protected methods

        ctor.prototype._clone = function () {
            var copy = new EntityQuery();
            copy.resourceName = this.resourceName;
            copy.entityType = this.entityType;
            copy.wherePredicate = this.wherePredicate;
            copy.orderByClause = this.orderByClause;
            copy.selectClause = this.selectClause;
            copy.skipCount = this.skipCount;
            copy.takeCount = this.takeCount;
            copy.expandClause = this.expandClause;
            &#x2F;&#x2F; default is to get queryOptions from the entityManager.
            copy.queryOptions = this.queryOptions;
            copy.entityManager = this.entityManager;

            return copy;
        };

        &#x2F;&#x2F; OData QueryOptions - currently supports filter, orderBy, skip, top and expand.
        &#x2F;&#x2F;        $filter    - done
        &#x2F;&#x2F;        $select
        &#x2F;&#x2F;        $orderBy   - done
        &#x2F;&#x2F;        $top       - done
        &#x2F;&#x2F;        $skip      - done
        &#x2F;&#x2F;        $format
        &#x2F;&#x2F;        $expand    - done
        &#x2F;&#x2F;        $inlinecount

        ctor.prototype._toUri = function (metadataStore) {
            &#x2F;&#x2F; force entityType validation;
            var entityType = this._getEntityType(metadataStore, false);
            if (!entityType) {
                entityType = new EntityType(metadataStore);
            }

            var eq = this;
            var queryOptions = {};
            queryOptions[&quot;$filter&quot;] = toFilterString();
            queryOptions[&quot;$orderby&quot;] = toOrderByString();
            queryOptions[&quot;$skip&quot;] = toSkipString();
            queryOptions[&quot;$top&quot;] = toTopString();
            queryOptions[&quot;$expand&quot;] = toExpandString();
            queryOptions[&quot;$select&quot;] = toSelectString();

            var qoText = toQueryOptionsString();
            return this.resourceName + qoText;

            &#x2F;&#x2F; private methods to this func.

            function toFilterString() {
                var clause = eq.wherePredicate;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }

            function toOrderByString() {
                var clause = eq.orderByClause;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }
            
             function toSelectString() {
                var clause = eq.selectClause;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }
            
            function toExpandString() {
                var clause = eq.expandClause;
                if (!clause) return &quot;&quot;;
                return clause.toOdataFragment(entityType);
            }

            function toSkipString() {
                var count = eq.skipCount;
                if (!count) return &quot;&quot;;
                return count.toString();
            }

            function toTopString() {
                var count = eq.takeCount;
                if (!count) return &quot;&quot;;
                return count.toString();
            }

            function toQueryOptionsString() {
                var qoStrings = [];
                for (var qoName in queryOptions) {
                    var qoValue = queryOptions[qoName];
                    if (qoValue) {
                        qoStrings.push(qoName + &quot;=&quot; + qoValue);
                    }
                }

                if (qoStrings.length &gt; 0) {
                    return &quot;?&quot; + qoStrings.join(&quot;&amp;&quot;);
                } else {
                    return &quot;&quot;;
                }
            }
        };

        ctor.prototype._toFilterFunction = function (entityType) {
            var wherePredicate = this.wherePredicate;
            if (!wherePredicate) return null;
            &#x2F;&#x2F; may throw an exception
            wherePredicate.validate(entityType);
            return wherePredicate.toFunction();
        };

        ctor.prototype._toOrderByComparer = function (entityType) {
            var orderByClause = this.orderByClause;
            if (!orderByClause) return null;
            &#x2F;&#x2F; may throw an exception
            orderByClause.validate(entityType);
            return orderByClause.getComparer();
        };

        &#x2F;&#x2F; private functions
        
        function normalizeResourceName(resourceName) {
            return resourceName;
&#x2F;&#x2F;            if (resourceName) {
&#x2F;&#x2F;                return resourceName.toLowerCase();
&#x2F;&#x2F;            } else {
&#x2F;&#x2F;                return undefined;
&#x2F;&#x2F;            }
        }

        function buildPredicate(entity) {
            var entityType = entity.entityType;
            var predParts = entityType.keyProperties.map(function (kp) {
                return Predicate.create(kp.name, FilterQueryOp.Equals, entity.getProperty(kp.name));
            });
            var pred = Predicate.and(predParts);
            return pred;
        }

        &#x2F;&#x2F; propertyPaths: can pass in create(&quot;A.X,B&quot;) or create(&quot;A.X desc, B&quot;) or create(&quot;A.X desc,B&quot;, true])
        &#x2F;&#x2F; isDesc parameter trumps isDesc in propertyName.

        function orderByCore(that, propertyPaths, isDesc) {
            var newClause;
            var eq = that._clone();
            if (!propertyPaths) {
                eq.orderByClause = null;
                return eq;
            }

            newClause = OrderByClause.create(propertyPaths, isDesc);

            if (eq.orderByClause) {
                eq.orderByClause.addClause(newClause);
            } else {
                eq.orderByClause = newClause;
            }
            return eq;
        }
        
        function selectCore(that, propertyPaths) {
            var eq = that._clone();
            if (!propertyPaths) {
                eq.selectClause = null;
                return eq;
            }
            eq.selectClause = new SelectClause(propertyPaths);
            return eq;
        }
        
        function expandCore(that, propertyPaths) {
            var eq = that._clone();
            if (!propertyPaths) {
                eq.expandClause = null;
                return eq;
            }
            eq.expandClause = new ExpandClause(propertyPaths);
            return eq;
        }
        

        function buildKeyPredicate(entityKey) {
            var keyProps = entityKey.entityType.keyProperties;
            var preds = core.arrayZip(keyProps, entityKey.values, function (kp, v) {
                return Predicate.create(kp.name, FilterQueryOp.Equals, v);
            });
            var pred = Predicate.and(preds);
            return pred;
        }

        function buildNavigationPredicate(entity, navigationProperty) {
            if (navigationProperty.isScalar) {
                if (navigationProperty.foreignKeyNames.length === 0) return null;
                var relatedKeyValues = navigationProperty.foreignKeyNames.map(function (fkName) {
                    return entity.getProperty(fkName);
                });
                var entityKey = new EntityKey(navigationProperty.entityType, relatedKeyValues);
                return buildKeyPredicate(entityKey);
            } else {
                var inverseNp = navigationProperty.inverse;
                if (!inverseNp) return null;
                var foreignKeyNames = inverseNp.foreignKeyNames;
                if (foreignKeyNames.length === 0) return null;
                var keyValues = entity.entityAspect.getKey().values;
                var predParts = core.arrayZip(foreignKeyNames, keyValues, function (fkName, kv) {
                    return Predicate.create(fkName, FilterQueryOp.Equals, kv);
                });
                var pred = Predicate.and(predParts);
                return pred;
            }
        }

        return ctor;
    })();

    var QueryFuncs = (function() {
        var obj = {
            toupper: function(source) { return source.toUpperCase(); },
            tolower: function (source) { return source.toLowerCase(); },
            substring: function(source, pos, length) { return source.substring(pos, length); },   
            substringof: function (source, find) { return source.indexOf(find) &gt;= 0; },
            length:  function(source) { return source.length; },            
            trim: function(source) { return source.trim(); },
            concat: function(s1, s2) { return s1.concat(s2); },
            replace: function (source, find, replace) { return source.replace(find, replace); },
            startswith: function (source, find) { return core.stringStartsWith(source, find); },
            endswith: function (source, find) { return core.stringEndsWith(source, find); },
            indexof: function(source, find) { return source.indexOf(find); },
            round: function(source) { return Math.round(source); },
            ceiling: function(source) {return Math.ceil(source); },
            floor: function (source) { return Math.floor(source); },
            second: function(source) { return source.second;},
            minute: function (source) { return source.minute;},
            day: function(source) { return source.day;},
            month: function(source) { return source.month; },
            year: function(source) { return source.year; }            
        };
        
        return obj;
    })();
    
    var FnNode = (function() {
        &#x2F;&#x2F; valid property name identifier
        var RX_IDENTIFIER = &#x2F;^[a-z_][\w.$]*$&#x2F;i ;
        &#x2F;&#x2F; comma delimited expressions ignoring commas inside of quotes.
        var RX_COMMA_DELIM1 = &#x2F;(&#x27;[^&#x27;]*&#x27;|[^,]+)&#x2F;g ;
        var RX_COMMA_DELIM2 = &#x2F;(&quot;[^&quot;]*&quot;|[^,]+)&#x2F;g ;
        
        var ctor = function(source, tokens) {
            var parts = source.split(&quot;:&quot;);
            if (parts.length == 1) {
                var value = parts[0].trim();
                this.value = value;
                &#x2F;&#x2F; value is either a string, a quoted string, a number, a bool value, or a date
                &#x2F;&#x2F; if a string ( not a quoted string) then this represents a property name.
                var firstChar = value.substr(0,1);
                var quoted = firstChar == &quot;&#x27;&quot; || firstChar == &#x27;&quot;&#x27;;
                if (quoted) {
                    var unquoted = value.substr(1, value.length - 2);
                    this.fn = function(entity) { return unquoted; };
                } else {
                    var isIdentifier = RX_IDENTIFIER.test(value);
                    if (isIdentifier) {
                        this.propertyPath = value;
                        this.fn = createPropFunction(value);
                    } else {
                        this.fn = function(entity) { return value; };
                    }
                } 
            } else {
                this.fnName = parts[0].trim().toLowerCase();
                this.localFn = QueryFuncs[this.fnName];
                var that = this;
                this.fn = function(entity) {
                    var resolvedNodes = that.fnNodes.map(function(fnNode) {
                        var argVal = fnNode.fn(entity);
                        return argVal;
                    });
                    var val = that.localFn.apply(null, resolvedNodes);
                    return val;
                };
                var argSource = tokens[parts[1]].trim();
                if (argSource.substr(0, 1) == &quot;(&quot;) {
                    argSource = argSource.substr(1, argSource.length - 2);
                }
                var commaMatchStr = source.indexOf(&quot;&#x27;&quot;) &gt;= 0 ? RX_COMMA_DELIM1 : RX_COMMA_DELIM2;
                var args = argSource.match(commaMatchStr);
                this.fnNodes = args.map(function(a) {
                    return new FnNode(a, tokens);
                });
            }
        };

        ctor.create = function(source) {
            var regex = &#x2F;\([^()]*\)&#x2F; ;
            var m;
            var tokens = [];
            var i = 0;
            while (m = regex.exec(source)) {
                var token = m[0];
                tokens.push(token);
                var repl = &quot;:&quot; + i++;
                source = source.replace(token, repl);
            }
            var node = new FnNode(source, tokens);
            return node;
        };

        ctor.prototype.toString = function() {
            if (this.fnName) {
                var args = this.fnNodes.map(function(fnNode) {
                    return fnNode.toString();
                });
                var uri = this.fnName + &quot;(&quot; + args.join(&quot;,&quot;) + &quot;)&quot;;
                return uri;
            } else {
                return this.value;
            }
        };

        ctor.prototype.toOdataFragment = function(entityType) {
            if (this.fnName) {
                var args = this.fnNodes.map(function(fnNode) {
                    return fnNode.toOdataFragment(entityType);
                });                
                var uri = this.fnName + &quot;(&quot; + args.join(&quot;,&quot;) + &quot;)&quot;;
                return uri;
            } else {
                var firstChar = this.value.substr(0, 1);
                if (firstChar === &quot;&#x27;&quot; || firstChar === &#x27;&quot;&#x27;) {
                    return this.value;                  
                } else if (this.value == this.propertyPath) {
                    return entityType._clientPropertyPathToServer(this.propertyPath);
                } else {
                    return this.value;
                }
            }
        };

        ctor.prototype.validate = function(entityType) {
            &#x2F;&#x2F; will throw if not found;
            if (this._isValidated) return;            
            this._isValidated = true;
            if (this.propertyPath) {
                entityType.getProperty(this.propertyPath, true);
            } else if (this.fnNodes) {
                this.fnNodes.forEach(function(node) {
                    node.validate(entityType);
                });
            }
        };
        

        return ctor;
    })();
   
    var FilterQueryOp = function () {
        &#x2F;**
        FilterQueryOp is an &#x27;Enum&#x27; containing all of the valid  {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} 
        filter operators for an {{#crossLink &quot;EntityQuery&quot;}}{{&#x2F;crossLink}}.

        @class FilterQueryOp
        @static
        **&#x2F;
        var aEnum = new Enum(&quot;FilterQueryOp&quot;);
        &#x2F;**
        Aliases: &quot;eq&quot;, &quot;==&quot;
        @property Equals {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.Equals = aEnum.addSymbol({ operator: &quot;eq&quot;, aliases: [&quot;==&quot;] });
        &#x2F;**
        Aliases: &quot;ne&quot;, &quot;!=&quot;
        @property NotEquals {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.NotEquals = aEnum.addSymbol({ operator: &quot;ne&quot;, aliases: [&quot;!=&quot;] });
        &#x2F;**
        Aliases: &quot;gt&quot;, &quot;&gt;&quot;
        @property GreaterThan {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.GreaterThan = aEnum.addSymbol({ operator: &quot;gt&quot;, aliases: [&quot;&gt;&quot;] });
        &#x2F;**
        Aliases: &quot;lt&quot;, &quot;&lt;&quot;
        @property LessThan {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.LessThan = aEnum.addSymbol({ operator: &quot;lt&quot;, aliases: [&quot;&lt;&quot;] });
        &#x2F;**
        Aliases: &quot;ge&quot;, &quot;&gt;=&quot;
        @property GreaterThanOrEqual {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.GreaterThanOrEqual = aEnum.addSymbol({ operator: &quot;ge&quot;, aliases: [&quot;&gt;=&quot;] });
        &#x2F;**
        Aliases: &quot;le&quot;, &quot;&lt;=&quot;
        @property LessThanOrEqual {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.LessThanOrEqual = aEnum.addSymbol({ operator: &quot;le&quot;, aliases: [&quot;&lt;=&quot;] });
        &#x2F;**
        String operation: Is a string a substring of another string.
        Aliases: &quot;substringof&quot;
        @property Contains {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.Contains = aEnum.addSymbol({ operator: &quot;substringof&quot;, isFunction: true });
        &#x2F;**
        @property StartsWith {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.StartsWith = aEnum.addSymbol({ operator: &quot;startswith&quot;, isFunction: true });
        &#x2F;**
        @property EndsWith {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.EndsWith = aEnum.addSymbol({ operator: &quot;endswith&quot;, isFunction: true });
        aEnum.seal();
        aEnum._map = function () {
            var map = {};
            aEnum.getSymbols().forEach(function (s) {
                map[s.name.toLowerCase()] = s;
                map[s.operator.toLowerCase()] = s;
                if (s.aliases) {
                    s.aliases.forEach(function (alias) {
                        map[alias.toLowerCase()] = s;
                    });
                }
            });
            return map;
        } ();
        aEnum.from = function (op) {
            if (aEnum.contains(op)) {
                return op;
            } else {
                return aEnum._map[op.toLowerCase()];
            }
        };
        return aEnum;
    } ();

    var BooleanQueryOp = function () {
        var aEnum = new Enum(&quot;BooleanQueryOp&quot;);
        aEnum.And = aEnum.addSymbol({ operator: &quot;and&quot;, aliases: [&quot;&amp;&amp;&quot;] });
        aEnum.Or = aEnum.addSymbol({ operator: &quot;or&quot;, aliases: [&quot;||&quot;] });
        aEnum.Not = aEnum.addSymbol({ operator: &quot;not&quot;, aliases: [&quot;~&quot;, &quot;!&quot;] });

        aEnum.seal();
        aEnum._map = function () {
            var map = {};
            aEnum.getSymbols().forEach(function (s) {
                map[s.name.toLowerCase()] = s;
                map[s.operator.toLowerCase()] = s;
                if (s.aliases) {
                    s.aliases.forEach(function (alias) {
                        map[alias.toLowerCase()] = s;
                    });
                }
            });
            return map;
        } ();
        aEnum.from = function (op) {
            if (aEnum.contains(op)) {
                return op;
            } else {
                return aEnum._map[op.toLowerCase()];
            }
        };
        return aEnum;
    } ();

    var Predicate = (function () {
        &#x2F;**  
        Used to define a &#x27;where&#x27; predicate for an EntityQuery.  Predicates are immutable, which means that any
        method that would modify a Predicate actually returns a new Predicate. 
        @class Predicate
        **&#x2F;
        
        &#x2F;**
        Predicate constructor
        @example
            var p1 = new Predicate(&quot;CompanyName&quot;, &quot;StartsWith&quot;, &quot;B&quot;);
            var query = new EntityQuery(&quot;Customers&quot;).where(p1);
        or 
        @example
            var p2 = new Predicate(&quot;Region&quot;, FilterQueryOp.Equals, null);
            var query = new EntityQuery(&quot;Customers&quot;).where(p2);
        @method &lt;ctor&gt; Predicate
        @param property {String} A property name, a nested property name or an expression involving a property name.
        @param operator {FilterQueryOp|String}
        @param value {Object}
        **&#x2F;
        var ctor = function (propertyOrExpr, operator, value) {
            if (arguments[0].prototype === true) {
                &#x2F;&#x2F; used to construct prototype
                return this;
            }
            return new SimplePredicate(propertyOrExpr, operator, value);
        };

        &#x2F;**  
        Returns whether an object is a Predicate
        @example
            var p1 = new Predicate(&quot;CompanyName&quot;, &quot;StartsWith&quot;, &quot;B&quot;);
            if (Predicate.isPredicate(p1)) {
                &#x2F;&#x2F; do something
            }
        @method isPredicate
        @param o {Object}
        @static
        **&#x2F;
        ctor.isPredicate = function (o) {
            return o instanceof Predicate;
        };

        &#x2F;**  
        Creates a new &#x27;simple&#x27; Predicate.  Note that this method can also take its parameters as an array.
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
        or parameters can be passed as an array.
        @example
            var predArgs = [&quot;Freight&quot;, &quot;gt&quot;, 100];
            var p1 = Predicate.create(predArgs);
        both of these are the same as 
        @example
            var p1 = new Predicate(&quot;Freight&quot;, &quot;gt&quot;, 100);
        @method create 
        @static
        @param property {String} A property name, a nested property name or an expression involving a property name.
        @param operator {FilterQueryOp|String}
        @param value {Object}
        **&#x2F;
        ctor.create = function (property, operator, value) {
            if (Array.isArray(property)) {
                return new SimplePredicate(property[0], property[1], property[2]);
            } else {
                return new SimplePredicate(property, operator, value);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;and&#x27;ing a set of specified Predicates together.
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = Predicate.and(p1, p2, p3);
        or
        @example
            var preds = [p1, p2, p3];
            var newPred = Predicate.and(preds);
        @method and
        @param predicates* {multiple Predicates|Array of Predicate}
        @static
        **&#x2F;
        ctor.and = function (predicates) {
            predicates = argsToPredicates(arguments);
            if (predicates.length === 1) {
                return predicates[0];
            } else {
                return new CompositePredicate(&quot;and&quot;, predicates);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;or&#x27;ing a set of specified Predicates together.
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = Predicate.or(p1, p2, p3);
        or
        @example
            var preds = [p1, p2, p3];
            var newPred = Predicate.or(preds);
        @method or
        @param predicates* {multiple Predicates|Array of Predicate}
        @static
        **&#x2F;
        ctor.or = function (predicates) {
            predicates = argsToPredicates(arguments);
            if (predicates.length === 1) {
                return predicates[0];
            } else {
                return new CompositePredicate(&quot;or&quot;, predicates);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;negating&#x27; a specified predicate.
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = Predicate.not(p1);
        This can also be accomplished using the &#x27;instance&#x27; version of the &#x27;not&#x27; method
        @example
            var not_p1 = p1.not();
        Both of which would be the same as
        @example
            var not_p1 = Predicate.create(&quot;Freight&quot;, &quot;le&quot;, 100);
        @method not
        @param predicate {Predicate}
        @static
        **&#x2F;
        ctor.not = function (predicate) {
            return new CompositePredicate(&quot;not&quot;, [predicate]);
        };

        &#x2F;**  
        &#x27;And&#x27;s this Predicate with one or more other Predicates and returns a new &#x27;composite&#x27; Predicate
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = p1.and(p2, p3);
        or
        @example
            var preds = [p2, p3];
            var newPred = p1.and(preds);
        The &#x27;and&#x27; method is also used to write &quot;fluent&quot; expressions
        @example
            var p4 = Predicate.create(&quot;ShipCity&quot;, &quot;startswith&quot;, &quot;F&quot;)
                .and(&quot;Size&quot;, &quot;gt&quot;, 2000);
        @method and
        @param predicates* {multiple Predicates|Array of Predicate}
        **&#x2F;
        ctor.prototype.and = function (predicates) {
            predicates = argsToPredicates(arguments);
            predicates.unshift(this);
            return ctor.and(predicates);
        };

        &#x2F;**  
        &#x27;Or&#x27;s this Predicate with one or more other Predicates and returns a new &#x27;composite&#x27; Predicate
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = p1.and(p2, p3);
        or
        @example
            var preds = [p2, p3];
            var newPred = p1.and(preds);
        The &#x27;or&#x27; method is also used to write &quot;fluent&quot; expressions
        @example
            var p4 = Predicate.create(&quot;ShipCity&quot;, &quot;startswith&quot;, &quot;F&quot;)
                .or(&quot;Size&quot;, &quot;gt&quot;, 2000);
        @method or
        @param predicates* {multiple Predicates|Array of Predicate}
        **&#x2F;
        ctor.prototype.or = function (predicates) {
            predicates = argsToPredicates(arguments);
            predicates.unshift(this);
            return ctor.or(predicates);
        };

        &#x2F;**  
        Returns the &#x27;negated&#x27; version of this Predicate
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = p1.not();
        This can also be accomplished using the &#x27;static&#x27; version of the &#x27;not&#x27; method
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = Predicate.not(p1);
        which would be the same as
        @example
            var not_p1 = Predicate.create(&quot;Freight&quot;, &quot;le&quot;, 100);
        @method not
        **&#x2F;
        ctor.prototype.not = function () {
            return new CompositePredicate(&quot;not&quot;, [this]);
        };

        &#x2F;&#x2F; methods defined in both subclasses of Predicate

        &#x2F;**  
        Returns the function that will be used to execute this Predicate against the local cache.
        @method toFunction
        @return {Function}
        **&#x2F;

        &#x2F;**  
        Returns a human readable string for this Predicate.
        @method toString
        @return {String}
        **&#x2F;

        &#x2F;**  
        Determines whether this Predicate is &#x27;valid&#x27; for the specified EntityType; This method will throw an exception
        if invalid.
        @method validate
        @param entityType {EntityType} The entityType to validate against.
        **&#x2F;

        function argsToPredicates(argsx) {
            if (argsx.length === 1 &amp;&amp; Array.isArray(argsx[0])) {
                return argsx[0];
            } else {
                var args = Array.prototype.slice.call(argsx);
                if (Predicate.isPredicate(args[0])) {
                    return args;
                } else {
                    return [Predicate.create(args)];
                }
            }
        }

        return ctor;

    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var SimplePredicate = (function () {

        var ctor = function (propertyOrExpr, operator, value) {
            assertParam(propertyOrExpr, &quot;propertyOrExpr&quot;).isString().check();
            assertParam(operator, &quot;operator&quot;).isEnumOf(FilterQueryOp).or().isString().check();
            assertParam(value, &quot;value&quot;).isRequired().check();

            this._propertyOrExpr = propertyOrExpr;
            this._fnNode = FnNode.create(propertyOrExpr);
            this._filterQueryOp = FilterQueryOp.from(operator);
            if (!this._filterQueryOp) {
                throw new Error(&quot;Unknown query operation: &quot; + operator);
            }
            this._value = value;
        };
        ctor.prototype = new Predicate({ prototype: true });

        ctor.prototype.toOdataFragment = function (entityType) {
            var exprFrag = this._fnNode.toOdataFragment(entityType);
            var val = formatValue(this._value);
            if (this._filterQueryOp.isFunction) {
                return this._filterQueryOp.operator + &quot;(&quot; + exprFrag + &quot;,&quot; + val + &quot;) eq true&quot;;
            } else {
                return exprFrag + &quot; &quot; + this._filterQueryOp.operator + &quot; &quot; + val;
            }
        };

        ctor.prototype.toFunction = function () {            
            var predFn = getPredicateFn(this._filterQueryOp, this._value);
            var exprFn = this._fnNode.fn;
            return function(entity) {
                return predFn(makeComparable(exprFn(entity)));
            };
        };

        ctor.prototype.toString = function () {
            var val = formatValue(this._value);
            return this._fnNode.toString() + &quot; &quot; + this._filterQueryOp.operator + &quot; &quot; + val;
        };

        ctor.prototype.validate = function (entityType) {
            &#x2F;&#x2F; throw if not valid
            this._fnNode.validate(entityType);
        };
        
        &#x2F;&#x2F; internal functions

        &#x2F;&#x2F; TODO: still need to handle CacheQueryOptions - string casing, trimming and guids.
        
        function getPredicateFn(filterQueryOp, value) {
            &#x2F;&#x2F; Date do not compare properly but Date.getTime()&#x27;s do.
            if (value instanceof Date) {
                value = value.getTime();
            }
            var predFn;
            switch (filterQueryOp) {
                case FilterQueryOp.Equals:
                    predFn = function (propValue) { return propValue == value; };
                    break;
                case FilterQueryOp.NotEquals:
                    predFn = function (propValue) { return propValue != value; };
                    break;
                case FilterQueryOp.GreaterThan:
                    predFn = function (propValue) { return propValue &gt; value; };
                    break;
                case FilterQueryOp.GreaterThanOrEqual:
                    predFn = function (propValue) { return propValue &gt;= value; };
                    break;
                case FilterQueryOp.LessThan:
                    predFn = function (propValue) { return propValue &lt; value; };
                    break;
                case FilterQueryOp.LessThanOrEqual:
                    predFn = function (propValue) { return propValue &lt;= value; };
                    break;
                case FilterQueryOp.StartsWith:
                    predFn = function (propValue) { return core.stringStartsWith(propValue, value); };
                    break;
                case FilterQueryOp.EndsWith:
                    predFn = function (propValue) { return core.stringEndsWith(propValue, value); };
                    break;
                case FilterQueryOp.Contains:
                    predFn = function (propValue) {
                        return propValue.indexOf(value) &gt;= 0;
                    };
                    break;
                default:
                    throw new Error(&quot;Unknown FilterQueryOp: &quot; + filterQueryOp);
                    
            }
            return predFn;
        }

        function formatValue(val) {
            if (typeof val === &quot;string&quot;) {
                if (core.isGuid(val)) {
                    return &quot;guid&#x27;&quot; + val + &quot;&#x27;&quot;;
                } else {
                    return &quot;&#x27;&quot; + val + &quot;&#x27;&quot;;
                }
            } else if (core.isDate(val)) {
                &#x2F;&#x2F; return core.toISODateString(val);
                return &quot;datetime&#x27;&quot;+val.toISOString() + &quot;&#x27;&quot;;
                &#x2F;&#x2F; return val.toISOString();
            } else {
                return val;
            }
        }

        return ctor;

    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var CompositePredicate = (function () {

        var ctor = function (booleanOperator, predicates) {
            &#x2F;&#x2F; if debug
            if (!Array.isArray(predicates)) {
                throw new Error(&quot;predicates parameter must be an array&quot;);
            }
            &#x2F;&#x2F; end debug
            if ((this.symbol === &quot;not&quot;) &amp;&amp; (predicates.length !== 1)) {
                throw new Error(&quot;Only a single predicate can be passed in with the &#x27;Not&#x27; operator&quot;);
            }

            this._booleanQueryOp = BooleanQueryOp.from(booleanOperator);
            if (!this._booleanQueryOp) {
                throw new Error(&quot;Unknown query operation: &quot; + booleanOperator);
            }
            this._predicates = predicates;
        };
        ctor.prototype = new Predicate({ prototype: true });

        ctor.prototype.toOdataFragment = function (entityType) {
            if (this._predicates.length == 1) {
                return this._booleanQueryOp.operator + &quot; &quot; + &quot;(&quot; + this._predicates[0].toOdataFragment(entityType) + &quot;)&quot;;
            } else {
                var result = this._predicates.map(function (p) {
                    return &quot;(&quot; + p.toOdataFragment(entityType) + &quot;)&quot;;
                }).join(&quot; &quot; + this._booleanQueryOp.operator + &quot; &quot;);
                return result;
            }
        };

        ctor.prototype.toFunction = function () {
            return createFunction(this._booleanQueryOp, this._predicates);
        };

        ctor.prototype.toString = function () {
            if (this._predicates.length == 1) {
                return this._booleanQueryOp.operator + &quot; &quot; + &quot;(&quot; + this._predicates[0] + &quot;)&quot;;
            } else {
                var result = this._predicates.map(function (p) {
                    return &quot;(&quot; + p.toString() + &quot;)&quot;;
                }).join(&quot; &quot; + this._booleanQueryOp.operator + &quot; &quot;);
                return result;
            }
        };

        ctor.prototype.validate = function (entityType) {
            &#x2F;&#x2F; will throw if not found;
            if (this.isValidated) return;
            this._predicates.every(function (p) {
                p.validate(entityType);
            });
            this._isValidated = true;
        };

        function createFunction(booleanQueryOp, predicates) {
            var func, funcs;
            switch (booleanQueryOp) {
                case BooleanQueryOp.Not:
                    func = predicates[0].toFunction();
                    return function (entity) {
                        return !func(entity);
                    };
                case BooleanQueryOp.And:
                    funcs = predicates.map(function (p) { return p.toFunction(); });
                    return function (entity) {
                        var result = funcs.reduce(function (prev, cur) {
                            return prev &amp;&amp; cur(entity);
                        }, true);
                        return result;
                    };
                case BooleanQueryOp.Or:
                    funcs = predicates.map(function (p) { return p.toFunction(); });
                    return function (entity) {
                        var result = funcs.reduce(function (prev, cur) {
                            return prev || cur(entity);
                        }, false);
                        return result;
                    };
                default:
                    throw new Error(&quot;Invalid boolean operator:&quot; + booleanQueryOp);
            }
        }

        return ctor;
    })();

    &#x2F;&#x2F; Not exposed externally for now
    var OrderByClause = (function () {
        &#x2F;*
        An OrderByClause is a description of the properties and direction that the result 
        of a query should be sorted in.  OrderByClauses are immutable, which means that any
        method that would modify an OrderByClause actually returns a new OrderByClause. 

        For example for an Employee object with properties of &#x27;Company&#x27; and &#x27;LastName&#x27; the following would be valid expressions:

            var obc = new OrderByClause(&quot;Company.CompanyName, LastName&quot;) 
                or 
            var obc = new OrderByClause(&quot;Company.CompanyName desc, LastName&quot;) 
                or 
            var obc = new OrderByClause(&quot;Company.CompanyName, LastName&quot;, true);
        @class OrderByClause
        *&#x2F;
        
        &#x2F;*
        @method &lt;ctor&gt; OrderByClause
        @param propertyPaths {String} A &#x27;,&#x27; delimited string of &#x27;propertyPaths&#x27;. Each substring of the &#x27;propertyPaths&#x27; 
        parameter should be a valid property name or property path for the EntityType of the query associated with this clause. 
        @param [isDesc=false] {Boolean}
        *&#x2F;
        var ctor = function (propertyPaths, isDesc) {
            if (propertyPaths.prototype === true) {
                &#x2F;&#x2F; used to construct prototype
                return this;
            }
            return ctor.create(propertyPaths, isDesc);
        };

        &#x2F;*
        Alternative method of creating an OrderByClause. 
        Example for an Employee object with properties of &#x27;Company&#x27; and &#x27;LastName&#x27;: 

            var obc = OrderByClause.create(&quot;Company.CompanyName, LastName&quot;) 
                or 
            var obc = OrderByClause.create(&quot;Company.CompanyName desc, LastName&quot;) 
                or 
            var obc = OrderByClause.create(&quot;Company.CompanyName, LastName&quot;, true);
        @method create 
        @static
        @param propertyPaths {String} A &#x27;,&#x27; delimited string of &#x27;propertyPaths&#x27;. Each substring of the &#x27;propertyPaths&#x27; 
        parameter should be a valid property name or property path for the EntityType of the query associated with this clause. 
        @param [isDesc=false] {Boolean}
        *&#x2F;
        ctor.create = function (propertyPaths, isDesc) {
            if (typeof (propertyPaths) !== &#x27;string&#x27;) {
                throw new Error(&quot;The propertyPaths parameter must be a string.&quot;);
            }
            var pathStrings = propertyPaths.split(&quot;,&quot;);
            if (pathStrings.length &gt; 1) {
                var clauses = pathStrings.map(function (pp) {
                    return new SimpleOrderByClause(pp, isDesc);
                });
                return new CompositeOrderByClause(clauses);
            } else {
                return new SimpleOrderByClause(pathStrings[0], isDesc);
            }
        };

        &#x2F;*
        Returns a &#x27;composite&#x27; OrderByClause by combining other OrderByClauses.
        @method combine
        @static
        @param orderByClauses {Array of OrderByClause}
        *&#x2F;
        ctor.combine = function (orderByClauses) {
            return new CompositeOrderByClause(orderByClauses);
        };

        &#x2F;*
        Returns whether an object is an OrderByClause.
        @method isOrderByClause
        @static
        @param obj {Object}
        *&#x2F;
        ctor.isOrderByClause = function (obj) {
            return obj instanceof OrderByClause;
        };

        &#x2F;*
        Returns whether a new OrderByClause with a specified clause add to the end of this one. 
        @method addClause
        @param orderByClause {OrderByClause}
        *&#x2F;
        ctor.prototype.addClause = function (orderByClause) {
            return new CompositeOrderByClause([this, orderByClause]);
        };

        return ctor;
    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var SimpleOrderByClause = (function () {

        var ctor = function (propertyPath, isDesc) {
            if (!typeof propertyPath == &#x27;string&#x27;) {
                throw new Error(&quot;propertyPath is not a string&quot;);
            }
            propertyPath = propertyPath.trim();

            var properties = propertyPath.split(&#x27; &#x27;);
            &#x2F;&#x2F; parts[0] is the propertyPath; [1] would be whether descending or not.
            if (properties.length &gt; 1 &amp;&amp; isDesc !== true &amp;&amp; isDesc !== false) {
                isDesc = core.stringStartsWith(properties[1].toLowerCase(), &quot;desc&quot;);
                if (!isDesc) {
                    var isAsc = core.stringStartsWith(properties[1].toLowerCase(), &quot;asc&quot;);
                    if (!isAsc) {
                        throw new Error(&quot;the second word in the propertyPath must begin with &#x27;desc&#x27; or &#x27;asc&#x27;&quot;);
                    }
                    isDesc = !isAsc;
                }
            }
            this.propertyPath = properties[0];
            this.isDesc = isDesc;
            this.properties = properties;
        };
        ctor.prototype = new OrderByClause({ prototype: true });

        ctor.prototype.validate = function (entityType) {
            if (!entityType) {
                return;
            } &#x2F;&#x2F; can&#x27;t validate yet
            &#x2F;&#x2F; will throw an exception on bad propertyPath
            entityType.getProperty(this.propertyPath, true);
        };

        ctor.prototype.toOdataFragment = function (entityType) {
            return entityType._clientPropertyPathToServer(this.propertyPath) + (this.isDesc ? &quot; desc&quot; : &quot;&quot;);
        };

        ctor.prototype.getComparer = function () {
            var properties = this.properties;
            var isDesc = this.isDesc;
            return function (entity1, entity2) {
                var value1 = makeComparable(getPropertyPathValue(entity1, properties));
                var value2 = makeComparable(getPropertyPathValue(entity2, properties));
                if (value1 == value2) {
                    return 0;
                } else if (value1 &gt; value2) {
                    return isDesc ? -1 : 1;
                } else {
                    return isDesc ? 1 : -1;
                }
            };
        };


        return ctor;
    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var CompositeOrderByClause = (function () {
        var ctor = function (orderByClauses) {
            var resultClauses = [];
            orderByClauses.forEach(function (obc) {
                if (obc instanceof CompositeOrderByClause) {
                    resultClauses = resultClauses.concat(obc.orderByClauses);
                } else if (obc instanceof SimpleOrderByClause) {
                    resultClauses.push(obc);
                } else {
                    throw new Error(&quot;Invalid argument to CompositeOrderByClause ctor.&quot;);
                }
            });
            this._orderByClauses = resultClauses;

        };
        ctor.prototype = new OrderByClause({ prototype: true });


        ctor.prototype.validate = function (entityType) {
            this._orderByClauses.forEach(function (obc) {
                obc.validate(entityType);
            });
        };

        ctor.prototype.toOdataFragment = function (entityType) {
            var strings = this._orderByClauses.map(function (obc) {
                return obc.toOdataFragment(entityType);
            });
            &#x2F;&#x2F; should return something like CompanyName,Address&#x2F;City desc
            return strings.join(&#x27;,&#x27;);
        };

        ctor.prototype.getComparer = function () {
            var orderByFuncs = this._orderByClauses.map(function (obc) {
                return obc.getComparer();
            });
            return function (entity1, entity2) {
                for (var i = 0; i &lt; orderByFuncs.length; i++) {
                    var result = orderByFuncs[i](entity1, entity2);
                    if (result != 0) {
                        return result;
                    }
                }
                return 0;
            };
        };
        return ctor;
    })();
    
    &#x2F;&#x2F; Not exposed
    var SelectClause = (function () {
        
        var ctor = function (propertyPaths) {
            assertParam(propertyPaths, &quot;propertyPaths&quot;).isString().check();
            this.propertyPaths = propertyPaths;
            this._pathStrings = propertyPaths.split(&quot;,&quot;).map(function(pp) {
                return pp.trim();
            });
        };

        ctor.prototype.validate = function (entityType) {
            if (!entityType) {
                return;
            } &#x2F;&#x2F; can&#x27;t validate yet
            &#x2F;&#x2F; will throw an exception on bad propertyPath
            this._pathStrings.forEach(function(path) {
                entityType.getProperty(path, true);
            });
         };

         ctor.prototype.toOdataFragment = function(entityType) {
             var frag = this._pathStrings.map(function(pp) {
                 return entityType._clientPropertyPathToServer(pp);
             }).join(&quot;,&quot;);
             return frag;
         };

         return ctor;
    })();
    
     &#x2F;&#x2F; Not exposed
    var ExpandClause = (function () {
        
        var ctor = function (propertyPaths) {
            this.propertyPaths = propertyPaths;
            this._pathStrings = propertyPaths.split(&quot;,&quot;).map(function(pp) {
                return pp.trim();
            });
        };
       
&#x2F;&#x2F;        &#x2F;&#x2F; TODO:
&#x2F;&#x2F;        ctor.prototype.validate = function (entityType) {
&#x2F;&#x2F;            
&#x2F;&#x2F;        };

        ctor.prototype.toOdataFragment = function(entityType) {
            var frag = this._pathStrings.map(function(pp) {
                return entityType._clientPropertyPathToServer(pp);
            }).join(&quot;,&quot;);
            return frag;
        };

        return ctor;
    })();
    

    &#x2F;&#x2F; propertyPath can be either an array of paths or a &#x27;.&#x27; delimited string.
    
    function createPropFunction(propertyPath) {
        var properties = propertyPath.split(&#x27;.&#x27;);
        if (properties.length === 1) {
            return function(entity) {
                return entity.getProperty(propertyPath);
            };
        } else {
            return function(entity) {
                return getPropertyPathValue(entity, properties);
            };
        }
    }

    function getPropertyPathValue(obj, propertyPath) {
        var properties;
        if (Array.isArray(propertyPath)) {
            properties = propertyPath;
        } else {
            properties = propertyPath.split(&quot;.&quot;);
        }
        if (properties.length === 1) {
            return obj.getProperty(propertyPath);
        } else {
            var nextValue = obj;
            for (var i = 0; i &lt; properties.length; i++) {
                nextValue = nextValue.getProperty(properties[i]);
                &#x2F;&#x2F; == in next line is deliberate - checks for undefined or null.
                if (nextValue == null) {
                    break;
                }
            }
            return nextValue;
        }
    }

    function makeComparable(value) {
        &#x2F;&#x2F; dates don&#x27;t perform equality comparisons properly 
        if (value instanceof Date) {
            return value.getTime();
        } else {
            return value;
        }
    }

    &#x2F;&#x2F; Fixup --- because EntityAspect does not have access to EntityQuery or EntityMetadata

    EntityAspect.prototype.loadNavigationProperty = function (navigationProperty, callback, errorCallback) {
        var entity = this.entity;
        var navProperty = entity.entityType._checkNavProperty(navigationProperty);
        var query = EntityQuery.fromEntityNavigation(entity, navProperty, callback, errorCallback);
        return entity.entityAspect.entityManager.executeQuery(query, callback, errorCallback);
    };

    &#x2F;&#x2F; expose
    &#x2F;&#x2F; do not expose SimplePredicate and CompositePredicate 
    &#x2F;&#x2F; Note: FnNode only exposed for testing purposes
    return {
        FilterQueryOp: FilterQueryOp,
        Predicate: Predicate,
        EntityQuery: EntityQuery,
        FnNode: FnNode,
        &#x2F;&#x2F; Not documented - only exposed for testing purposes
        OrderByClause: OrderByClause
    };
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
