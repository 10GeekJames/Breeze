/*
 * OData query expression grammar.
 * Note: use this gramar with pegjs:
 *  - http://pegjs.majda.cz/ 
 *  - https://github.com/dmajda/pegjs
 */

 {
    fn = function(name, args) {
        if (args.length === 1) {
            return { type: "fn_1", name: name, p0: args[0] };
        } else if (args.length === 2) {
            return { type: "fn_2", name: name, p0: args[0], p1: args[1] };
        } else if (args.length === 3) {
            return { type: "fn_3", name: name, p0: args[0], p1: args[1], p2: args[2] };
        }
    }

    flatten = function(list) {
        if (list.join) {
           var f = list.map(function(l) { return flatten(l); }  );
           return f.join('');
        } else {
           return list;
        }
    }

 }

start                       = query



/*
 * Basic cons.
 */

WSP                         =  ' '  //Whitespace
DIGIT                       = [0-9]
INT                         = a:DIGIT+ { return a.join(''); }
HEXDIG                      =   [0-9a-fA-F]
//peg does not support repetition (ie: [a]{4})
HEXDIG2                     =   HEXDIG HEXDIG
HEXDIG4                     =   HEXDIG2 HEXDIG2
HEXDIG8                     =   HEXDIG4 HEXDIG8
SQUOTE                      =   "%x27" / "'"

// end: Basic cons

/* 
 * OData literals - adapted from OData ABNF:
 *  - http://www.odata.org/media/30002/OData%20ABNF.html
 */

literal                     =   null /
                                binary / 
                                boolean /
                                numericLiteral /
                                dateTime /
                                dateTimeOffset /
                                guid /
                                string

null                        =   "null" ( "'" identifier "'" )?
                                  { return { type: "lit_null" } }
                                // The optional qualifiedTypeName is used to specify what type this null value should be considered. 
                                // Knowing the type is useful for function overload resolution purposes. 

binary                      =   binary:(( "%d88" / "binary" ) SQUOTE HEXDIG HEXDIG SQUOTE)
                                  { return { type: "lit_binary", value: binary } }
                                // note: "X" is case sensitive "binary" is not hence using the character code.

boolean                     =   "true"  { return { type: "lit_bool", value: true  } } /
                                "false" { return { type: "lit_bool", value: false } }

dateTime                    =  "datetime" SQUOTE a:dateTimeBody SQUOTE
                                 { return { type: "lit_dateTime", value: new Date(a) } }

dateTimeOffset              =  "datetimeoffset" SQUOTE a:dateTimeOffsetBody SQUOTE
                                 { return { type: "lit_dateTimeOffset", value: new Date(a) } }

numericLiteral              =  number:decimalLiteral
                                 { return { type: "lit_number", value: parseFloat(flatten(number)) } }

guid                        =  "guid" SQUOTE guid:(HEXDIG8 "-" HEXDIG4 "-" HEXDIG4 "-" HEXDIG8 HEXDIG4) SQUOTE
                                 { return { type: "lit_guid",   value: guid } }

string                      =   SQUOTE v:validstring SQUOTE
                                 { return { type: "lit_string", value: v } }


zeroToTwelve                =   a:"0" b:[1-9] { return a + b;} / a:"1" b:[0-2] { return a + b; }
zeroToThirteen              =   zeroToTwelve / "13"
zeroToSixty                 =   "60" / a:[0-5] b:DIGIT { return a + b; }
zeroToThirtyOne             =   "3" a:[0-1] { return "3" + a; } / a:[0-2] b:DIGIT { return a + b; }
zeroToTwentyFour            =   "2" a:[0-4] { return "2" + a; } / a:[0-1] b:DIGIT { return a + b; }
year                        =  a:DIGIT b:DIGIT c:DIGIT d:DIGIT { return a + b + c + d; }
month                       =   zeroToTwelve
day                         =   zeroToThirtyOne
hour                        =   zeroToTwentyFour
minute                      =   zeroToSixty
second                      =   zeroToSixty
nanoSeconds                 =  INT
dateTimeBodyA               =  a:year "-" b:month "-" c:day "T" d:hour ":" e:minute "Z"?
                                 { return a + '-' + b + '-' + c + "T" + d + ":" + e; }
dateTimeBodyB               =  a:dateTimeBodyA ":" b:second "Z"? { return a + ":" + b; }
dateTimeBodyC               =  a:dateTimeBodyB "." b:nanoSeconds { return a + "." + b; }
dateTimeBodyD               =  a:dateTimeBodyC "-" b:zeroToTwentyFour ":" c:zeroToSixty
                                 {  return a + "-" + b + ":" + c;  }
dateTimeBody                =  dateTimeBodyD
                             / dateTimeBodyC
                             / dateTimeBodyB
                             / dateTimeBodyA
dateTimeOffsetBody          =  dateTimeBody "Z" / // TODO: is the Z optional?
                               dateTimeBody sign zeroToThirteen ":00" /
                               dateTimeBody sign zeroToThirteen /
                               dateTimeBody sign zeroToTwelve ":" zeroToSixty /
                               dateTimeBody sign zeroToTwelve
sign                        =   "+" / "-"
nan                         =   "NaN"
negativeInfinity            =   "-INF"
positiveInfinity            =   "INF"
nanInfinity                 =   nan / negativeInfinity / positiveInfinity
decimalLiteral
  = parts:(decimalIntegerLiteral "." decimalDigits? exponentPart?)
  / parts:(decimalDigits exponentPart?)
  / parts:(decimalIntegerLiteral list:exponentPart?)
decimalIntegerLiteral
  = "0"
  / parts:(nonZeroDigit decimalDigits?)
decimalDigits
  = [0-9]+
nonZeroDigit
  = [1-9]
exponentPart
  = exponentIndicator signedInteger
exponentIndicator
  = [eE]
signedInteger
  = [-+]? decimalDigits

// end: OData literals

/*
 * OData identifiers
 */

unreserved                  = a:[a-zA-Z0-9-_]+ { return a.join(''); }
validstring                 = a:[^']* { return a.join(''); }
identifierPart              = a:[a-zA-Z] b:unreserved { return a + b; }
identifier                  = 
                                a:identifierPart list:("." i:identifier {return i;})? {
                                    if (list === "") list = [];
                                    if (require('util').isArray(list[0])) {
                                        list = list[0];
                                    }
                                    list.unshift(a);
                                    return list.join('.');
                                }
                                
// --

/*
 * OData query options
 */

// $top
top                         =   "$top=" a:INT { return { '$top': ~~a }; }
                            /   "$top=" .* { return {"error": 'invalid $top parameter'}; }

// $expand
expand                      =   "$expand=" list:expandList { return { "$expand": list }; }
                            /   "$expand=" .* { return {"error": 'invalid $expand parameter'}; }

expandList                  =   i:identifierPath list:("," WSP? l:expandList {return l;})? {
                                    if (list === "") list = [];
                                    if (require('util').isArray(list[0])) {
                                        list = list[0];
                                    }
                                    list.unshift(i);
                                    return list;
                                }

//$skip
skip                        =   "$skip=" a:INT {return {'$skip': ~~a }; }
                            /   "$skip=" .* { return {"error": 'invalid $skip parameter'}; }

//$format
format                      =   "$format=" unreserved*
                            /   "$format=" .* { return {"error": 'invalid $format parameter'}; }
//$inlinecount
inlinecount                 =   "$inlinecount=" unreserved*
                            /   "$inlinecount=" .* { return {"error": 'invalid $inlinecount parameter'}; }

// $orderby
orderby                     =   "$orderby=" list:orderbyList { 
                                    return { "$orderby": list }; }
                            /   "$orderby=" .* { return {"error": 'invalid $orderby parameter'}; }

orderbyList                 = i:(id:identifier ord:(WSP ("asc"/"desc"))? { 
                                    var result = {};
                                    result[id] = ord[1] || 'asc';
                                    return result;
                                }) 
                              list:("," WSP? l:orderbyList{return l;})? {

                                    if (list === "") list = [];
                                    if (require('util').isArray(list[0])) {
                                        list = list[0];
                                    }
                                    list.unshift(i);
                                    return list;
                                }

//$select
select                      =   "$select=" list:selectList { return { "$select":list }; }
                            /   "$select=" .* { return {"error": 'invalid $select parameter'}; }

identifierPathParts         =   "/" i:identifierPart list:identifierPathParts? {
                                    if (list === "") list = [];
                                    if (require('util').isArray(list[0])) {
                                        list = list[0];
                                    }
                                    list.unshift("/" + i);
                                    return list;
                                }
identifierPath              =   a:identifier b:identifierPathParts? { return a + b; }
selectList                  =   
                                i:(a:identifierPath b:".*"?{return a + b;}/"*") list:("," WSP? l:selectList {return l;})? {
                                    if (list === "") list = [];
                                    if (require('util').isArray(list[0])) {
                                        list = list[0];
                                    }
                                    list.unshift(i);
                                    return list;
                                }

//filter


filter                      =   "$filter=" list:filterExpr { 
                                    return { 
                                        "$filter": list
                                    }; 
                                }
                            /   "$filter=" .* { return {"error": 'invalid $filter parameter'}; }


filterExpr = baseExpr

baseExpr = WSP* p1:n0Expr x:(andOrExpr)*  {
   if (x.length > 0) {
      return { type: x[0].type, op: x[0].op, p1: p1, p2: x[0].p2 };
   } else {
      return p1;
   }
}


n0Expr   = WSP* p1:n1Expr x:(boolExpr/mathExpr)* {
   if (x.length > 0) {
         return { type: x[0].type, op: x[0].op, p1: p1, p2: x[0].p2 };
      } else {
         return p1;
      }
}

andOrExpr  =   WSP+ op:andOrOp  WSP+ p2:baseExpr { return { type: "op_andOr", op:op, p2: p2 }}
boolExpr   =   WSP+ op:boolOp   WSP+ p2:n0Expr   { return { type: "op_bool",  op:op, p2: p2 }}
mathExpr   =   WSP+ op:mathOp   WSP+ p2:n0Expr   { return { type: "op_math",  op:op, p2: p2 }}

n1Expr   =  unaryExpr / methodCallExpr / literal / memberExpr / parenExpr

memberExpr  =  member:identifierPath           { return { type: "member", value:  member  } }
parenExpr   = "("  expr:baseExpr  ")"          { return  expr   }

unaryExprOp =  "not " / "-"
unaryExpr   = op:unaryExprOp expr:baseExpr     { return { type: "unaryOp", op: op, value: expr } }

boolOp = "eq" / "ne" / "lt" / "le" / "gt" / "ge"
mathOp = "add" / "sub" / "mul" / "div" / "mod"
andOrOp =  "and" / "or"

// subExpr = identifierPart / anyMethodCallExpr / allMethodCallExpr

lambdaVariable = identifier + ":"
lambdaExpr     = lambdaVariable  baseExpr


methodCallExpr          =   anyMethodCallExpr
                          / allMethodCallExpr
                          / replaceMethodCallExpr
                          / substring1MethodCallExpr
                          / substring2MethodCallExpr
                          / toLowerMethodCallExpr
                          / toUpperMethodCallExpr
                          / trimMethodCallExpr
                          / concatMethodCallExpr
                          / lengthMethodCallExpr
                          / indexOfMethodCallExpr
                          / secondMethodCallExpr
                          / minuteMethodCallExpr
                          / hourMethodCallExpr
                          / dayMethodCallExpr
                          / monthMethodCallExpr
                          / yearMethodCallExpr
                          / roundMethodCallExpr
                          / floorMethodCallExpr
                          / ceilingMethodCallExpr
                          / isOf1MethodCallExpr
                          / isOf2MethodCallExpr
                          / substringOfMethodCallExpr
                          / startsWithMethodCallExpr
                          / endsWithMethodCallExpr

anyMethodCallExpr         = n:"any"         a:larg    { return fn(n, a); }
allMethodCallExpr         = n:"all"         a:larg    { return fn(n, a); }
replaceMethodCallExpr     = n:"replace"     a:args3   { return fn(n, a); }
substring1MethodCallExpr  = n:"substring"   a:args2   { return fn(n, a); }
substring2MethodCallExpr  = n:"substring"   a:args2   { return fn(n, a); }
toLowerMethodCallExpr     = n:"tolower"     a:args1   { return fn(n, a); }
toUpperMethodCallExpr     = n:"toupper"     a:args1   { return fn(n, a); }
trimMethodCallExpr        = n:"trim"        a:args1   { return fn(n, a); }
concatMethodCallExpr      = n:"concat"      a:args2   { return fn(n, a); }
lengthMethodCallExpr      = n:"length"      a:args1   { return fn(n, a); }
indexOfMethodCallExpr     = n:"indexof"     a:args2   { return fn(n, a); }
substringOfMethodCallExpr = n:"substringof" a:args2   { return fn(n, a); }
startsWithMethodCallExpr  = n:"startswith"  a:args2   { return fn(n, a); }
endsWithMethodCallExpr    = n:"endswith"    a:args2   { return fn(n, a); }
secondMethodCallExpr      = n:"second"      a:args1   { return fn(n, a); }
minuteMethodCallExpr      = n:"minute"      a:args1   { return fn(n, a); }
hourMethodCallExpr        = n:"hour"        a:args1   { return fn(n, a); }
dayMethodCallExpr         = n:"day"         a:args1   { return fn(n, a); }
monthMethodCallExpr       = n:"month"       a:args1   { return fn(n, a); }
yearMethodCallExpr        = n:"year"        a:args1   { return fn(n, a); }

roundMethodCallExpr       = n:"round"       a:args1   { return fn(n, a); }
ceilingMethodCallExpr     = n:"ceiling"     a:args1   { return fn(n, a); }
floorMethodCallExpr       = n:"floor"       a:args1   { return fn(n, a); }

isOf1MethodCallExpr       = n:"isof"        a:args1   { return fn(n, a); }
isOf2MethodCallExpr       = n:"isof"        a:args2   { return fn(n, a); }

larg  = "(" p1:lambdaExpr ")"                               { return [ p1 ]; }
args1 = "(" p1:baseExpr ")"                                 { return [ p1 ]; }
args2 = "(" p1:baseExpr "," p2:baseExpr ")"                 { return [ p1, p2 ]; }
args3 = "(" p1:baseExpr "," p2:baseExpr "," p3:baseExpr ")" { return [ p1, p2, p3 ]; }


unsupported                 =   "$" er:.* { return { error: "unsupported method: " + er }; }

//end: OData query options

/*
 * OData query
 */

expList                     = e:exp "&" el:expList { return [e].concat(el); } /
                              e:exp { return [e]; }
                              

exp                         =
                                expand / 
                                filter /
                                orderby /
                                skip /
                                top /
                                format /
                                inlinecount /
                                select /
                                unsupported

query                       = list:expList {
                                    //turn the array into an object like:
                                    // { $top: 5, $skip: 10 }
                                    var result = {};
                                    list = list || [];
                                    for(var i in list){

                                        if (list[i] !== "") {
                                            var paramName = Object.keys(list[i])[0]; //ie: $top
                                            result[paramName] = list[i][paramName];
                                        }
                                    }
                                    return result;
                                }