using Breeze.WebApi;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using NHibernate;
using NHibernate.Cfg;
using NHibernate.Linq;
using NHibernate.Metadata;
using NHibernate.Type;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;

namespace Breeze.Nhibernate.WebApi
{
    public class NHContext : ContextProvider, IDisposable
    {
        private ISession session;
        protected Configuration configuration;

        /// <summary>
        /// Create a new context for the given session.  
        /// Each thread should have its own NHContext and Session.
        /// </summary>
        /// <param name="session">Used for queries and updates</param>
        /// <param name="configuration">Used for metadata generation</param>
        public NHContext(ISession session, Configuration configuration)
        {
            this.session = session;
            this.configuration = configuration;
        }

        public ISession Session
        {
            get { return session; }
        }

        public NhQueryableInclude<T> GetQuery<T>()
        {
            return new NhQueryableInclude<T>(session.GetSessionImplementation());
        }

        public void Close()
        {
            if (session != null && session.IsOpen) session.Close();
        }

        public void Dispose()
        {
            Close();
        }

        #region Metadata

        protected override string BuildJsonMetadata()
        {
            var meta = GetMetadata();
            var serializerSettings = new JsonSerializerSettings()
            {
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                PreserveReferencesHandling = PreserveReferencesHandling.Objects,
                ContractResolver = new CamelCasePropertyNamesContractResolver()
            };

            var json = JsonConvert.SerializeObject(meta, Formatting.Indented);
            return json;
        }

        protected IDictionary<string, object> GetMetadata()
        {
            if (_metadata == null)
            {
                var builder = new NHBreezeMetadata(session.SessionFactory, configuration);
                _metadata = builder.BuildMetadata();
            }
            return _metadata;
        }

        #endregion
        #region Save Changes

        private Dictionary<EntityInfo, KeyMapping> EntityKeyMapping = new Dictionary<EntityInfo, KeyMapping>();
        private Dictionary<EntityInfo, ICollection<ValidationResult>> ValidationResults = new Dictionary<EntityInfo, ICollection<ValidationResult>>();
        private IDictionary<string, object> _metadata;

        /// <summary>
        /// Persist the changes to the entities in the saveMap.
        /// This implements the abstract method in ContextProvider
        /// </summary>
        /// <param name="saveMap">Map of Type -> List of entities of that type</param>
        /// <returns>List of KeyMappings, which map the temporary keys to their real generated keys</returns>
        protected override List<KeyMapping> SaveChangesCore(Dictionary<Type, List<EntityInfo>> saveMap)
        {
            using (var tx = session.BeginTransaction())
            {
                try
                {
                    ProcessSaves(saveMap);

                    if (ValidationResults.Any())
                    {
                        var msg = CollectValidationErrors();
                        throw new ValidationException(msg);
                    }

                    session.Flush();
                    tx.Commit();
                    RefreshFromSession(saveMap);
                }
                catch (PropertyValueException pve)
                {
                    // NHibernate can throw this
                    if (tx.IsActive) tx.Rollback();
                    var msg = string.Format("'{0}' validation error: property={1}, message={2}", pve.EntityName, pve.PropertyName, pve.Message);
                    throw new ValidationException(msg);
                }
                catch (Exception)
                {
                    if (tx.IsActive) tx.Rollback();
                    throw;
                }
                finally
                {
                    if (session.IsOpen) session.Close();
                }
            }

            return UpdateAutoGeneratedKeys();
        }

        /// <summary>
        /// Concatenate all the validation messages together.
        /// </summary>
        /// <returns></returns>
        protected string CollectValidationErrors()
        {
            var sb = new StringBuilder();
            foreach (var kvp in ValidationResults)
            {
                var entityInfo = kvp.Key;
                var entity = entityInfo.Entity;
                var type = entity.GetType();
                var id = GetIdentifier(entity);

                foreach(var r in kvp.Value)
                {
                    sb.AppendFormat("\n'{0}';{1} validation error: {2}",
                        type.Name, id, r.ToString());
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Persist the changes to the entities in the saveMap.
        /// </summary>
        /// <param name="saveMap"></param>
        private void ProcessSaves(Dictionary<Type, List<EntityInfo>> saveMap)
        {
            // Get the map of foreign key relationships
            var fkMap = (IDictionary<string, string>)GetMetadata()[NHBreezeMetadata.FK_MAP];

            // Relate entities in the saveMap to each other
            FixupRelationships(saveMap, fkMap, false);

            foreach (var kvp in saveMap)
            {
                var entityType = kvp.Key;
                var classMeta = session.SessionFactory.GetClassMetadata(entityType);

                foreach (var entityInfo in kvp.Value)
                {
                    AddKeyMapping(entityInfo, entityType, classMeta);
                    ProcessEntity(entityInfo, classMeta);
                }
            }

            // Relate entities in the saveMap to other NH entities, so NH can save the FK values.
            FixupRelationships(saveMap, fkMap, true);

        }

        /// <summary>
        /// Connect the related entities in the saveMap to other entities.
        /// </summary>
        /// <param name="saveMap">Map of entity types -> entity instances to save</param>
        /// <param name="fkMap">Map of relationship name -> foreign key name</param>
        /// <param name="canUseSession">Whether we can load the related entity via the Session</param>
        private void FixupRelationships(Dictionary<Type, List<EntityInfo>> saveMap, IDictionary<string, string> fkMap, bool canUseSession)
        {
            foreach (var kvp in saveMap)
            {
                var entityType = kvp.Key;
                var classMeta = session.SessionFactory.GetClassMetadata(entityType);

                foreach (var entityInfo in kvp.Value)
                {
                    FixupRelationships(entityInfo, classMeta, saveMap, fkMap, canUseSession);
                }
            }
        }

        /// <summary>
        /// Connect the related entities based on the foreign key values.
        /// Note that this may cause related entities to be loaded from the DB if they are not already in the session.
        /// </summary>
        /// <param name="entityInfo">Entity that will be saved</param>
        /// <param name="meta">Metadata about the entity type</param>
        /// <param name="saveMap">Map of entity types -> entity instances to save</param>
        /// <param name="fkMap">Map of relationship name -> foreign key name</param>
        /// <param name="canUseSession">Whether we can load the related entity via the Session</param>
        private void FixupRelationships(EntityInfo entityInfo, IClassMetadata meta, Dictionary<Type, List<EntityInfo>> saveMap, 
            IDictionary<string, string> fkMap, bool canUseSession)
        {
            var entity = entityInfo.Entity;
            var propNames = meta.PropertyNames;
            var propTypes = meta.PropertyTypes;

            for (int i = 0; i < propNames.Length; i++)
            {
                var propType = propTypes[i];
                if (propType.IsAssociationType && propType.IsEntityType)
                {
                    var propName = propNames[i];

                    object relatedEntity = meta.GetPropertyValue(entity, propName, EntityMode.Poco);
                    if (relatedEntity != null) continue;    // entities are already connected

                    var relKey = meta.EntityName + '.' + propName;
                    var foreignKeyName = fkMap[relKey];

                    object id = GetForeignKeyValue(entityInfo, meta, foreignKeyName, canUseSession);

                    if (id != null)
                    {
                        relatedEntity = FindInSaveMap(propType.ReturnedClass, id, saveMap);

                        if (relatedEntity == null && canUseSession)
                        {
                            var relatedEntityName = propType.Name;
                            relatedEntity = session.Load(relatedEntityName, id);
                        }

                        if (relatedEntity != null)
                            meta.SetPropertyValue(entity, propName, relatedEntity, EntityMode.Poco);
                    }
                }
            }
        }

        /// <summary>
        /// Get the value of the foreign key property.  This comes from the entity, but if that value is
        /// null, we may try to get it from the originalValuesMap.
        /// </summary>
        /// <param name="entityInfo"></param>
        /// <param name="meta"></param>
        /// <param name="foreignKeyName"></param>
        /// <param name="currentValuesOnly">if false, and the entity is deleted, try to get the value from the originalValuesMap 
        /// if we were unable to get it from the entity.</param>
        /// <returns></returns>
        private object GetForeignKeyValue(EntityInfo entityInfo, IClassMetadata meta, string foreignKeyName, bool currentValuesOnly)
        {
            var entity = entityInfo.Entity;
            object id = null;
            if (foreignKeyName == meta.IdentifierPropertyName)
                id = meta.GetIdentifier(entity, EntityMode.Poco);
            else if (meta.PropertyNames.Contains(foreignKeyName))
                id = meta.GetPropertyValue(entity, foreignKeyName, EntityMode.Poco);
            else if (meta.IdentifierType.IsComponentType)
            {
                // compound key
                var compType = meta.IdentifierType as EmbeddedComponentType;
                var index = Array.IndexOf<string>(compType.PropertyNames, foreignKeyName);
                if (index >= 0)
                {
                    var idComp = meta.GetIdentifier(entity, EntityMode.Poco);
                    id = compType.GetPropertyValue(idComp, index, EntityMode.Poco);
                }
            }

            if (id == null && !currentValuesOnly && entityInfo.EntityState == EntityState.Deleted)
            {
                entityInfo.OriginalValuesMap.TryGetValue(foreignKeyName, out id);
            }
            return id;
        }


        /// <summary>
        /// Find the matching entity in the saveMap.  This is for relationship fixup.
        /// </summary>
        /// <param name="entityType"></param>
        /// <param name="entityId"></param>
        /// <param name="saveMap"></param>
        /// <returns>The entity, or null if not found</returns>
        private object FindInSaveMap(Type entityType, object entityId, Dictionary<Type, List<EntityInfo>> saveMap)
        {
            var entityIdString = entityId.ToString();
            List<EntityInfo> entityInfoList;
            if (saveMap.TryGetValue(entityType, out entityInfoList))
            {
                var meta = session.SessionFactory.GetClassMetadata(entityType);
                foreach (var entityInfo in entityInfoList)
                {
                    var entity = entityInfo.Entity;
                    var id = meta.GetIdentifier(entity, EntityMode.Poco);
                    if (id != null && entityIdString.Equals(id.ToString())) return entity;
                }
            }
            return null;
        }


        /// <summary>
        /// Add, update, or delete the entity according to its EntityState.
        /// </summary>
        /// <param name="entityInfo"></param>
        private void ProcessEntity(EntityInfo entityInfo, IClassMetadata classMeta)
        {
            var entity = entityInfo.Entity;
            var state = entityInfo.EntityState;

            // Perform validation on the entity, based on DataAnnotations.  TODO move this to a pluggable interceptor
            var validationResults = new List<ValidationResult>();
            if (!Validator.TryValidateObject(entity, new ValidationContext(entity), validationResults, true))
            {
                ValidationResults.Add(entityInfo, validationResults);
                return;
            }

            // Restore the old value of the concurrency column so Hibernate will be able to save the entity
            if (classMeta.IsVersioned)
            {
                RestoreOldVersionValue(entityInfo, classMeta);
            }

            if (state == EntityState.Modified)
            {
                session.Update(entity);
            }
            else if (state == EntityState.Added)
            {
                session.Save(entity);
            }
            else if (state == EntityState.Deleted)
            {
                session.Delete(entity);
            }
            else
            {
                // Just re-associate the entity with the session.  Needed for many to many to get both ends into the session.
                session.Lock(entity, LockMode.None);
            }
        }

        /// <summary>
        /// Restore the old value of the concurrency column so Hibernate will save the entity.
        /// Otherwise it will complain because Breeze has already changed the value.
        /// </summary>
        /// <param name="entityInfo"></param>
        /// <param name="classMeta"></param>
        private void RestoreOldVersionValue(EntityInfo entityInfo, IClassMetadata classMeta)
        {
            var vcol = classMeta.VersionProperty;
            var vname = classMeta.PropertyNames[vcol];
            object oldVersion;
            if (entityInfo.OriginalValuesMap.TryGetValue(vname, out oldVersion))
            {
                var entity = entityInfo.Entity;
                var vtype = classMeta.PropertyTypes[vcol].ReturnedClass;
                oldVersion = Convert.ChangeType(oldVersion, vtype);     // because JsonConvert makes all integers Int64
                classMeta.SetPropertyValue(entity, vname, oldVersion, EntityMode.Poco);
            }
        }

        /// <summary>
        /// Record the value of the temporary key in EntityKeyMapping
        /// </summary>
        /// <param name="entityInfo"></param>
        private void AddKeyMapping(EntityInfo entityInfo, Type type, IClassMetadata meta)
        {
            var entity = entityInfo.Entity;
            var id = GetIdentifier(entity, meta);
            var km = new KeyMapping() { EntityTypeName = type.FullName, TempValue = id };
            EntityKeyMapping.Add(entityInfo, km);
        }

        /// <summary>
        /// Get the identifier value for the entity.  If the entity does not have an
        /// identifier property, or natural identifiers defined, then the entity itself is returned.
        /// </summary>
        /// <param name="entity"></param>
        /// <param name="meta"></param>
        /// <returns></returns>
        private object GetIdentifier(object entity, IClassMetadata meta = null)
        {
            var type = entity.GetType();
            meta = meta ?? session.SessionFactory.GetClassMetadata(type);
            if (meta.HasIdentifierProperty)
            {
                return meta.GetIdentifier(entity, EntityMode.Poco);
            }
            else if (meta.HasNaturalIdentifier)
            {
                var idprops = meta.NaturalIdentifierProperties;
                var values = meta.GetPropertyValues(entity, EntityMode.Poco);
                var idvalues = idprops.Select(i => values[i]).ToArray();
                return idvalues;
            }
            return entity;
        }

        /// <summary>
        /// Update the KeyMappings with their real values.
        /// </summary>
        /// <returns></returns>
        private List<KeyMapping> UpdateAutoGeneratedKeys()
        {
            var list = new List<KeyMapping>();
            foreach (var entityInfo in EntitiesWithAutoGeneratedKeys)
            {
                KeyMapping km;
                if (EntityKeyMapping.TryGetValue(entityInfo, out km))
                {
                    if (km.TempValue != null)
                    {
                        var entity = entityInfo.Entity;
                        var id = GetIdentifier(entity);
                        km.RealValue = id;
                        list.Add(km);
                    }
                }
            }
            return list;
        }

        /// <summary>
        /// Refresh the entities from the database.  This picks up changes due to triggers, etc.
        /// </summary>
        /// TODO make this faster
        /// TODO make this optional
        /// <param name="saveMap"></param>
        private void RefreshFromSession(Dictionary<Type, List<EntityInfo>> saveMap)
        {
            using (var tx = session.BeginTransaction())
            {
                foreach (var kvp in saveMap)
                {
                    foreach (var entityInfo in kvp.Value)
                    {
                        if (entityInfo.EntityState != EntityState.Deleted)
                            session.Refresh(entityInfo.Entity);
                    }
                }
                tx.Commit();
            }
        }


        #endregion
    }
}