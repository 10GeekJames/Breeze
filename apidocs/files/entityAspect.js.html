<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>entityAspect.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>
<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/~entityTracking-interface.html">~entityTracking-interface</a></li>
            
                <li><a href="..&#x2F;classes/~keyGenerator-interface.html">~keyGenerator-interface</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
                <li><a href="..&#x2F;modules/entityModel.html">entityModel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: entityAspect.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿
define([&quot;core&quot;, &quot;event&quot;, &quot;validate&quot;],
function (core, Event, m_validate) {
    &#x2F;**
    @module entityModel   
    **&#x2F;

    var Enum = core.Enum;
    var assertParam = core.assertParam;

    var Validator = m_validate.Validator;
    var ValidationError = m_validate.ValidationError;

    var EntityState = (function () {
        &#x2F;**
        EntityState is an &#x27;Enum&#x27; containing all of the valid states for an &#x27;Entity&#x27;.

        @class EntityState
        @static
        **&#x2F;
        var entityStateMethods = {
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isUnchanged();
            is the same as
            @example
                return es === EntityState.Unchanged;
            @method isUnchanged
            @return Whether an entityState instance is EntityState.Unchanged.
            **&#x2F;
            isUnchanged: function () { return this === EntityState.Unchanged; },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isAdded();
            is the same as
            @example
                return es === EntityState.Added;
            @method isAdded
            @return Whether an entityState instance is EntityState.Added.
            **&#x2F;
            isAdded: function () { return this === EntityState.Added; },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isModified();
            is the same as
            @example
                return es === EntityState.Modified;
            @method isModified
            @return Whether an entityState instance is EntityState.Modified.
            **&#x2F;
            isModified: function () { return this === EntityState.Modified; },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isDeleted();
            is the same as
            @example
                return es === EntityState.Deleted;
            @method isDeleted
            @return Whether an entityState instance is EntityState.Deleted.
            **&#x2F;
            isDeleted: function () { return this === EntityState.Deleted; },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isDetached();
            is the same as
            @example
                return es === EntityState.Detached;
            @method isDetached
            @return Whether an entityState instance is EntityState.Detached.
            **&#x2F;
            isDetached: function () { return this === EntityState.Detached; },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isUnchangedOrModified();
            is the same as
            @example
                return es === EntityState.Unchanged || es === EntityState.Modified
            @method isUnchangedOrModified
            @return Whether an entityState instance is EntityState.Unchanged or EntityState.Modified.
            **&#x2F;
            isUnchangedOrModified: function () {
                return this === EntityState.Unchanged || this === EntityState.Modified;
            },
            &#x2F;**
            @example
                var es = anEntity.entityAspect.entityState;
                return es.isAddedModifiedOrDeleted();
            is the same as
            @example
                return es === EntityState.Added || es === EntityState.Modified || es === EntityState.Deleted
            @method isAddedModifiedOrDeleted
            @return Whether an entityState instance is EntityState.Unchanged or EntityState.Modified or EntityState.Deleted.
            **&#x2F;
            isAddedModifiedOrDeleted: function () {
                return this === EntityState.Added ||
                    this === EntityState.Modified ||
                    this === EntityState.Deleted;
            }
        };

        var EntityState = new Enum(&quot;EntityState&quot;, entityStateMethods);
        &#x2F;**
        The &#x27;Unchanged&#x27; state.

        @property Unchanged {symbol}
        @final
        @static
        **&#x2F;
        EntityState.Unchanged = EntityState.addSymbol();
        &#x2F;**
        The &#x27;Added&#x27; state.

        @property Added {symbol}
        @final
        @static
        **&#x2F;
        EntityState.Added = EntityState.addSymbol();
        &#x2F;**
        The &#x27;Modified&#x27; state.

        @property Modified {symbol}
        @final
        @static
        **&#x2F;
        EntityState.Modified = EntityState.addSymbol();
        &#x2F;**
        The &#x27;Deleted&#x27; state.

        @property Deleted {symbol}
        @final
        @static
        **&#x2F;
        EntityState.Deleted = EntityState.addSymbol();
        &#x2F;**
        The &#x27;Detached&#x27; state.

        @property Detached {symbol}
        @final
        @static
        **&#x2F;
        EntityState.Detached = EntityState.addSymbol();
        EntityState.seal();
        return EntityState;
    })();
    
    var EntityAction = (function () {
        &#x2F;**
        EntityAction is an &#x27;Enum&#x27; containing all of the valid actions that can occur to an &#x27;Entity&#x27;.

        @class EntityAction
        @static
        **&#x2F;
        var entityActionMethods = {
            isAttach: function () { return !!this.isAttach; },
            isDetach: function () { return !!this.isDetach; },
            isModification: function () { return !!this.isModification; }
        };

        var EntityAction = new Enum(&quot;EntityAction&quot;, entityActionMethods);
        
        &#x2F;**
        Attach - Entity was attached via an AttachEntity call.

        @property Attach {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.Attach = EntityAction.addSymbol({ isAttach: true});
        
        &#x2F;**
        AttachOnQuery - Entity was attached as a result of a query.

        @property AttachOnQuery {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.AttachOnQuery = EntityAction.addSymbol({ isAttach: true});
        
        &#x2F;**
        AttachOnImport - Entity was attached as a result of an import.

        @property AttachOnImport {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.AttachOnImport = EntityAction.addSymbol({ isAttach: true});
        
        
        &#x2F;**
        AttachOnQuery - Entity was detached.

        @property Detach {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.Detach = EntityAction.addSymbol( { isDetach: true });
        
        &#x2F;**
        MergeOnQuery - Properties on the entity were merged as a result of a query.

        @property MergeOnQuery {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.MergeOnQuery = EntityAction.addSymbol( { isModification: true });
        
        &#x2F;**
        MergeOnImport - Properties on the entity were merged as a result of an import.

        @property MergeOnImport {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.MergeOnImport = EntityAction.addSymbol( { isModification: true });
        
        &#x2F;**
        MergeOnImport - Properties on the entity were merged as a result of a save

        @property MergeOnImport {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.MergeOnSave = EntityAction.addSymbol( { isModification: true });
        
        &#x2F;**
        PropertyChange - A property on the entity was changed.

        @property PropertyChange {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.PropertyChange = EntityAction.addSymbol({ isModification: true});
        
        &#x2F;**
        EntityStateChange - The EntityState of the entity was changed.

        @property EntityStateChange {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.EntityStateChange = EntityAction.addSymbol();
        
        
        &#x2F;**
        AcceptChanges - AcceptChanges was called on the entity, or its entityState was set to Unmodified.

        @property AcceptChanges {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.AcceptChanges = EntityAction.addSymbol();

        &#x2F;**
        RejectChanges - RejectChanges was called on the entity.

        @property RejectChanges {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.RejectChanges = EntityAction.addSymbol({ isModification: true});
        
        &#x2F;**
        Clear - The EntityManager was cleared.  All entities detached.

        @property Clear {symbol}
        @final
        @static
        **&#x2F;
        EntityAction.Clear = EntityAction.addSymbol({ isDetach: true});
        
        EntityAction.seal();
        return EntityAction;
    })();

    var EntityAspect = function () {
        &#x2F;**
        An EntityAspect instance is associated with every attached entity and is accessed via the entity&#x27;s &#x27;entityAspect&#x27; property. 

        The EntityAspect itself provides properties to determine and modify the EntityState of the entity and has methods 
        that provide a variety of services including validation and change tracking.

        An EntityAspect will almost never need to be constructed directly. You will usually get an EntityAspect by accessing
        an entities &#x27;entityAspect&#x27; property.  This property will be automatically attached when an entity is created via either 
        a query, import or EntityManager.createEntity call.
        
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var aspect = order.entityAspect;
            var currentState = aspect.entityState;
        @class EntityAspect
        **&#x2F;
        var ctor = function (entity) {
            if (!entity) {
                throw new Error(&quot;The EntityAspect ctor requires an entity as its only argument.&quot;);
            }
            if (entity.entityAspect) {
                return entity.entityAspect;
            }
            &#x2F;&#x2F; if called without new
            if (!(this instanceof EntityAspect)) {
                return new EntityAspect(entity);
            }

            &#x2F;&#x2F; entityType should already be on the entity from &#x27;watch&#x27;
            this.entity = entity;
            entity.entityAspect = this;

            &#x2F;&#x2F; TODO: keep public or not?
            this.entityGroup = null;
            this.entityManager = null;
            this.entityState = EntityState.Detached;
            this.isBeingSaved = false;
            this.originalValues = {};
            this._validationErrors = {};
            this.validationErrorsChanged = new Event(&quot;validationErrorsChanged&quot;);
            this.propertyChanged = new Event(&quot;propertyChanged&quot;);
            var entityType = entity.entityType;
            if (!entityType) {
                var typeName = entity.prototype._$typeName;
                if (!typeName) {
                    throw new Error(&quot;This entity is not registered as a valid EntityType&quot;);
                } else {
                    throw new Error(&quot;Metadata for this entityType has not yet been resolved: &quot; + typeName);
                }
            }
            var entityCtor = entityType.getEntityCtor();
            core.config.trackingImplementation.startTracking(entity, entityCtor.prototype);
            var initFn = entityCtor._$initializationFn;
            if (initFn) {
                if (typeof initFn === &quot;string&quot;) {
                    entity[initFn](entity);
                } else {
                    entityCtor._$initializationFn(entity);
                }
            }
            
        };

        &#x2F;**
        The Entity that this aspect is associated with.

        __readOnly__
        @property entity {Entity} 
        **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}} that contains this entity.

        __readOnly__
        @property entityManager {EntityManager}
        **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;EntityState&quot;}}{{&#x2F;crossLink}} of this entity.

        __readOnly__
        @property entityState {EntityState}
        **&#x2F;
        
          &#x2F;**
        Whether this entity is in the process of being saved.

        __readOnly__
        @property isBeingSaved {Boolean}
        **&#x2F;

        &#x2F;**
        The &#x27;original values&#x27; of this entity where they are different from the &#x27;current values&#x27;. 
        This is a map where the key is a property name and the value is the &#x27;original value&#x27; of the property.

        __readOnly__
        @property originalValues {Object} 
        **&#x2F;

        &#x2F;**
        An {{#crossLink &quot;Event&quot;}}{{&#x2F;crossLink}} that fires whenever a value of one of this entity&#x27;s properties change.
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            order.entityAspect.propertyChanged.subscribe(
                function (propertyChangedArgs) {
                    &#x2F;&#x2F; this code will be executed anytime a property value changes on the &#x27;order&#x27; entity.
                    var entity = propertyChangedArgs.entity; &#x2F;&#x2F; Note: entity === order
                    var propertyNameChanged = propertyChangedArgs.propertyName;
                    var oldValue = propertyChangedArgs.oldValue;
                    var newValue = propertyChangedArgs.newValue;
                });
        @event propertyChanged 
        @param entity {Entity} The entity whose property is changing.
        @param propertyName {String} The property that changed. This value will be &#x27;null&#x27; for operations that replace the entire entity.  This includes
        queries, imports and saves that require a merge. The remaining parameters will not exist in this case either.
        @param oldValue {Object} The old value of this property before the change.
        @param newValue {Object} The new value of this property after the change.
        @readOnly
        **&#x2F;

        &#x2F;**
        An {{#crossLink &quot;Event&quot;}}{{&#x2F;crossLink}} that fires whenever any of the validation errors on this entity change. 
        Note that this might be the removal of an error when some data on the entity is fixed. 
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            order.entityAspect.validationErrorsChanged.subscribe(
                function (validationChangeArgs) {
                    &#x2F;&#x2F; this code will be executed anytime a property value changes on the &#x27;order&#x27; entity.
                    var entity == validationChangeArgs.entity; &#x2F;&#x2F; Note: entity === order
                    var errorsAdded = validationChangeArgs.added;
                    var errorsCleared = validationChangeArgs.removed;
                });
        @event validationErrorsChanged 
        @param entity {Entity} The entity on which the validation errors are being added or removed.
        @param added {Array of ValidationError} An array containing any newly added {{#crossLink &quot;ValidationError&quot;}}{{&#x2F;crossLink}}s
        @param removed {Array of ValidationError} An array containing any newly removed {{#crossLink &quot;ValidationError&quot;}}{{&#x2F;crossLink}}s. This is those
        errors that have been &#x27;fixed&#x27;
        @readOnly
        **&#x2F;

        &#x2F;**
        Returns the {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}} for this Entity. 
        @example
             &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var entityKey = order.entityAspect.getKey();
        @method getKey
        @param [forceRefresh = false] {Boolean} Forces the recalculation of the key.  This should normally be unnecessary.
        @return {EntityKey} The {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}} associated with this Entity.
        **&#x2F;
        ctor.prototype.getKey = function (forceRefresh) {
            forceRefresh = core.assertParam(forceRefresh, &quot;forceRefresh&quot;).isBoolean().isOptional().check(false);
            if (forceRefresh || !this._entityKey) {
                var entityType = this.entity.entityType;
                var keyProps = entityType.keyProperties;
                var values = keyProps.map(function (p) {
                    return this.entity.getProperty(p.name);
                }, this);
                this._entityKey = new EntityKey(entityType, values);
            }
            return this._entityKey;
        };

        &#x2F;**
        Returns the entity to an {{#crossLink &quot;EntityState&quot;}}{{&#x2F;crossLink}} of &#x27;Unchanged&#x27; by committing all changes made since the entity was last queried 
        had &#x27;acceptChanges&#x27; called on it. 
        @example
             &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
             order.entityAspect.acceptChanges();
             &#x2F;&#x2F; The &#x27;order&#x27; entity will now be in an &#x27;Unchanged&#x27; state with any changes committed.
        @method acceptChanges
        **&#x2F;
        ctor.prototype.acceptChanges = function () {
            this.setUnchanged();
            if (this.entityManager.entityChangeNotificationEnabled) {
                this.entityManager.entityChanged.publish({ entityAction: EntityAction.AcceptChanges, entity: this.entity });
            }
        };

        &#x2F;**
        Returns the entity to an EntityState of &#x27;Unchanged&#x27; by rejecting all changes made to it since the entity was last queried 
        had &#x27;rejectChanges&#x27; called on it. 
        @example
             &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
             order.entityAspect.rejectChanges();
             &#x2F;&#x2F; The &#x27;order&#x27; entity will now be in an &#x27;Unchanged&#x27; state with any changes rejected. 
        @method rejectChanges
        **&#x2F;
        ctor.prototype.rejectChanges = function () {
            var originalValues = this.originalValues;
            var entity = this.entity;
            for (var propName in originalValues) {
                entity.setProperty(propName, originalValues[propName]);
            }
            if (this.entityState.isAdded()) {
                this.entityManager.detachEntity(entity);
            } else {
                this.setUnchanged();
                if (this.entityManager.entityChangeNotificationEnabled) {
                    this.entityManager.entityChanged.publish({ entityAction: EntityAction.RejectChanges, entity: entity });
                }
            }
        };

        &#x2F;**
        Sets the entity to an EntityState of &#x27;Unchanged&#x27;.  This is also the equivalent of calling {{#crossLink &quot;EntityAspect&#x2F;acceptChanges&quot;}}{{&#x2F;crossLink}}
         @example
             &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
             order.entityAspect.setUnchanged();
             &#x2F;&#x2F; The &#x27;order&#x27; entity will now be in an &#x27;Unchanged&#x27; state with any changes committed.
        @method setUnchanged
        **&#x2F;
        ctor.prototype.setUnchanged = function () {
            this.originalValues = {};
            delete this.hasTempKey;
            this.entityState = EntityState.Unchanged;
            if (this.entityManager.entityChangeNotificationEnabled) {
                this.entityManager.entityChanged.publish({ entityAction: EntityAction.EntityStateChange, entity: this.entity });
            }
        };

        &#x2F;&#x2F; Dangerous method - see notes - talk to Jay - this is not a complete impl
        &#x2F;&#x2F;        ctor.prototype.setAdded = function () {
        &#x2F;&#x2F;            this.originalValues = {};
        &#x2F;&#x2F;            this.entityState = EntityState.Added;
        &#x2F;&#x2F;            if (this.entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
        &#x2F;&#x2F;                this.entityManager.generateTempKeyValue(this.entity);
        &#x2F;&#x2F;            }
        &#x2F;&#x2F;        };

        &#x2F;**
        Sets the entity to an EntityState of &#x27;Modified&#x27;.  This can also be achieved by changing the value of any property on an &#x27;Unchanged&#x27; entity.
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            order.entityAspect.setModified();
            &#x2F;&#x2F; The &#x27;order&#x27; entity will now be in a &#x27;Modified&#x27; state. 
        @method setModified
        **&#x2F;
        ctor.prototype.setModified = function () {
            this.entityState = EntityState.Modified;
            if (this.entityManager.entityChangeNotificationEnabled) {
                this.entityManager.entityChanged.publish({ entityAction: EntityAction.EntityStateChange, entity: this.entity });
            }
        };

        &#x2F;**
        Sets the entity to an EntityState of &#x27;Deleted&#x27;.  This both marks the entity as being scheduled for deletion during the next &#x27;Save&#x27; call
        but also removes the entity from all of its related entities. 
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            order.entityAspect.setDeleted();
            &#x2F;&#x2F; The &#x27;order&#x27; entity will now be in a &#x27;Deleted&#x27; state and it will no longer have any &#x27;related&#x27; entities. 
        @method setDeleted
        **&#x2F;
        ctor.prototype.setDeleted = function () {
            if (this.entityState.isAdded()) {
                this.entityManager.detachEntity(this.entity);
            } else {
                this.entityState = EntityState.Deleted;
                this._removeFromRelations();
                if (this.entityManager.entityChangeNotificationEnabled) {
                    this.entityManager.entityChanged.publish({ entityAction: EntityAction.EntityStateChange, entity: this.entity });
                }
            }
            &#x2F;&#x2F; TODO: think about cascade deletes
        };

        &#x2F;**
        Performs validation on the entity, any errors encountered during the validation are available via the 
        {{#crossLink &quot;EntityAspect.getValidationErrors&quot;}}{{&#x2F;crossLink}} method. Validating an entity means executing
        all of the validators on both the entity itself as well as those on each of its properties.
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var isOk = order.entityAspect.validateEntity();
            &#x2F;&#x2F; isOk will be &#x27;true&#x27; if there are no errors on the entity.
            if (!isOk) {
                var errors = order.entityAspect.getValidationErrors();
            }
        @method validateEntity
        @return {Boolean} Whether the entity passed validation.
        **&#x2F;
        ctor.prototype.validateEntity = function () {
            var ok = true;
            var entityType = this.entity.entityType;
            this._processValidationOpAndPublish(function (that) {
                &#x2F;&#x2F; property level first
                entityType.getProperties().forEach(function (p) {
                    var value = that.entity.getProperty(p.name);
                    if (p.validators.length &gt; 0) {
                        ok = that._validateProperty(p, value) &amp;&amp; ok;
                    }
                });
                &#x2F;&#x2F; then entity level
                entityType.validators.forEach(function (validator) {
                    ok = validate(that, validator, that.entity) &amp;&amp; ok;
                });
            });

            return ok;
        };

        &#x2F;**
        Performs validation on a specific property of this entity, any errors encountered during the validation are available via the 
        {{#crossLink &quot;EntityAspect.getValidationErrors&quot;}}{{&#x2F;crossLink}} method. Validating a property means executing
        all of the validators on the specified property.  This call is also made automatically anytime a property
        of an entity is changed.
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var isOk = order.entityAspect.validateProperty(&quot;Order&quot;); 
        or
        @example
            var orderDateProperty = order.entityType.getProperty(&quot;OrderDate&quot;);
            var isOk = order.entityAspect.validateProperty(OrderDateProperty); 
        @method validateProperty
        @param property {DataProperty|NavigationProperty} The {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} or 
        {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}} to validate.
        @param [context] {Object} A context object used to pass additional information to each  {{#crossLink &quot;Validator&quot;}}{{&#x2F;crossLink}}
        @return {Boolean} Whether the entity passed validation.
        **&#x2F;
        ctor.prototype.validateProperty = function (property, context) {
            assertParam(property, &quot;property&quot;).isString().or().isEntityProperty().check();
            if (typeof (property) === &#x27;string&#x27;) {
                property = this.entity.entityType.getProperty(property, true);
            }

            var value = this.entity.getProperty(property.name);
            return this._validateProperty(property, value, context);
        };

        &#x2F;**
        Returns the validation errors associated with either the entire entity or any specified property.
        @example
        This method can return all of the errors for an Entity
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var valErrors = order.entityAspect.getValidationErrors();
        as well as those for just a specific property.
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var orderDateErrors = order.entityAspect.getValidationErrors(&quot;OrderDate&quot;);
        which can also be expressed as
        @example
            &#x2F;&#x2F; assume order is an order entity attached to an EntityManager.
            var orderDateProperty = order.entityType.getProperty(&quot;OrderDate&quot;);
            var orderDateErrors = order.entityAspect.getValidationErrors(orderDateProperty);
        @method getValidationErrors
        @param [property] {DataProperty|NavigationProperty} The property for which validation errors should be retrieved.
        If omitted, all of the validation errors for this entity will be returned.
        @return {Array of ValidationError}
        **&#x2F;
        ctor.prototype.getValidationErrors = function (property) {
            assertParam(property, &quot;property&quot;).isOptional().isEntityProperty().or().isString();
            var result = core.getOwnPropertyValues(this._validationErrors);
            if (property) {
                var propertyName = typeof (property) === &#x27;string&#x27; ? property : property.name;
                result = result.filter(function (ve) {
                    return (ve.property.name === propertyName);
                });
            }
            return result;
        };

        &#x2F;**
        Adds a validation error for a specified property.
        @method addValidationError
        @param validationError {ValidationError} 
        **&#x2F;
        ctor.prototype.addValidationError = function (validationError) {
            assertParam(validationError, &quot;validationError&quot;).isInstanceOf(ValidationError).check();
            this._processValidationOpAndPublish(function (that) {
                that._addValidationError(validationError);
            });
        };

        &#x2F;**
        Removes a validation error for a specified property.
        @method removeValidationError
        @param validator {Validator}
        @param [property] {DataProperty|NavigationProperty}
        **&#x2F;
        ctor.prototype.removeValidationError = function (validator, property) {
            assertParam(validator, &quot;validator&quot;).isString().or().isInstanceOf(Validator).check();
            assertParam(property, &quot;property&quot;).isOptional().isEntityProperty();
            this._processValidationOpAndPublish(function (that) {
                that._removeValidationError(validator, property);
            });
        };

        &#x2F;**
        Performs a query for the value of a specified {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}.
        @example
               emp.entityAspect.loadNavigationProperty(&quot;Orders&quot;)
                .then(function (data) {
                    var orders = data.results;
                }).fail(function (exception) {
                    &#x2F;&#x2F; handle exception here;
                });
        @method loadNavigationProperty
        @async
        @param navigationProperty {NavigationProperty} The NavigationProperty to &#x27;load&#x27;.
        @param [callback] {Function} Function to call on success.
        @param [errorCallback] {Function} Function to call on failure.
        @return {Promise} 
        **&#x2F;
        &#x2F;&#x2F; This method is provided in entityQuery.js.
        &#x2F;&#x2F; ctor.prototype.loadNavigationProperty = function(navigationProperty, callback, errorCallback) 

        &#x2F;&#x2F; returns null for np&#x27;s that do not have a parentKey
        ctor.prototype.getParentKey = function (navigationProperty) {
            &#x2F;&#x2F; NavigationProperty doesn&#x27;t yet exist
            &#x2F;&#x2F; core.assertParam(navigationProperty, &quot;navigationProperty&quot;).isInstanceOf(NavigationProperty).check();
            var fkNames = navigationProperty.foreignKeyNames;
            if (!fkNames) return null;
            var that = this;
            var fkValues = fkNames.map(function (fkn) {
                return that.entity.getProperty(fkn);
            });
            return new EntityKey(navigationProperty.entityType, fkValues);
        };

        &#x2F;&#x2F; internal methods

        ctor.prototype._removeFromRelations = function () {
            var entity = this.entity;

            &#x2F;&#x2F; remove this entity from any collections.
            &#x2F;&#x2F; mark the entity deleted
            entity.entityType.navigationProperties.forEach(function (np) {
                var inverseNp = np.inverse;
                if (!inverseNp) return;
                var npValue = entity.getProperty(np.name);
                if (np.isScalar) {
                    if (npValue) {
                        if (inverseNp.isScalar) {
                            npValue.setProperty(inverseNp.name, null);
                        } else {
                            var collection = npValue.getProperty(inverseNp.name);
                            if (collection.length) {
                                core.arrayRemoveItem(collection, entity);
                            }
                        }
                    }
                } else {
                    &#x2F;&#x2F; npValue is a live list so we need to copy it first.
                    npValue.slice(0).forEach(function (v) {
                        if (inverseNp.isScalar) {
                            v.setProperty(inverseNp.name, null);
                        } else {
                            &#x2F;&#x2F; TODO: many to many - not yet handled.
                        }
                    });
                    &#x2F;&#x2F; now clear it.
                    npValue.length = 0;
                }
            });

        };

        &#x2F;&#x2F; called from defaultInterceptor.
        ctor.prototype._validateProperty = function (property, value, context) {
            var ok = true;
            this._processValidationOpAndPublish(function (that) {
                if (context) {
                    context.property = property;
                } else {
                    context = { property: property };
                }
                property.validators.forEach(function (validator) {
                    ok = ok &amp;&amp; validate(that, validator, value, context);
                });
            });
            return ok;
        };

        ctor.prototype._processValidationOpAndPublish = function (validationFn) {
            if (this._pendingValidationResult) {
                &#x2F;&#x2F; only top level processValidations call publishes
                validationFn(this);
            } else {
                try {
                    this._pendingValidationResult = { entity: this.entity, added: [], removed: [] };
                    validationFn(this);
                    if (this._pendingValidationResult.added.length &gt; 0 || this._pendingValidationResult.removed.length &gt; 0) {
                        this.validationErrorsChanged.publish(this._pendingValidationResult);
                    }
                } finally {
                    this._pendingValidationResult = undefined;
                }
            }
        };

        ctor.prototype._addValidationError = function (validationError) {
            this._validationErrors[validationError.key] = validationError;
            this._pendingValidationResult.added.push(validationError);
        };

        ctor.prototype._removeValidationError = function (validator, property) {
            var key = ValidationError.getKey(validator, property);
            var valError = this._validationErrors[key];
            if (valError) {
                delete this._validationErrors[key];
                this._pendingValidationResult.removed.push(valError);
            }
        };

        function validate(aspect, validator, value, context) {
            var ve = validator.validate(value, context);
            if (ve) {
                aspect._addValidationError(ve);
                return false;
            } else {
                aspect._removeValidationError(validator, context ? context.property: null);
                return true;
            }
        }

        return ctor;

    } ();

    var EntityKey = (function () {

        var ENTITY_KEY_DELIMITER = &quot;:::&quot;;

        &#x2F;**
        An EntityKey is an object that represents the unique identity of an entity.  EntityKey&#x27;s are immutable. 

        @class EntityKey
        **&#x2F;
        
        &#x2F;** 
        Constructs a new EntityKey.  Each entity within an EntityManager will have a unique EntityKey. 
        @example
            &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
            var empType = em1.metadataStore.getEntityType(&quot;Employee&quot;);
            var entityKey = new EntityKey(empType, 1);
        EntityKey&#x27;s may also be found by calling EntityAspect.getKey()
        @example
            &#x2F;&#x2F; assume employee1 is an existing Employee entity
            var empKey = employee1.entityAspect.getKey();
        Multipart keys are created by passing an array as the &#x27;keyValues&#x27; parameter
        @example
            var empTerrType = em1.metadataStore.getEntityType(&quot;EmployeeTerritory&quot;);            
            var empTerrKey = new EntityKey(empTerrType, [ 1, 77]);
            &#x2F;&#x2F; The order of the properties in the &#x27;keyValues&#x27; array must be the same as that 
            &#x2F;&#x2F; returned by empTerrType.keyProperties
        @method &lt;ctor&gt; EntityKey
        @param entityType {EntityType} The {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} of the entity.
        @param keyValues {value|Array of values} A single value or an array of values.
        **&#x2F;
        var ctor = function (entityType, keyValues) {
            &#x2F;&#x2F; can&#x27;t ref EntityType here because of module circularity
            &#x2F;&#x2F; assertParam(entityType, &quot;entityType&quot;).isInstanceOf(EntityType);
            if (!Array.isArray(keyValues)) {
                keyValues = Array.prototype.slice.call(arguments, 1);
            }
            if (!this instanceof ctor) {
                return new ctor(entityType, keyValues);
            }
            this.entityType = entityType;
            this.values = keyValues;
            this._keyInGroup = createKeyString(keyValues);
        };
        ctor._$typeName = &quot;EntityKey&quot;;

        ctor.prototype.toJSON = function () {
            return {
                entityType: this.entityType.name,
                values: this.values
            };
        };

        ctor.fromJSON = function (json, metadataStore) {
            var et = metadataStore.getEntityType(json.entityType, true);
            return new EntityKey(et, json.values);
        };

        &#x2F;**
        Used to compare EntityKeys are determine if they refer to the same Entity.
        There is also an static version of &#x27;equals&#x27; with the same functionality. 
        @example
            &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
            var empType = em1.metadataStore.getEntityType(&quot;Employee&quot;);
            var empKey1 = new EntityKey(empType, 1);
            &#x2F;&#x2F; assume employee1 is an existing Employee entity
            var empKey2 = employee1.entityAspect.getKey();
            if (empKey1.equals(empKey2)) {
               &#x2F;&#x2F; do something  ...
            }
        @method equals
        @param entityKey {EntityKey}
        **&#x2F;
        ctor.prototype.equals = function (entityKey) {
            if (!entityKey instanceof EntityKey) return false;
            return (this.entityType === entityKey.entityType) &amp;&amp;
                core.arrayEquals(this.values, entityKey.values);
        };

        &#x2F;*
        Returns a human readable representation of this EntityKey.
        @method toString
        *&#x2F;
        ctor.prototype.toString = function () {
            return this.entityType.name + &#x27;-&#x27; + this._keyInGroup;
        };

        &#x2F;**
        Used to compare EntityKeys are determine if they refer to the same Entity. 
        There is also an instance version of &#x27;equals&#x27; with the same functionality. 
        @example
            &#x2F;&#x2F; assume em1 is an EntityManager containing a number of existing entities.
            var empType = em1.metadataStore.getEntityType(&quot;Employee&quot;);
            var empKey1 = new EntityKey(empType, 1);
            &#x2F;&#x2F; assume employee1 is an existing Employee entity
            var empKey2 = employee1.entityAspect.getKey();
            if (EntityKey.equals(empKey1, empKey2)) {
               &#x2F;&#x2F; do something  ...
            }
        @method equals
        @static
        @param k1 {EntityKey}
        @param k2 {EntityKey}
        **&#x2F;
        ctor.equals = function (k1, k2) {
            if (!k1 instanceof EntityKey) return false;
            return k1.equals(k2);
        };

        &#x2F;&#x2F; TODO: we may want to compare to default values later.
        ctor.prototype._isEmpty = function () {
            return this.values.join(&quot;&quot;).length === 0;
        };

        ctor._fromRawEntity = function (rawEntity, entityType) {
            var keyValues = entityType.keyProperties.map(function (p) {
                return rawEntity[p.nameOnServer];
            });
            return new EntityKey(entityType, keyValues);
        };



        function createKeyString(keyValues) {
            return keyValues.join(ENTITY_KEY_DELIMITER);
        }

        return ctor;
    })();

    &#x2F;&#x2F; expose

    return {
        EntityAspect: EntityAspect,
        EntityState: EntityState,
        EntityAction: EntityAction,
        EntityKey: EntityKey
    };


});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
